{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/EightQueen/EightQueen1.jpg","path":"img/EightQueen/EightQueen1.jpg","modified":0,"renderable":0},{"_id":"source/img/EightQueen/EightQueen2.jpg","path":"img/EightQueen/EightQueen2.jpg","modified":0,"renderable":0},{"_id":"source/img/EightQueen/EightQueen4.jpg","path":"img/EightQueen/EightQueen4.jpg","modified":0,"renderable":0},{"_id":"source/img/EightQueen/EightQueen3.jpg","path":"img/EightQueen/EightQueen3.jpg","modified":0,"renderable":0},{"_id":"source/img/EightQueen/EightQueen4.png","path":"img/EightQueen/EightQueen4.png","modified":0,"renderable":0},{"_id":"source/img/EightQueen/EightQueen5.jpg","path":"img/EightQueen/EightQueen5.jpg","modified":0,"renderable":0},{"_id":"source/img/EightQueen/EightQueen3.png","path":"img/EightQueen/EightQueen3.png","modified":0,"renderable":0},{"_id":"source/img/Graph/DGBFS.png","path":"img/Graph/DGBFS.png","modified":0,"renderable":0},{"_id":"source/img/Graph/DG.png","path":"img/Graph/DG.png","modified":0,"renderable":0},{"_id":"source/img/Graph/DGDFS.png","path":"img/Graph/DGDFS.png","modified":0,"renderable":0},{"_id":"source/img/Graph/DGL.png","path":"img/Graph/DGL.png","modified":0,"renderable":0},{"_id":"source/img/Graph/Topological Order 1.png","path":"img/Graph/Topological Order 1.png","modified":0,"renderable":0},{"_id":"source/img/Graph/Topological Order 2.png","path":"img/Graph/Topological Order 2.png","modified":0,"renderable":0},{"_id":"source/img/Graph/Topological Order.png","path":"img/Graph/Topological Order.png","modified":0,"renderable":0},{"_id":"source/img/Graph/Topological Order 3.png","path":"img/Graph/Topological Order 3.png","modified":0,"renderable":0},{"_id":"source/img/Graph/UDG.png","path":"img/Graph/UDG.png","modified":0,"renderable":0},{"_id":"source/img/Graph/UDGBFS.png","path":"img/Graph/UDGBFS.png","modified":0,"renderable":0},{"_id":"source/img/Graph/UDGDFS.png","path":"img/Graph/UDGDFS.png","modified":0,"renderable":0},{"_id":"source/img/Graph/UDGL.png","path":"img/Graph/UDGL.png","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/insertFix2.png","path":"img/RedBlackTree/insertFix2.png","modified":0,"renderable":0},{"_id":"source/img/SIMD/Example_SIMD.jpg","path":"img/SIMD/Example_SIMD.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/insertFix4.png","path":"img/RedBlackTree/insertFix4.png","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/insertFix3.png","path":"img/RedBlackTree/insertFix3.png","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/leftrotate.jpg","path":"img/RedBlackTree/leftrotate.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/insertFix1.png","path":"img/RedBlackTree/insertFix1.png","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/removeFix1.jpg","path":"img/RedBlackTree/removeFix1.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/rbtree.png","path":"img/RedBlackTree/rbtree.png","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/removeFix2.jpg","path":"img/RedBlackTree/removeFix2.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/removeFix4.jpg","path":"img/RedBlackTree/removeFix4.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/removeFix5.jpg","path":"img/RedBlackTree/removeFix5.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/removeFix3.jpg","path":"img/RedBlackTree/removeFix3.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/removeFix6.jpg","path":"img/RedBlackTree/removeFix6.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/removeFix7.jpg","path":"img/RedBlackTree/removeFix7.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/removeFix8.jpg","path":"img/RedBlackTree/removeFix8.jpg","modified":0,"renderable":0},{"_id":"source/img/RedBlackTree/rightrotate.jpg","path":"img/RedBlackTree/rightrotate.jpg","modified":0,"renderable":0},{"_id":"source/img/PythonSort/3.gif","path":"img/PythonSort/3.gif","modified":0,"renderable":0},{"_id":"source/img/PythonSort/5.gif","path":"img/PythonSort/5.gif","modified":0,"renderable":0},{"_id":"themes/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/img/PythonSort/2.gif","path":"img/PythonSort/2.gif","modified":0,"renderable":0},{"_id":"source/img/PythonSort/6.gif","path":"img/PythonSort/6.gif","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/BRDF_02.png","path":"img/Graphics/PBR/BRDF_02.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/BRDF_03.png","path":"img/Graphics/PBR/BRDF_03.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/BRDF_01.png","path":"img/Graphics/PBR/BRDF_01.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/BRDF_04.png","path":"img/Graphics/PBR/BRDF_04.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_00.png","path":"img/Graphics/PBR/The_Reflection_Equation_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_02.png","path":"img/Graphics/PBR/The_Reflection_Equation_02.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_03.png","path":"img/Graphics/PBR/The_Reflection_Equation_03.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_04.png","path":"img/Graphics/PBR/The_Reflection_Equation_04.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_01.png","path":"img/Graphics/PBR/Threoy_of_PBR_01.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_03.png","path":"img/Graphics/PBR/Threoy_of_PBR_03.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_02.png","path":"img/Graphics/PBR/Threoy_of_PBR_02.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_04.png","path":"img/Graphics/PBR/Threoy_of_PBR_04.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/微信图片_20180805233454.jpg","path":"img/Graphics/PBR/微信图片_20180805233454.jpg","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_7.png","path":"img/Graphics/RayTracing/RayTracing_7.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/Ray_triangle_Intersection_00.png","path":"img/Graphics/RayTracing/Ray_triangle_Intersection_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_9.png","path":"img/Graphics/RayTracing/RayTracing_9.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/epslion_problem_00.png","path":"img/Graphics/RayTracing/epslion_problem_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/lighting_and_matrials_00.png","path":"img/Graphics/RayTracing/lighting_and_matrials_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/lighting_and_matrials_02.png","path":"img/Graphics/RayTracing/lighting_and_matrials_02.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/lighting_and_matrials_01.png","path":"img/Graphics/RayTracing/lighting_and_matrials_01.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/ray_00.png","path":"img/Graphics/RayTracing/ray_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/ray_01.png","path":"img/Graphics/RayTracing/ray_01.png","modified":0,"renderable":0},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/styles.css","path":"libs/open-sans/styles.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/images/avatar.jpg","path":"css/images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/images/logo.jpg","path":"css/images/logo.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":0,"renderable":1},{"_id":"source/img/Graphics/PBR/PBR_0.png","path":"img/Graphics/PBR/PBR_0.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_01.png","path":"img/Graphics/PBR/The_Reflection_Equation_01.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_1.png","path":"img/Graphics/RayTracing/RayTracing_1.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_5.png","path":"img/Graphics/RayTracing/RayTracing_5.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/Ray_box_Intersection_00.png","path":"img/Graphics/RayTracing/Ray_box_Intersection_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/PBR/BRDF_00.png","path":"img/Graphics/PBR/BRDF_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_0.png","path":"img/Graphics/RayTracing/RayTracing_0.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_3.png","path":"img/Graphics/RayTracing/RayTracing_3.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_4.png","path":"img/Graphics/RayTracing/RayTracing_4.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_6.png","path":"img/Graphics/RayTracing/RayTracing_6.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_8.png","path":"img/Graphics/RayTracing/RayTracing_8.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/ray_02.png","path":"img/Graphics/RayTracing/ray_02.png","modified":0,"renderable":0},{"_id":"source/img/PythonSort/4.gif","path":"img/PythonSort/4.gif","modified":0,"renderable":0},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":0,"renderable":1},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_00.png","path":"img/Graphics/PBR/Threoy_of_PBR_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/DoRayTracing_00.png","path":"img/Graphics/RayTracing/DoRayTracing_00.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/DoRayTracing_01.png","path":"img/Graphics/RayTracing/DoRayTracing_01.png","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/epslion_problem_01.png","path":"img/Graphics/RayTracing/epslion_problem_01.png","modified":0,"renderable":0},{"_id":"source/img/about_img/EL_3.PNG","path":"img/about_img/EL_3.PNG","modified":0,"renderable":0},{"_id":"source/img/about_img/PA_0.PNG","path":"img/about_img/PA_0.PNG","modified":0,"renderable":0},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/libs/jquery/2.1.3/jquery.min.js","path":"libs/jquery/2.1.3/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/about_img/EL_4.PNG","path":"img/about_img/EL_4.PNG","modified":0,"renderable":0},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/img/Graphics/RayTracing/RayTracing_2.png","path":"img/Graphics/RayTracing/RayTracing_2.png","modified":0,"renderable":0},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/img/about_img/EL_1.PNG","path":"img/about_img/EL_1.PNG","modified":0,"renderable":0},{"_id":"source/img/Graphics/RayTracing/RayTracing_10.png","path":"img/Graphics/RayTracing/RayTracing_10.png","modified":0,"renderable":0},{"_id":"source/img/PythonSort/1.gif","path":"img/PythonSort/1.gif","modified":0,"renderable":0},{"_id":"source/img/about_img/EL_2.PNG","path":"img/about_img/EL_2.PNG","modified":0,"renderable":0},{"_id":"source/img/about_img/EL_0.PNG","path":"img/about_img/EL_0.PNG","modified":0,"renderable":0},{"_id":"source/file/lec09_ray_tracing.pdf","path":"file/lec09_ray_tracing.pdf","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"94b8e7f47adc55215f98ae44acf23612714e185f","modified":1519822521385},{"_id":"themes/hexo-theme-icarus/.gitignore","hash":"ece1c3037855e866d5816467cdfb2cef4e36e0a7","modified":1519919449984},{"_id":"themes/hexo-theme-icarus/LICENSE","hash":"73ed09aa00f7bda6319fc7d5b722fb40e0c2017e","modified":1519919449984},{"_id":"themes/hexo-theme-icarus/_config.yml","hash":"5101c78a47fbff8bec260955baadb4bebbfd9d11","modified":1530794429997},{"_id":"themes/hexo-theme-icarus/README.md","hash":"c2407cbda23f087be719d6dc3f7207a8e01ffd73","modified":1519919449985},{"_id":"themes/hexo-theme-icarus/package.json","hash":"c156985c2689895a228188a29ceaae8f7d0bb34f","modified":1519919450007},{"_id":"source/_posts/Adjacency-List-Graph.md","hash":"d0b9b88ec230a3112a1efaa2b452a0fac76e429a","modified":1520438649114},{"_id":"source/about/index.md","hash":"0e5ab71479f994e6e8469785f0f2dca9a19992b6","modified":1535291609674},{"_id":"source/_posts/BRDF.md","hash":"89281196bea16174d549dd3f6dd361a053db5c93","modified":1531660301832},{"_id":"source/_posts/Adjacency-Matrix-Graph.md","hash":"1fa77a62786dc2c882e389c86ed19fec5d477b0b","modified":1520438625627},{"_id":"source/_posts/Breadth-First-Search.md","hash":"e7d2814722062d21b881dabbee87c230eb6115af","modified":1520438670235},{"_id":"source/_posts/Basic-Graph-Theory.md","hash":"7c5f1e324b132a890c7f787deba27f8ea4a3a590","modified":1520438792906},{"_id":"source/_posts/Depth-First-Search.md","hash":"618d1346e87dbf39a2ce28251b0dfdf0dec512f5","modified":1520438688770},{"_id":"source/_posts/Lighting_and_Materials.md","hash":"e656cd319a0f77ce173960da88ff0c1b875a7257","modified":1531207742512},{"_id":"source/_posts/Do-Ray-Tracing.md","hash":"8b37166038bb33f54caaf9f8d0ef52d7048b98a9","modified":1531207722935},{"_id":"source/_posts/N-Queens-Problem.md","hash":"b7632f554b73d618d22a944ea6c3254ba3663430","modified":1520606580190},{"_id":"source/_posts/Ray-Tracing-Catalogue.md","hash":"f400f3c412193a0b4f3120a70a08285e930a962c","modified":1531207481125},{"_id":"source/_posts/Physically-Based-Rendering-Catalogue.md","hash":"79157a06e94fe70b311f4aca1369cd23223b9df1","modified":1531318314960},{"_id":"source/_posts/Ray-and-Camera.md","hash":"f44b96bee344626370f52e9a151ee2486b9c8da4","modified":1531207713479},{"_id":"source/_posts/RedBlackTree-II.md","hash":"0b0503ba5c85a397318dd617982342945edc9953","modified":1520087057860},{"_id":"source/_posts/RedBlackTree-I.md","hash":"5f4474b4081620f86dfe010e9f8e47c304b80c13","modified":1520087027253},{"_id":"source/_posts/RedBlackTree-III.md","hash":"08f2bbe58ec708c36833df108141419cd127b1d9","modified":1520258403085},{"_id":"source/_posts/SSE-Instruction-List.md","hash":"f34ceb8508a7d7c806ca8e4542ef0d6a5624eca2","modified":1522075820776},{"_id":"source/_posts/Sorting-Algorithm.md","hash":"d7761a9dcedfa9b835ab57d0db44d1574596ebdb","modified":1520660089563},{"_id":"source/_posts/The-Reflectance-Equation.md","hash":"6aba820bcd18acb51fd81adb463d3946237a53a9","modified":1531321458934},{"_id":"source/_posts/Theory-of-PBR.md","hash":"f67fd97d9d9d1009a4246db68f1f08af6d08410f","modified":1531235737795},{"_id":"source/_posts/Topological-Sort.md","hash":"9e46946724f8ba13f552b72d441edc0fad4205a6","modified":1520512996271},{"_id":"source/_posts/Various-surfaces.md","hash":"784e1b1a91ebab248b50094df6913f1840e82b18","modified":1531207704711},{"_id":"source/_posts/Theory-of-Ray-Tracing.md","hash":"2eb8ce19bb756732956a06b5628acfeeaae5167c","modified":1531207680431},{"_id":"themes/hexo-theme-icarus/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1519919449971},{"_id":"themes/hexo-theme-icarus/.git/config","hash":"7b9dd27b1a850e883885c30b03f2abbc794137fd","modified":1519919449976},{"_id":"themes/hexo-theme-icarus/.git/index","hash":"bb9c0ed74333d24520e0030448754c5317354b3a","modified":1519919450079},{"_id":"themes/hexo-theme-icarus/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1519919052269},{"_id":"themes/hexo-theme-icarus/.git/packed-refs","hash":"9aba972945bd38696eb833224c10b8d449567035","modified":1519919449967},{"_id":"themes/hexo-theme-icarus/.github/ISSUE_TEMPLATE.md","hash":"2ea8f838582b199302121509c750bebb0ae1fb0f","modified":1519919449984},{"_id":"themes/hexo-theme-icarus/languages/en.yml","hash":"2b888a89957e07f440452a12ef338af979abb4c6","modified":1519919449987},{"_id":"themes/hexo-theme-icarus/languages/es.yml","hash":"f48b21e020b48a38747a5cd0a2c853d717ad8a7f","modified":1519919449987},{"_id":"themes/hexo-theme-icarus/languages/fr.yml","hash":"7b386bf21226433cb7da7989aba07ce33da5b359","modified":1519919449987},{"_id":"themes/hexo-theme-icarus/languages/ja.yml","hash":"e13df67ba3666c0d95d60c081e41fb86f6f48663","modified":1519919449988},{"_id":"themes/hexo-theme-icarus/languages/id.yml","hash":"83021037b6dad8dd48f48e3b4a822d07d56fc272","modified":1519919449988},{"_id":"themes/hexo-theme-icarus/languages/ko.yml","hash":"5e6e5b5d20c940cf0be26957f3a3f6a141f338e0","modified":1519919449988},{"_id":"themes/hexo-theme-icarus/languages/pt-BR.yml","hash":"3cf767f94766ac3a93d6efb9ef954e20d16b2b44","modified":1519919449989},{"_id":"themes/hexo-theme-icarus/languages/ru.yml","hash":"7423608a9608766ab5998d6b8d3e8d76b792e30e","modified":1519919449989},{"_id":"themes/hexo-theme-icarus/languages/zh-CN.yml","hash":"fdce6e6716768cfac9355c4e88a05260efeeae1c","modified":1519919449989},{"_id":"themes/hexo-theme-icarus/languages/tr.yml","hash":"50d94b21e1838db1214f6874f4f81b47c8c521db","modified":1519919449989},{"_id":"themes/hexo-theme-icarus/layout/categories.ejs","hash":"7be3918bcfb9f04b5213aeda4ad19c952128bee3","modified":1519919449990},{"_id":"themes/hexo-theme-icarus/layout/archive.ejs","hash":"6a4adb703df447a754225fa665e679816e432ea2","modified":1519919449990},{"_id":"themes/hexo-theme-icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1519919449991},{"_id":"themes/hexo-theme-icarus/languages/zh-TW.yml","hash":"646a7ef3e85481b013ffb2f4d9f9a8900f092d73","modified":1519919449990},{"_id":"themes/hexo-theme-icarus/layout/index.ejs","hash":"c329f4598a0af4d8678ba789fdc84fcdf10122de","modified":1519919450000},{"_id":"themes/hexo-theme-icarus/layout/layout.ejs","hash":"2bc1e3071a5ec25096584d01726a3b7c4d53ffaf","modified":1519919450000},{"_id":"themes/hexo-theme-icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1519919450000},{"_id":"themes/hexo-theme-icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1519919450002},{"_id":"themes/hexo-theme-icarus/layout/tags.ejs","hash":"2a5b11bdf0dbf7300e11eae34bba00490ed77a0f","modified":1519919450005},{"_id":"themes/hexo-theme-icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1519919450005},{"_id":"themes/hexo-theme-icarus/scripts/meta.js","hash":"2e5ac0cb9c90c072ca4b33e88f1892e954935ab7","modified":1519919450008},{"_id":"themes/hexo-theme-icarus/scripts/thumbnail.js","hash":"4a7385e533f3567758bc995a8be5eb3e7839ac9c","modified":1519919450008},{"_id":"source/img/EightQueen/EightQueen1.jpg","hash":"afebe8396c5960f7b86cc8b7e1c46afa7e00719f","modified":1519822521420},{"_id":"source/img/EightQueen/EightQueen2.jpg","hash":"527dcf777845e9df1794721aba349e72514d8bb6","modified":1519822521420},{"_id":"source/img/EightQueen/EightQueen4.jpg","hash":"4b3fcd9e4c5adb75fe48fdd066f9807769a35cea","modified":1519822521421},{"_id":"source/img/EightQueen/EightQueen3.jpg","hash":"0916ef5bfa25f375f5c99b1c3f66e24d9fec49a5","modified":1519822521421},{"_id":"source/img/EightQueen/EightQueen4.png","hash":"2008fc87ac809647ba2125e979e3717bb8ab5780","modified":1519822521422},{"_id":"source/img/EightQueen/EightQueen5.jpg","hash":"dda5d7287f773c4718a0c43c3d44621be1b12c56","modified":1519822521422},{"_id":"source/img/EightQueen/EightQueen3.png","hash":"55b24fb3dd11e95926fd948337de4e1be754b128","modified":1519822521421},{"_id":"source/img/Graph/DGBFS.png","hash":"92ad1213be44daa815ac3f96d78c6f25381c9e77","modified":1519822521423},{"_id":"source/img/Graph/DG.png","hash":"3f109f92ab19233473b68c0887c350dfc29c2cbe","modified":1519822521423},{"_id":"source/img/Graph/DGDFS.png","hash":"50dbdc2f9f60530393e8385ee1f9869eb4216816","modified":1519822521424},{"_id":"source/img/Graph/DGL.png","hash":"511e44b1a6e006a82e3ae073c26d2de9dc24c0fa","modified":1519822521424},{"_id":"source/img/Graph/Topological Order 1.png","hash":"a92ee1e08478e291089514c5e51957f237088852","modified":1519822521425},{"_id":"source/img/Graph/Topological Order 2.png","hash":"27152cc74d170297cd9b82dbc9a4557fb2deb3ec","modified":1519822521425},{"_id":"source/img/Graph/Topological Order.png","hash":"f867623b63241fab5e04aed1520521799cfccc28","modified":1519822521426},{"_id":"source/img/Graph/Topological Order 3.png","hash":"f7b4e744cd747262bd6f2c599c63500f88b38aa6","modified":1519822521426},{"_id":"source/img/Graph/UDG.png","hash":"1e4e63fd2338a6869ce7f4d6d38c6b6adbaa8ca5","modified":1519822521426},{"_id":"source/img/Graph/UDGBFS.png","hash":"79ffb44346348e2235cf5be14db491c357fcf6de","modified":1519822521427},{"_id":"source/img/Graph/UDGDFS.png","hash":"48a59bbc312b4357e0380c048f9a3afd2a8dda54","modified":1519822521427},{"_id":"source/img/Graph/UDGL.png","hash":"988f7a4fe1bf7cca183a00e5ac1e280f0c152348","modified":1519822521428},{"_id":"source/img/RedBlackTree/insertFix2.png","hash":"8f0edd37a6f822917c4ce2ce1810a710859ab95c","modified":1519822521437},{"_id":"source/img/SIMD/Example_SIMD.jpg","hash":"344c55c0be47ef5ee711b6f23078e15c7a0537a1","modified":1522074658992},{"_id":"source/img/RedBlackTree/insertFix4.png","hash":"ab592eaa6d168df2f394de33bc88bc4bd3a9686c","modified":1519822521438},{"_id":"source/img/RedBlackTree/insertFix3.png","hash":"24a2df1c6a5fb3905fe59be4061e2c47d43112bf","modified":1519822521437},{"_id":"source/img/RedBlackTree/leftrotate.jpg","hash":"49d85050b3bfce71707346bb7724840fb0b38c1b","modified":1519822521438},{"_id":"source/img/RedBlackTree/insertFix1.png","hash":"a6e2d8ea99c22ae28b6a06cd1875a198b5945c1f","modified":1519822521436},{"_id":"source/img/RedBlackTree/removeFix1.jpg","hash":"c7f4d2a111411cac60c6c2f20a6d249ff71c6d42","modified":1519822521439},{"_id":"source/img/RedBlackTree/rbtree.png","hash":"a3540c19413961c930ba6c95d27b36b28979cddf","modified":1519822521439},{"_id":"source/img/RedBlackTree/removeFix2.jpg","hash":"2676a21396ea823ed3e3e681dbb7b770fb229eef","modified":1519822521439},{"_id":"source/img/RedBlackTree/removeFix4.jpg","hash":"98a5983478738f8223ca7e1e0550000d5b7c7796","modified":1519822521440},{"_id":"source/img/RedBlackTree/removeFix5.jpg","hash":"adb2c1bd12bdde17cf0ccad0faf0f2054e1a6e8c","modified":1519822521441},{"_id":"source/img/RedBlackTree/removeFix3.jpg","hash":"d97c5b02aa4e43965020156ba43017ce176a90ce","modified":1519822521440},{"_id":"source/img/RedBlackTree/removeFix6.jpg","hash":"c0a4bbe927ddd5e806dbe7c55d1bb61d9c9d3a6f","modified":1519822521441},{"_id":"source/img/RedBlackTree/removeFix7.jpg","hash":"43c63cb1142f3bf0fca2414925c9242e36428458","modified":1519822521441},{"_id":"source/img/RedBlackTree/removeFix8.jpg","hash":"601cb708e278a55107b66801fea317c29e2e8d3c","modified":1519822521442},{"_id":"source/img/RedBlackTree/rightrotate.jpg","hash":"1ccac37948f03661a96695479bb5bb463f3692f0","modified":1519822521442},{"_id":"source/img/PythonSort/3.gif","hash":"2492ae35eb401fb9eadf1d40a4a68310af740891","modified":1519822521432},{"_id":"source/img/PythonSort/5.gif","hash":"44e4ef3163872bf7ea31bdd2d8cec42dbb6a59bd","modified":1519822521435},{"_id":"themes/hexo-theme-icarus/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1519919052270},{"_id":"themes/hexo-theme-icarus/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1519919052270},{"_id":"themes/hexo-theme-icarus/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1519919052275},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1519919052276},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1519919052276},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1519919052277},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1519919052277},{"_id":"themes/hexo-theme-icarus/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1519919052278},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1519919052277},{"_id":"themes/hexo-theme-icarus/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1519919052278},{"_id":"themes/hexo-theme-icarus/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1519919052279},{"_id":"themes/hexo-theme-icarus/.git/logs/HEAD","hash":"38cade19c8d72d46201592c86643e0fb67db451f","modified":1519919449973},{"_id":"themes/hexo-theme-icarus/_source/categories/index.md","hash":"62fe9cd3a09f7971c8bfb84f18ed7863f84cb30a","modified":1519919449986},{"_id":"themes/hexo-theme-icarus/_source/about/index.md","hash":"3c9b7a6853bfcdd019317c95f2aa33829b269cbc","modified":1519919449986},{"_id":"themes/hexo-theme-icarus/_source/tags/index.md","hash":"f913370f50299b9b8b4cfd73fbdd5c07f4950549","modified":1519919449986},{"_id":"themes/hexo-theme-icarus/layout/comment/changyan.ejs","hash":"67b9c24a2973bb208e183ce46201d3c209a1bd4a","modified":1519919449991},{"_id":"themes/hexo-theme-icarus/layout/comment/counter.ejs","hash":"f744b41f3cc258e2a5a6df6abf6cf9ba9f05c19c","modified":1519919449991},{"_id":"themes/hexo-theme-icarus/layout/comment/disqus.ejs","hash":"b83fd91a30ca2bd62e2d43ae48e0523e0e1994c0","modified":1519919449992},{"_id":"themes/hexo-theme-icarus/layout/comment/duoshuo.ejs","hash":"adc024b7205e934e64c98a5b912c41117a4425bd","modified":1519919449992},{"_id":"themes/hexo-theme-icarus/layout/comment/facebook.ejs","hash":"6a53104fc01fd4a7a34b46c2828e76d02cacb0dd","modified":1519919449992},{"_id":"themes/hexo-theme-icarus/layout/comment/index.ejs","hash":"61f0398161f27ea5d134212a2ed601acdba0402f","modified":1519919449993},{"_id":"themes/hexo-theme-icarus/layout/comment/gitment.ejs","hash":"c7998209b9a766eeba6976dd4bdffb1f87469358","modified":1519919449992},{"_id":"themes/hexo-theme-icarus/layout/comment/livere.ejs","hash":"d2d0d8113a5a7d2cddf1d8ce067e07d40874e56c","modified":1519919449994},{"_id":"themes/hexo-theme-icarus/layout/comment/isso.ejs","hash":"b3dd067a6099f0e088f3374d37b8a726bafe15e5","modified":1519919449994},{"_id":"themes/hexo-theme-icarus/layout/comment/scripts.ejs","hash":"869b13c45f043451c73c46b347967667e18f6d0b","modified":1519919449994},{"_id":"themes/hexo-theme-icarus/layout/comment/valine.ejs","hash":"0ea90a606f0d386a5ae0da83c0501cbb25319fde","modified":1519919449994},{"_id":"themes/hexo-theme-icarus/layout/comment/youyan.ejs","hash":"b4c49b97b757d01ba0c4e16f9862a2ec05f37b1f","modified":1519919449995},{"_id":"themes/hexo-theme-icarus/layout/common/footer.ejs","hash":"a102a07d8e170889eb82696f2c4ddda848126da0","modified":1520510150773},{"_id":"themes/hexo-theme-icarus/layout/common/article.ejs","hash":"ebc18807a58c974ad824ff7800b4e801bdf94a39","modified":1519919449995},{"_id":"themes/hexo-theme-icarus/layout/common/head.ejs","hash":"6b6063ff2f8f65cb4ce3fc6d197a81d30f813017","modified":1519919449996},{"_id":"themes/hexo-theme-icarus/layout/common/header.ejs","hash":"c75d5c3e956f70b0b82552f1e3f5749f0229ddd7","modified":1519919449996},{"_id":"themes/hexo-theme-icarus/layout/common/profile.ejs","hash":"d4dfa98d6481f9cd8f78b7a749276a76241b35d1","modified":1519919449998},{"_id":"themes/hexo-theme-icarus/layout/common/sidebar.ejs","hash":"ba03c02607a3330b03727a12ecbbafe9cc3ee450","modified":1519919449999},{"_id":"themes/hexo-theme-icarus/layout/common/scripts.ejs","hash":"6c39352254c93f1fbedb4e81d2fdc94f34f54c2e","modified":1519919449999},{"_id":"themes/hexo-theme-icarus/layout/common/thumbnail.ejs","hash":"b80d8733a620be64a6f7d73f0b012a986755fd91","modified":1519919449999},{"_id":"themes/hexo-theme-icarus/layout/common/timeline.ejs","hash":"a2ba07bd70a82a80df71133dc0cea1248a1e3b3e","modified":1519919450000},{"_id":"themes/hexo-theme-icarus/layout/plugin/baidu-analytics.ejs","hash":"3218b9f6345aaa537f742ab4781bd27a3f40c378","modified":1519919450001},{"_id":"themes/hexo-theme-icarus/layout/plugin/google-analytics.ejs","hash":"760a8f9ee9b81f6eb27a5f2c8c5159b220a88a74","modified":1519919450001},{"_id":"themes/hexo-theme-icarus/layout/plugin/scripts.ejs","hash":"2a41940ab86d3f7b095436b56ea304689c2b5121","modified":1519919450001},{"_id":"themes/hexo-theme-icarus/layout/search/baidu.ejs","hash":"8cc6f6e601b14d310f20eaf29dc55d6c60ab4ee4","modified":1519919450002},{"_id":"themes/hexo-theme-icarus/layout/search/index-mobile.ejs","hash":"8e2e28b37a908f60e4953bf9175a7af329d15d40","modified":1519919450002},{"_id":"themes/hexo-theme-icarus/layout/search/index.ejs","hash":"fb1ac5d6b44dbc96cbef7ecdbb6397c3d4fe3e0f","modified":1519919450002},{"_id":"themes/hexo-theme-icarus/layout/search/insight.ejs","hash":"21ec59e4534ac2417d6b215b6cfe3825245ad340","modified":1519919450003},{"_id":"themes/hexo-theme-icarus/layout/search/swiftype.ejs","hash":"cce9c44180d9490f45b30b8f052ac82675a9d66a","modified":1519919450003},{"_id":"themes/hexo-theme-icarus/layout/share/addtoany.ejs","hash":"b79f714da69c121729a136df0c94c09a85966d44","modified":1519919450004},{"_id":"themes/hexo-theme-icarus/layout/share/bdshare.ejs","hash":"d2a0826700c51d9edaf21fa6cbb047b5127cec8a","modified":1519919450004},{"_id":"themes/hexo-theme-icarus/layout/share/default.ejs","hash":"8532f15f400dbc7c1e89ab26972fc4e404001849","modified":1519919450004},{"_id":"themes/hexo-theme-icarus/layout/share/index.ejs","hash":"52c094140d19e7e2fce57fe43968b2bd86aa4ef0","modified":1519919450004},{"_id":"themes/hexo-theme-icarus/layout/share/jiathis.ejs","hash":"442abbc0fe5cab4171179257d172150f2a789638","modified":1519919450005},{"_id":"themes/hexo-theme-icarus/layout/widget/category.ejs","hash":"81c6c0a3450e1ab56a725bb953a5021a07c0e212","modified":1519919450006},{"_id":"themes/hexo-theme-icarus/layout/widget/archive.ejs","hash":"d6412cd574744f994f16e3a70ce29a71b449133a","modified":1519919450005},{"_id":"themes/hexo-theme-icarus/layout/widget/links.ejs","hash":"23d637daed63e86ec7c4a12f5a48908905ed7819","modified":1519919450006},{"_id":"themes/hexo-theme-icarus/layout/widget/recent_posts.ejs","hash":"7767972b9d0cba456f0e0cff1b96b516936414ea","modified":1519919450006},{"_id":"themes/hexo-theme-icarus/layout/widget/tag.ejs","hash":"cf8a87b0573c9ff11d82ca5edb86267f77e11589","modified":1519919450006},{"_id":"themes/hexo-theme-icarus/layout/widget/tagcloud.ejs","hash":"a4b28996e0e7df2e582387455c02f5c33f691bbd","modified":1519919450007},{"_id":"themes/hexo-theme-icarus/source/css/_extend.styl","hash":"c18c58c67f49b8afe92fa8852ff7e203ce5958de","modified":1519919450009},{"_id":"themes/hexo-theme-icarus/source/css/_variables.styl","hash":"28d73a420f32c73595fcc559528544cf998590c7","modified":1519919450038},{"_id":"themes/hexo-theme-icarus/source/css/style.styl","hash":"5c22522034beed5018efd77e34c01584a815b23d","modified":1519919450040},{"_id":"themes/hexo-theme-icarus/source/js/insight.js","hash":"691bc7ce086b55b360bb6ec517b2ad6e53ebadc7","modified":1519919450041},{"_id":"themes/hexo-theme-icarus/source/js/main.js","hash":"39739be85d5800a16c288a476d70c7fea05c9a27","modified":1519919450041},{"_id":"source/img/PythonSort/2.gif","hash":"71405a826cbf59fad388c6b8699adbe9b7311b0d","modified":1519822521432},{"_id":"source/img/PythonSort/6.gif","hash":"0115a5312f9769ac3af29ba959726ba65c475b93","modified":1519822521436},{"_id":"source/img/Graphics/PBR/BRDF_02.png","hash":"8e73da456386294897bcda65e44558d6bd5f98f6","modified":1531658731421},{"_id":"source/img/Graphics/PBR/BRDF_03.png","hash":"976f66eec8116dbbdba91852dea8011854d4d235","modified":1531658993196},{"_id":"source/img/Graphics/PBR/BRDF_01.png","hash":"8c4df7cb0da280ac7e5c4d387c5a140c6a09e42d","modified":1531658650802},{"_id":"source/img/Graphics/PBR/BRDF_04.png","hash":"4bbd2f9e06c23d2e111182ebf5ebee14f2e491d8","modified":1531659129273},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_00.png","hash":"4739c9d8c90e1c6a0bb6ac2eaef88c34c00349bc","modified":1531318948775},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_02.png","hash":"7d239a7792f73aaac00fdd305656533beb14e4d4","modified":1531319030634},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_03.png","hash":"7821f42769ea6fe03a265464bbb0e0e3cbc7cfeb","modified":1531319049740},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_04.png","hash":"1364b2fd2d88280aec09809f979c51a3b60b0c97","modified":1531320920702},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_01.png","hash":"0a2bcf997f4cf600ad3ed2b09b732f34301af97c","modified":1531234124696},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_03.png","hash":"aacef3c4e055f84a27dae5c0f271a47120b8b24d","modified":1531235489326},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_02.png","hash":"8c4df7cb0da280ac7e5c4d387c5a140c6a09e42d","modified":1531235195928},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_04.png","hash":"4f459ddaa9e792763d3acabd643a160bb2505028","modified":1531235495999},{"_id":"source/img/Graphics/PBR/微信图片_20180805233454.jpg","hash":"b0a2e598296355c53ac3ce390f34124d93d2b3ff","modified":1533483344379},{"_id":"source/img/Graphics/RayTracing/RayTracing_7.png","hash":"42a24a704c00f0a095aebbc69c2c4d6973192f4c","modified":1530798789346},{"_id":"source/img/Graphics/RayTracing/Ray_triangle_Intersection_00.png","hash":"3016afed9473c895bcfd64c77b0bae5a80fb1eb5","modified":1530934254340},{"_id":"source/img/Graphics/RayTracing/RayTracing_9.png","hash":"3965313af97cb25ad49ee148c86b2494d02fc8d6","modified":1530798964093},{"_id":"source/img/Graphics/RayTracing/epslion_problem_00.png","hash":"c06a175773350d0f1e2e225f632a725624856402","modified":1530936160575},{"_id":"source/img/Graphics/RayTracing/lighting_and_matrials_00.png","hash":"4319ca333e40c09474e4ee912345fb25c590e9fd","modified":1531142426169},{"_id":"source/img/Graphics/RayTracing/lighting_and_matrials_02.png","hash":"156d4f49ce4136770b3dee0500443230c97c98dc","modified":1531144670839},{"_id":"source/img/Graphics/RayTracing/lighting_and_matrials_01.png","hash":"c540703f4c1806c4ae031aa6df73f59ab4b836cd","modified":1531144665090},{"_id":"source/img/Graphics/RayTracing/ray_00.png","hash":"534b1f7e60b93238e92d0299292de28b09a079b1","modified":1530951249606},{"_id":"source/img/Graphics/RayTracing/ray_01.png","hash":"99bf187515791e39e5e52c8b09505c674869a643","modified":1530952628686},{"_id":"themes/hexo-theme-icarus/.git/refs/heads/master","hash":"93cadec7110d74453ec94cf59c8dc39d1e7e6459","modified":1519919449973},{"_id":"themes/hexo-theme-icarus/.git/objects/pack/pack-f4d7451bc7491a1e7337a65b4c7853baf5bd721a.idx","hash":"a056b80d48acc4af0f68d234f87b2163fa53fec8","modified":1519919449840},{"_id":"themes/hexo-theme-icarus/layout/common/post/category.ejs","hash":"96f999573eb908f7129a1c09e486d46d630c0a7d","modified":1519919449997},{"_id":"themes/hexo-theme-icarus/layout/common/post/banner.ejs","hash":"431b445dfa5dec4b710069c7f1b5fae3f0a907a5","modified":1519919449996},{"_id":"themes/hexo-theme-icarus/layout/common/post/date.ejs","hash":"67f6fb688420c100e6b7ffe10775d7a59bc44862","modified":1520510296069},{"_id":"themes/hexo-theme-icarus/layout/common/post/gallery.ejs","hash":"1ccdc66206e84668fa1f0d2440a8ed983aa321fd","modified":1519919449997},{"_id":"themes/hexo-theme-icarus/layout/common/post/nav.ejs","hash":"79d15e00ead668bf44a48f4e870ac0cde9dbdee3","modified":1519919449997},{"_id":"themes/hexo-theme-icarus/layout/common/post/title.ejs","hash":"a1c02064737ae393d8e9393d4777dff408de155f","modified":1520440279209},{"_id":"themes/hexo-theme-icarus/layout/common/post/tag.ejs","hash":"7df16851b35da0ea09f7323bdbfb977198823f4c","modified":1519919449997},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/justifiedGallery.min.css","hash":"45fa2fad51cecfc41107dbd4637450b746a7cbc3","modified":1519919450053},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/styles.css","hash":"08c8c7eeaf34cb2f8c3312a3ce2e96b58ce2b4c0","modified":1519919450077},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"1c7fd3bd976f671ba396ad4dbbb7157006243bf5","modified":1519919450052},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/styles.css","hash":"6335d719343cca455152ad71a1aaed9868339236","modified":1519919450078},{"_id":"themes/hexo-theme-icarus/source/css/_partial/archive.styl","hash":"4dd216a147dd65ddc37521fe8a1a01aa929aeea5","modified":1519919450033},{"_id":"themes/hexo-theme-icarus/source/css/_partial/comment.styl","hash":"7fc8a32cf235d0a977d9ff0c49263c0541025222","modified":1519919450034},{"_id":"themes/hexo-theme-icarus/source/css/_partial/article.styl","hash":"c05ead4c95e2dd0b69f9041f3032301d2e000eb3","modified":1519919450034},{"_id":"themes/hexo-theme-icarus/source/css/_partial/footer.styl","hash":"06c2c9029ebfb16880a203c218657048a83a3e4b","modified":1519919450035},{"_id":"themes/hexo-theme-icarus/source/css/_partial/insight.styl","hash":"8a84868a13c7edb733347655b33dc169c682e8b8","modified":1519919450036},{"_id":"themes/hexo-theme-icarus/source/css/_partial/profile.styl","hash":"dfa3eab5933c6af4dfb7268c511157cbb926dcfa","modified":1519919450036},{"_id":"themes/hexo-theme-icarus/source/css/_partial/header.styl","hash":"218713de00dc6c503e7036fce2aab81dd94b4c0c","modified":1519919450035},{"_id":"themes/hexo-theme-icarus/source/css/_partial/sidebar.styl","hash":"fb211c3c747565e6fa2304f436b42d14ef84d71a","modified":1519919450037},{"_id":"themes/hexo-theme-icarus/source/css/_partial/timeline.styl","hash":"ba1ea8a87ca7c667f0d3cc40033b52bdf168fbdd","modified":1519919450037},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/arduino-light.styl","hash":"591962bfc758a521b4cb907750c19a1a2423b4d5","modified":1519919450010},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/agate.styl","hash":"c01db6c4e7648b217048a8deefeee189688a9290","modified":1519919450009},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/androidstudio.styl","hash":"b0923fe15d0b5eb24d3c6236cb2fc30ee14a4c56","modified":1519919450009},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/arta.styl","hash":"3bc322455f657aa29f455f91009034af08cdc65c","modified":1519919450010},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/ascetic.styl","hash":"ca087a3c70998c7ac6b0b42d5cf7a653b8707591","modified":1519919450011},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"a6b1960d8a3b39d035e06ce92af4f00a259b5c56","modified":1519919450011},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-cave-light.styl","hash":"f47de0b9d66617728f68096ed48371dd6bb9e67a","modified":1519919450011},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"68021a92fd7d6895426d0cc7f0929aa95633d742","modified":1519919450011},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-dune-light.styl","hash":"657fe215931fd06e21b56374df699a94890f7ab4","modified":1519919450012},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"6c051f034c229c49ffc9a2ec96c032441b0c6586","modified":1519919450012},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"2b416a0567a53aa0fa8898b196ddd44315c1a5f3","modified":1519919450012},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"15559324ee3a5f9bf6724ec9606f6f2e16cdc24d","modified":1519919450012},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-forest-light.styl","hash":"8d7c7242974aa2454fa792c5d7a47c5f9632355a","modified":1519919450013},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"bf62cafe316eb874f1f43679957dc3add4fbea34","modified":1519919450013},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-heath-light.styl","hash":"c1db353e8613607580d40b12ddc162d029560576","modified":1519919450013},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"64ab6ab93a092a890d3d0fdeb23e4b6a2d0f2887","modified":1519919450014},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"8a6c187afcd60152306c003e1a5903e57d9428dd","modified":1519919450014},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"96181544eeadc5b0749229f11607e7c01f81e078","modified":1519919450015},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"8659eaae6a0c2e00b4b9199803e50adf4ff0128d","modified":1519919450014},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"5261a100e84cf34f4752c24dfaddfa05c7be96f7","modified":1519919450015},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"8a5207a0c30262a0bf5e1a41411a306f7a89a7e7","modified":1519919450015},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"434b7f0bdd5f91bf79d5b4ca46820db4a8e10166","modified":1519919450015},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"08e2df313c272d5c70c93e713639663c168180d0","modified":1519919450016},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"fa0cccd0f0dc015218cf8c1bba0b53c8c9383135","modified":1519919450016},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"add3d88c9d12567dcfae7a8e49984d119fc72227","modified":1519919450016},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/brown-paper.styl","hash":"d14846542a26b75fd26df5b5df6c5493733f73f6","modified":1519919450016},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1519919450017},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/codepen-embed.styl","hash":"7432ce9edb047b6382d28c82054a7e2a77e476c3","modified":1519919450017},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/color-brewer.styl","hash":"9c4905eab730d0b389e6972e907057577f7e25f1","modified":1519919450017},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/dark.styl","hash":"df4c1dc05567ad0812d0cd3133cb2a2a5fd23c04","modified":1519919450018},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/darkula.styl","hash":"3c943561a885092286ec8db14e9177036bf8d21f","modified":1519919450018},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/docco.styl","hash":"7bd3389ce16d20488ab336d557056cc703c921c7","modified":1519919450018},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/foundation.styl","hash":"28c59a31467c33bd51cbf3b6085782c2a724ff6c","modified":1519919450019},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/far.styl","hash":"5989aea14ccd0153d17ee19b3e125dae06c75f3c","modified":1519919450019},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/github-gist.styl","hash":"71f4b0fca91a587e6eba15a5306dca963bb8f441","modified":1519919450019},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/github.styl","hash":"a84eb710b302006120c3e7f8ca18f9e6fbc231c3","modified":1519919450020},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/googlecode.styl","hash":"7f5082ae008925a23eb713f160773fe647eb3ff7","modified":1519919450020},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/grayscale.styl","hash":"c83804abe39faebd80f8f4ff64fbd7137674cb1c","modified":1519919450020},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/highlightjs.styl","hash":"fd796a58c5d4590cda67c998187933788d45f30a","modified":1519919450020},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/hopscotch.styl","hash":"7ec8d75a9c9d58f65868ea64289873302d3fad5e","modified":1519919450021},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/hybrid.styl","hash":"d3ee1bcefc94f5f87a2b76a689f4c31594501d07","modified":1519919450021},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/idea.styl","hash":"e284c1760e8da0848f56cd5601d867ceeb0192d7","modified":1519919450021},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/index.styl","hash":"36c44375229613a5bb9ee84a8e90214978070439","modified":1519919450022},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/ir-black.styl","hash":"c59db73998af32ce8419a5d2d335bcc9cfbaae45","modified":1519919450022},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/kimbie.dark.styl","hash":"3b998c640eeb2c6192fee24bc78b4137de475dd7","modified":1519919450022},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/kimbie.light.styl","hash":"e901738455ec9a1bddde7b62bbd8595de6033e1e","modified":1519919450022},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/magula.styl","hash":"ab179306c12a1cf2949482beaca328e379ef034a","modified":1519919450023},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/mono-blue.styl","hash":"14fb8678739b77f35771b6d63101ddbf1e7a9fbc","modified":1519919450023},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/monokai-sublime.styl","hash":"32955f699687b5fc2e4072804cb90925912d3c7c","modified":1519919450025},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/monokai.styl","hash":"8489fc71bedefa8f271808126296fce6381f9e04","modified":1519919450025},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/obsidian.styl","hash":"8145db8ec349548f09d91d7a05c00c83ff84d146","modified":1519919450025},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/paraiso-dark.styl","hash":"50f1cee8a5b3b165b4184ead0a99dc564b62ef4f","modified":1519919450025},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/paraiso-light.styl","hash":"e428e8202b01e83b0f018a96058d806e7f4c76bf","modified":1519919450026},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/pojoaque.styl","hash":"d9f4b35c9f6115029600a8a023b559013e2b4e75","modified":1519919450026},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1519919450026},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/railscasts.styl","hash":"1ff800d9b6de464fafe591682cc48bf983202758","modified":1519919450027},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/rainbow.styl","hash":"516c7080d64b12730357358dee2adc42c43c4516","modified":1519919450027},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1519919450028},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/school-book.styl","hash":"186c37e9c39e65aa291cce3317e35904693598d1","modified":1519919450029},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/solarized-dark.styl","hash":"577458d1f6c02bc42e312066bf7dd7e427cab057","modified":1519919450029},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/solarized-light.styl","hash":"bb04944fc06c12ecd7b56ad933dbedde60c2259a","modified":1519919450029},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/sunburst.styl","hash":"482bbb2bc461b22e9d6ce55f0f84767e1cfae99a","modified":1519919450030},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"eeafa86697c857c4e9a84ad48c0d56a7154997a3","modified":1519919450030},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"f3cd5ed391d40265e36fcd9f7daced52773fb886","modified":1519919450030},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"1cd947f3d414fa5c1435caea509f27c99f6dc5b3","modified":1519919450030},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night.styl","hash":"b2a175caa23631f764b2f6fe2bac9739f5f5e078","modified":1519919450031},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow.styl","hash":"502335f0fac07ed74ca78207bcf3ef8dd2252cf6","modified":1519919450032},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/vs.styl","hash":"14fbb0c43af440a290280b26968c8a5c0786b27f","modified":1519919450032},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/xcode.styl","hash":"5fa8999c7f807c1aae29c7a1cdf681678576fb69","modified":1519919450033},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/zenburn.styl","hash":"6908313d2666d31fc9d8658fd7e8dda3de2bb596","modified":1519919450033},{"_id":"themes/hexo-theme-icarus/source/css/_util/mixin.styl","hash":"3f8730ec2b1b582ba93b14f0e50a41fbbce52755","modified":1519919450038},{"_id":"themes/hexo-theme-icarus/source/css/images/avatar.jpg","hash":"518573c62ed28c7ae178254e8a5ef5a9286ee79d","modified":1530948748779},{"_id":"themes/hexo-theme-icarus/source/css/_util/grid.styl","hash":"866fc18d6368c4131b03601a15af7703a9a42b61","modified":1519919450038},{"_id":"themes/hexo-theme-icarus/source/css/images/logo.jpg","hash":"518573c62ed28c7ae178254e8a5ef5a9286ee79d","modified":1530948748779},{"_id":"themes/hexo-theme-icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1519919450040},{"_id":"source/img/Graphics/PBR/PBR_0.png","hash":"703d987d99ce101b204bd73004bc5b280488fb10","modified":1530712873128},{"_id":"source/img/Graphics/PBR/The_Reflection_Equation_01.png","hash":"fd34cce7926bac42b5cb8e4132be4ef7a760dfdd","modified":1531319018131},{"_id":"source/img/Graphics/RayTracing/RayTracing_1.png","hash":"e8d75c8c7b0862fb04973e2b14033bd8684cd747","modified":1530793489124},{"_id":"source/img/Graphics/RayTracing/RayTracing_5.png","hash":"6c98e66001d3830bd98f9fd033e8eb8d1e9e5105","modified":1530798289853},{"_id":"source/img/Graphics/RayTracing/Ray_box_Intersection_00.png","hash":"c7b2e7daee192eb60a97a757f8773221a25ce981","modified":1530933494762},{"_id":"source/img/Graphics/PBR/BRDF_00.png","hash":"d897d09a7bf4e8cd5e34118a0dbc24219e064a60","modified":1531404531669},{"_id":"source/img/Graphics/RayTracing/RayTracing_0.png","hash":"f050562b527284a9b76bec5ccb9857b58850b9b9","modified":1530711704476},{"_id":"source/img/Graphics/RayTracing/RayTracing_3.png","hash":"caf63df55a8d9f6247249481500d53aaba6c40a7","modified":1530798357707},{"_id":"source/img/Graphics/RayTracing/RayTracing_4.png","hash":"6f436edc58161262ec6b726e6bf8eb34582a0068","modified":1530798375848},{"_id":"source/img/Graphics/RayTracing/RayTracing_6.png","hash":"245764b151284dc8d8dde9f5bb6ec9713361cf6e","modified":1530798758762},{"_id":"source/img/Graphics/RayTracing/RayTracing_8.png","hash":"a30c12b747043a442d66e9910adcbe39babacd8a","modified":1530798883678},{"_id":"source/img/Graphics/RayTracing/ray_02.png","hash":"2c87a727b697bf883b5838cb6abe742a02a2b570","modified":1530980095456},{"_id":"source/img/PythonSort/4.gif","hash":"d70822274ca52ebc2c925fb94e81dc6a11591afa","modified":1519822521434},{"_id":"themes/hexo-theme-icarus/.git/logs/refs/heads/master","hash":"38cade19c8d72d46201592c86643e0fb67db451f","modified":1519919449974},{"_id":"themes/hexo-theme-icarus/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1519919449970},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.css","hash":"bf188c224998b995d0119cfd18fade22e53f573c","modified":1519919450042},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.min.css","hash":"bd7c2763e15e568bdccc85e38432d79f65f8d9a1","modified":1519919450042},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1519919450059},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1519919450059},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1519919450060},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"10c9630e41bb8d6bb7f75a3bfe8cdb33451ed7ba","modified":1519919450054},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1519919450059},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"5281d2cfb0ef278940c4860ea9aa7ef86d3dbc8d","modified":1519919450055},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1519919450055},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css","hash":"2866c3f1eda31ed34485ff3511bcfb706d78ac56","modified":1519919450056},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1519919450056},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css.map","hash":"6ee19f99bca3ecf2fa0d6f07fb5c200db07ddd11","modified":1519919450056},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css","hash":"d26b528a13ee1ef245bdb0aa3db149be3fe9cba6","modified":1519919450057},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1519919450058},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css.map","hash":"91788030e3c7107b6b4bf50a82d4309368850488","modified":1519919450058},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1519919450060},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1519919450061},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1519919450062},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.js","hash":"ba52bd55c0ab647e277c42b0e48a0ac25cbd3099","modified":1519919450062},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1519919450061},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"44203a1490749aff6aba9784868b6c888d3fb86e","modified":1519919450063},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.js","hash":"6369e9704550f4207fa798dc6018da1d259fd318","modified":1519919450063},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"a5c468d260e3a8e68c9026aa2b5f31ce1860b8bf","modified":1519919450064},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.js","hash":"8a026dc31f912cbd3b8a110bb87984b372661f65","modified":1519919450064},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.js","hash":"562f883ba3a5e8ea570fd5d0c40afe527938c026","modified":1519919450065},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.min.js","hash":"fbdbcb46ae9fd668ba5e4dce5635c040359e3359","modified":1519919450064},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.min.js","hash":"ec662f97ed5a15c2bd8cf87d5c93cd9a6b4df07a","modified":1519919450065},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.js","hash":"b000585441e9bff2f5b7c538d623b698d48049a6","modified":1519919450065},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.min.js","hash":"afe725882964c87a148ac6ab54955cb0da0974c4","modified":1519919450065},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.js","hash":"99fe3cc63161f0d678360a939fbd54c5d1c11eeb","modified":1519919450066},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"e570807e2786a0acb393c1195c820a660312fffe","modified":1519919450066},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.min.js","hash":"050e7684bfbb133bed5375938fe0021f1fa88f7f","modified":1519919450067},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.js","hash":"11c8509a3e398cb8c2a32ff559ccdda6d9d71740","modified":1519919450066},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.js","hash":"69a127964e508699f5f13467dd1b58fbf04bcca9","modified":1519919450067},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.min.js","hash":"8daabc26ceadc43741904b99db7e01bfababbd04","modified":1519919450067},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1519919450069},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.js","hash":"6d424527be45ff4deedd198e195fdeb74f1c6567","modified":1519919450068},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.min.js","hash":"dc9c6447d3574fcba3868c35bb48e0bed9be6b7e","modified":1519919450068},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1519919450069},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1519919450070},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1519919450070},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1519919450071},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1519919450071},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1519919450071},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1519919450072},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1519919450072},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1519919450073},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1519919450072},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1519919450073},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1519919450074},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1519919450074},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1519919450075},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1519919450075},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1519919450075},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1519919450076},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1519919450076},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1519919450076},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1519919450077},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1519919450078},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1519919450078},{"_id":"source/img/Graphics/PBR/Threoy_of_PBR_00.png","hash":"598d37c32c06960d34d0ad3e348fe9fe813eab35","modified":1531316728914},{"_id":"source/img/Graphics/RayTracing/DoRayTracing_00.png","hash":"18fe9f9f8c4b6ac17d65589f242b03619e2c91d0","modified":1531202567845},{"_id":"source/img/Graphics/RayTracing/DoRayTracing_01.png","hash":"1c977d540b9d9fe95d3dc8b28571cf5f4517c41d","modified":1531204540983},{"_id":"source/img/Graphics/RayTracing/epslion_problem_01.png","hash":"386383a8c09afb13baa0bb395751f1a83aceaea3","modified":1530936174225},{"_id":"source/img/about_img/EL_3.PNG","hash":"7aa08b67da917fc579691275a3443a27c96ac6d5","modified":1519822521455},{"_id":"source/img/about_img/PA_0.PNG","hash":"853a41ae658f0c0a8313a3ea145e8a045f1c7b8b","modified":1519822521460},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1519919450044},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1519919450044},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1519919450050},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1519919450051},{"_id":"themes/hexo-theme-icarus/source/libs/jquery/2.1.3/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1519919450052},{"_id":"source/img/about_img/EL_4.PNG","hash":"675e70abd06119df33b9b51abe3611aece03872d","modified":1519822521457},{"_id":"themes/hexo-theme-icarus/.git/logs/refs/remotes/origin/HEAD","hash":"38cade19c8d72d46201592c86643e0fb67db451f","modified":1519919449970},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1519919450049},{"_id":"source/img/Graphics/RayTracing/RayTracing_2.png","hash":"e6ff16ccc916af662c330f80d48e00c312935c2b","modified":1530797907584},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"964e8dac2cee79c4b49b5bc300675773f6518812","modified":1519919450047},{"_id":"source/img/about_img/EL_1.PNG","hash":"068136d92ab86383eb7e1a63bc92d23ce97bf3b2","modified":1519822521449},{"_id":"source/img/Graphics/RayTracing/RayTracing_10.png","hash":"8483cae98c3e9d7bc80b068e2ec643797160e1cb","modified":1530799112185},{"_id":"source/img/PythonSort/1.gif","hash":"6393fd6978c778adeb8e449f2c2c41d8fee5164d","modified":1519822521431},{"_id":"source/img/about_img/EL_2.PNG","hash":"ac2962b5a980a618d36d4e33ccf90f3e7002c77c","modified":1519822521452},{"_id":"source/img/about_img/EL_0.PNG","hash":"259c77d58a222f82c205befc5e9ab45c10dbc41a","modified":1519822521446},{"_id":"source/file/lec09_ray_tracing.pdf","hash":"44f9cc621dd50937ecccc188f73daabef4ed8e82","modified":1530890092872},{"_id":"themes/hexo-theme-icarus/.git/objects/pack/pack-f4d7451bc7491a1e7337a65b4c7853baf5bd721a.pack","hash":"e6fe8da800f09678954db9fefc791d0410c145a1","modified":1519919449872},{"_id":"public/content.json","hash":"4770ff534b1e5fb8cdbb8b64093e4395499b119a","modified":1538906319804},{"_id":"public/about/index.html","hash":"648c39ac42eea0a242e95ea55d296242088d7a2d","modified":1538906342885},{"_id":"public/2018/07/12/BRDF/index.html","hash":"d84de07665c30334839a523b74f914dde18e9759","modified":1538906342885},{"_id":"public/2018/07/11/The-Reflectance-Equation/index.html","hash":"7ea67c1f251b57b83d76d33a148b0d241872bce3","modified":1538906342886},{"_id":"public/2018/07/10/Theory-of-PBR/index.html","hash":"d60def055e691712cc102d8e6287c053e932cdfd","modified":1538906342886},{"_id":"public/2018/07/10/Do-Ray-Tracing/index.html","hash":"7a44a3bc053bac1f816467f1472aa62a50018db3","modified":1538906342886},{"_id":"public/2018/07/09/Lighting_and_Materials/index.html","hash":"a4697b0bee8d5432b43a60bbfaac40b7db1d8c6a","modified":1538906342886},{"_id":"public/2018/07/07/Ray-and-Camera/index.html","hash":"081a6cadd0d2c87824be21fe5d3fecb00a94180d","modified":1538906342886},{"_id":"public/2018/07/06/Various-surfaces/index.html","hash":"3ffe3802fbe7b35323e0beb8eeed1ef413705a2e","modified":1538906342886},{"_id":"public/2018/07/05/Theory-of-Ray-Tracing/index.html","hash":"7d5451a7ca6ef24f87f090657f2e67d82fe4936d","modified":1538906342886},{"_id":"public/2018/07/04/Physically-Based-Rendering-Catalogue/index.html","hash":"43ed68282265d34e9c69d7a86593380a087dc21c","modified":1538906342886},{"_id":"public/2018/07/04/Ray-Tracing-Catalogue/index.html","hash":"9e239467e2be995219c904a6e7b9e41a79b977e8","modified":1538906342886},{"_id":"public/2018/03/26/SSE-Instruction-List/index.html","hash":"7047be32bd1c37d356c4577d8f59a2bcbc656ca2","modified":1538906342886},{"_id":"public/2018/03/10/Sorting-Algorithm/index.html","hash":"a4ce2ee41986780bbaaa1561a1fc390b76589140","modified":1538906342886},{"_id":"public/2018/03/09/N-Queens-Problem/index.html","hash":"dfdda80dacd39bc975a3a2418efe3c7c0d757684","modified":1538906342886},{"_id":"public/2018/03/08/Topological-Sort/index.html","hash":"e894180b1d77a8cf81ff2432cbc2c327e8519051","modified":1538906342886},{"_id":"public/2018/03/07/Breadth-First-Search/index.html","hash":"a6bec177116cd04d34aa5834d5dda0d8613a4e2a","modified":1538906342886},{"_id":"public/2018/03/07/Depth-First-Search/index.html","hash":"de1e18a65dfb1720fee17f6f9f393a12cdb2a961","modified":1538906342886},{"_id":"public/2018/03/06/Adjacency-List-Graph/index.html","hash":"caf38fabb19b473c7765491030e41cb8dfe3b0f6","modified":1538906342886},{"_id":"public/2018/03/06/Adjacency-Matrix-Graph/index.html","hash":"74a19db79574088580eaf76af8116189045e7b2e","modified":1538906342886},{"_id":"public/2018/03/04/Basic-Graph-Theory/index.html","hash":"9a673b13d98a31991c6ac8ab651e0bddc0e358ac","modified":1538906342887},{"_id":"public/2018/03/02/RedBlackTree-III/index.html","hash":"a8a56f34e2863c30a2a226493dc044e9042f275b","modified":1538906342887},{"_id":"public/2018/03/02/RedBlackTree-II/index.html","hash":"6e4442009d4e8f2376f2164a9ab69874a848283d","modified":1538906342887},{"_id":"public/2018/03/02/RedBlackTree-I/index.html","hash":"69fa320800fed93ce2b17313326217dae136c755","modified":1538906342887},{"_id":"public/archives/index.html","hash":"6e4d7aed5a5ecbf9e38cbc94dcab2e9115a5931c","modified":1538906342887},{"_id":"public/archives/page/2/index.html","hash":"2f40eee278a59416fe4d4d061ff94e259dcb49c6","modified":1538906342887},{"_id":"public/archives/page/3/index.html","hash":"439893a5cfd576238eaf128d8279a4435d4f5f83","modified":1538906342887},{"_id":"public/archives/2018/index.html","hash":"cd9adaadc46a409f3a49ce9b8cc74c26f2cc1a9e","modified":1538906342887},{"_id":"public/archives/2018/page/2/index.html","hash":"01f18247cf8aa9e3aef7502c07f23d66c1327141","modified":1538906342887},{"_id":"public/archives/2018/page/3/index.html","hash":"6cb95a8329d6ace454aeda3b4cf846bf0a2d92f4","modified":1538906342887},{"_id":"public/archives/2018/03/index.html","hash":"102f067bd04444395a86c658013e7fc79dbe35f6","modified":1538906342887},{"_id":"public/archives/2018/03/page/2/index.html","hash":"b9a03fdaa1a99e10a4e3db8432860956eb0f857e","modified":1538906342888},{"_id":"public/archives/2018/07/index.html","hash":"f3df0304a80ce0366698815746bd60acac120a5f","modified":1538906342888},{"_id":"public/tags/C/index.html","hash":"31d2b820b1991e6b435b8d3456b88fc0ed2e16a1","modified":1538906342888},{"_id":"public/tags/C/page/2/index.html","hash":"0aecbd5ebc342a5cc55fcdf9e50390ac2dca2c66","modified":1538906342888},{"_id":"public/tags/Data-Structure/index.html","hash":"c2ac07154cbbde90505612d6d4c7c9194ed8bf64","modified":1538906342888},{"_id":"public/tags/Graph/index.html","hash":"030774299820568aaf97cc5cc42ae88237958371","modified":1538906342888},{"_id":"public/tags/Algorithm/index.html","hash":"7106f7e72a94ab65841a41a9608b0bdbbed94d5c","modified":1538906342888},{"_id":"public/tags/Graphics/index.html","hash":"30e6e9f0aa7d9c4bb3aff17f46f1b5e6c6783328","modified":1538906342888},{"_id":"public/tags/PBR/index.html","hash":"3bc6bbc185736bcb4e9f6db2f9ff33ae064d3c0b","modified":1538906342888},{"_id":"public/tags/Ray-Tracing/index.html","hash":"61a995a064a8731b5ab9684b3f595c3201223758","modified":1538906342888},{"_id":"public/tags/Backtracking/index.html","hash":"b26011007494609612d18ca025193e260794fd80","modified":1538906342888},{"_id":"public/tags/Tree/index.html","hash":"e1b6662c0864274a3c34bdf0ebd0738bfb03c7f5","modified":1538906342888},{"_id":"public/tags/SIMD/index.html","hash":"e86ac7115b0b6f6a4a6571022178b48c98099047","modified":1538906342888},{"_id":"public/tags/SSE/index.html","hash":"16e7a3fd0453d72aeda9ee19b7b1f8929aa40161","modified":1538906342889},{"_id":"public/tags/Python/index.html","hash":"2555be6f3f4c44c6f945bfb20d25f1b4b10b7709","modified":1538906342889},{"_id":"public/tags/Sort/index.html","hash":"e0234ba6d1bbefef3be8a3793c3fe578a816b515","modified":1538906342889},{"_id":"public/index.html","hash":"40c7b34b27fbed8cec691dc256edf1b8041996ec","modified":1538906342888},{"_id":"public/page/2/index.html","hash":"b45a0367ffc5e52e7051d16c3a004300c4a73663","modified":1538906342888},{"_id":"public/page/3/index.html","hash":"f932f644c3ae1fdd9e452062805d7c922fbd6ec4","modified":1538906342888},{"_id":"public/categories/Data-Structure/index.html","hash":"1cfdc36677d39d307b6ace297b382403f9da437c","modified":1538906342887},{"_id":"public/categories/Algorithm/index.html","hash":"d4921d8efefe3be348c7262194cc0f70c06eb0d0","modified":1538906342887},{"_id":"public/categories/Graphics/index.html","hash":"81ea28246df0a2571b287fe4038060ad85b413e5","modified":1538906342887},{"_id":"public/categories/Data-Structure/Graph/index.html","hash":"9ea42f7fb9641c3214b764ca78d00c37eac92c45","modified":1538906342887},{"_id":"public/categories/Algorithm/Search/index.html","hash":"fe3b7e5c504e4c37963f1103ead15d1fe0389202","modified":1538906342887},{"_id":"public/categories/Algorithm/Problems/index.html","hash":"263630d3c4bd1bf651e2ffb6616a2f650610f356","modified":1538906342887},{"_id":"public/categories/Graphics/Ray-Tracing/index.html","hash":"abbe5985d7ad9e176dcde0e8bee6a7e0229be8e5","modified":1538906342887},{"_id":"public/categories/Graphics/PBR/index.html","hash":"fb0bbb5d86039069ff4c1780529e2f09811eb8fc","modified":1538906342887},{"_id":"public/categories/Data-Structure/Tree/index.html","hash":"1d013baabc71ca21e2c19113ee88deea33903d51","modified":1538906342887},{"_id":"public/categories/Algorithm/Sort/index.html","hash":"ff2032d6084cd835bf485ae2280db9c4ae8c4700","modified":1538906342887},{"_id":"public/categories/SIMD/index.html","hash":"ec59bb2177fb2e33f9609a317c68945564327d37","modified":1538906342887},{"_id":"public/categories/SIMD/SSE/index.html","hash":"1d36c7f6895b651a9a6ef616ee73f3168cf3500a","modified":1538906342887},{"_id":"public/CNAME","hash":"94b8e7f47adc55215f98ae44acf23612714e185f","modified":1538906320040},{"_id":"public/img/EightQueen/EightQueen1.jpg","hash":"afebe8396c5960f7b86cc8b7e1c46afa7e00719f","modified":1538906320040},{"_id":"public/img/EightQueen/EightQueen2.jpg","hash":"527dcf777845e9df1794721aba349e72514d8bb6","modified":1538906320040},{"_id":"public/img/EightQueen/EightQueen4.jpg","hash":"4b3fcd9e4c5adb75fe48fdd066f9807769a35cea","modified":1538906320040},{"_id":"public/img/EightQueen/EightQueen3.jpg","hash":"0916ef5bfa25f375f5c99b1c3f66e24d9fec49a5","modified":1538906320040},{"_id":"public/img/EightQueen/EightQueen4.png","hash":"2008fc87ac809647ba2125e979e3717bb8ab5780","modified":1538906320040},{"_id":"public/img/EightQueen/EightQueen5.jpg","hash":"dda5d7287f773c4718a0c43c3d44621be1b12c56","modified":1538906320040},{"_id":"public/img/EightQueen/EightQueen3.png","hash":"55b24fb3dd11e95926fd948337de4e1be754b128","modified":1538906320040},{"_id":"public/img/Graph/DG.png","hash":"3f109f92ab19233473b68c0887c350dfc29c2cbe","modified":1538906320040},{"_id":"public/img/Graph/DGBFS.png","hash":"92ad1213be44daa815ac3f96d78c6f25381c9e77","modified":1538906320040},{"_id":"public/img/Graph/DGDFS.png","hash":"50dbdc2f9f60530393e8385ee1f9869eb4216816","modified":1538906320040},{"_id":"public/img/Graph/DGL.png","hash":"511e44b1a6e006a82e3ae073c26d2de9dc24c0fa","modified":1538906320040},{"_id":"public/img/Graph/Topological Order 1.png","hash":"a92ee1e08478e291089514c5e51957f237088852","modified":1538906320040},{"_id":"public/img/Graph/Topological Order 2.png","hash":"27152cc74d170297cd9b82dbc9a4557fb2deb3ec","modified":1538906320040},{"_id":"public/img/Graph/Topological Order.png","hash":"f867623b63241fab5e04aed1520521799cfccc28","modified":1538906320040},{"_id":"public/img/Graph/Topological Order 3.png","hash":"f7b4e744cd747262bd6f2c599c63500f88b38aa6","modified":1538906320040},{"_id":"public/img/Graph/UDG.png","hash":"1e4e63fd2338a6869ce7f4d6d38c6b6adbaa8ca5","modified":1538906320040},{"_id":"public/img/Graph/UDGBFS.png","hash":"79ffb44346348e2235cf5be14db491c357fcf6de","modified":1538906320040},{"_id":"public/img/Graph/UDGDFS.png","hash":"48a59bbc312b4357e0380c048f9a3afd2a8dda54","modified":1538906320040},{"_id":"public/img/Graph/UDGL.png","hash":"988f7a4fe1bf7cca183a00e5ac1e280f0c152348","modified":1538906320040},{"_id":"public/img/RedBlackTree/insertFix2.png","hash":"8f0edd37a6f822917c4ce2ce1810a710859ab95c","modified":1538906320040},{"_id":"public/img/SIMD/Example_SIMD.jpg","hash":"344c55c0be47ef5ee711b6f23078e15c7a0537a1","modified":1538906320040},{"_id":"public/img/RedBlackTree/insertFix4.png","hash":"ab592eaa6d168df2f394de33bc88bc4bd3a9686c","modified":1538906320040},{"_id":"public/img/RedBlackTree/insertFix3.png","hash":"24a2df1c6a5fb3905fe59be4061e2c47d43112bf","modified":1538906320040},{"_id":"public/img/RedBlackTree/leftrotate.jpg","hash":"49d85050b3bfce71707346bb7724840fb0b38c1b","modified":1538906320040},{"_id":"public/img/RedBlackTree/insertFix1.png","hash":"a6e2d8ea99c22ae28b6a06cd1875a198b5945c1f","modified":1538906320041},{"_id":"public/img/RedBlackTree/removeFix1.jpg","hash":"c7f4d2a111411cac60c6c2f20a6d249ff71c6d42","modified":1538906320041},{"_id":"public/img/RedBlackTree/rbtree.png","hash":"a3540c19413961c930ba6c95d27b36b28979cddf","modified":1538906320041},{"_id":"public/img/RedBlackTree/removeFix2.jpg","hash":"2676a21396ea823ed3e3e681dbb7b770fb229eef","modified":1538906320041},{"_id":"public/img/RedBlackTree/removeFix4.jpg","hash":"98a5983478738f8223ca7e1e0550000d5b7c7796","modified":1538906320041},{"_id":"public/img/RedBlackTree/removeFix5.jpg","hash":"adb2c1bd12bdde17cf0ccad0faf0f2054e1a6e8c","modified":1538906320041},{"_id":"public/img/RedBlackTree/removeFix3.jpg","hash":"d97c5b02aa4e43965020156ba43017ce176a90ce","modified":1538906320041},{"_id":"public/img/RedBlackTree/removeFix6.jpg","hash":"c0a4bbe927ddd5e806dbe7c55d1bb61d9c9d3a6f","modified":1538906320041},{"_id":"public/img/RedBlackTree/removeFix7.jpg","hash":"43c63cb1142f3bf0fca2414925c9242e36428458","modified":1538906320041},{"_id":"public/img/RedBlackTree/removeFix8.jpg","hash":"601cb708e278a55107b66801fea317c29e2e8d3c","modified":1538906320041},{"_id":"public/img/RedBlackTree/rightrotate.jpg","hash":"1ccac37948f03661a96695479bb5bb463f3692f0","modified":1538906320041},{"_id":"public/img/PythonSort/3.gif","hash":"2492ae35eb401fb9eadf1d40a4a68310af740891","modified":1538906320041},{"_id":"public/img/PythonSort/5.gif","hash":"44e4ef3163872bf7ea31bdd2d8cec42dbb6a59bd","modified":1538906320041},{"_id":"public/img/Graphics/PBR/BRDF_02.png","hash":"8e73da456386294897bcda65e44558d6bd5f98f6","modified":1538906320041},{"_id":"public/img/Graphics/PBR/BRDF_03.png","hash":"976f66eec8116dbbdba91852dea8011854d4d235","modified":1538906320041},{"_id":"public/img/Graphics/PBR/BRDF_01.png","hash":"8c4df7cb0da280ac7e5c4d387c5a140c6a09e42d","modified":1538906320041},{"_id":"public/img/Graphics/PBR/BRDF_04.png","hash":"4bbd2f9e06c23d2e111182ebf5ebee14f2e491d8","modified":1538906320041},{"_id":"public/img/Graphics/PBR/The_Reflection_Equation_00.png","hash":"4739c9d8c90e1c6a0bb6ac2eaef88c34c00349bc","modified":1538906320041},{"_id":"public/img/Graphics/PBR/The_Reflection_Equation_02.png","hash":"7d239a7792f73aaac00fdd305656533beb14e4d4","modified":1538906320041},{"_id":"public/img/Graphics/PBR/The_Reflection_Equation_03.png","hash":"7821f42769ea6fe03a265464bbb0e0e3cbc7cfeb","modified":1538906320041},{"_id":"public/img/Graphics/PBR/The_Reflection_Equation_04.png","hash":"1364b2fd2d88280aec09809f979c51a3b60b0c97","modified":1538906320041},{"_id":"public/img/Graphics/PBR/Threoy_of_PBR_01.png","hash":"0a2bcf997f4cf600ad3ed2b09b732f34301af97c","modified":1538906320041},{"_id":"public/img/Graphics/PBR/Threoy_of_PBR_03.png","hash":"aacef3c4e055f84a27dae5c0f271a47120b8b24d","modified":1538906320041},{"_id":"public/img/Graphics/PBR/Threoy_of_PBR_02.png","hash":"8c4df7cb0da280ac7e5c4d387c5a140c6a09e42d","modified":1538906320041},{"_id":"public/img/Graphics/PBR/Threoy_of_PBR_04.png","hash":"4f459ddaa9e792763d3acabd643a160bb2505028","modified":1538906320041},{"_id":"public/img/Graphics/PBR/微信图片_20180805233454.jpg","hash":"b0a2e598296355c53ac3ce390f34124d93d2b3ff","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/RayTracing_7.png","hash":"42a24a704c00f0a095aebbc69c2c4d6973192f4c","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/Ray_triangle_Intersection_00.png","hash":"3016afed9473c895bcfd64c77b0bae5a80fb1eb5","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/RayTracing_9.png","hash":"3965313af97cb25ad49ee148c86b2494d02fc8d6","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/epslion_problem_00.png","hash":"c06a175773350d0f1e2e225f632a725624856402","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/lighting_and_matrials_00.png","hash":"4319ca333e40c09474e4ee912345fb25c590e9fd","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/lighting_and_matrials_02.png","hash":"156d4f49ce4136770b3dee0500443230c97c98dc","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/lighting_and_matrials_01.png","hash":"c540703f4c1806c4ae031aa6df73f59ab4b836cd","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/ray_00.png","hash":"534b1f7e60b93238e92d0299292de28b09a079b1","modified":1538906320042},{"_id":"public/img/Graphics/RayTracing/ray_01.png","hash":"99bf187515791e39e5e52c8b09505c674869a643","modified":1538906320042},{"_id":"public/css/images/avatar.jpg","hash":"518573c62ed28c7ae178254e8a5ef5a9286ee79d","modified":1538906320042},{"_id":"public/css/images/logo.jpg","hash":"518573c62ed28c7ae178254e8a5ef5a9286ee79d","modified":1538906320042},{"_id":"public/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1538906320042},{"_id":"public/libs/lightgallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1538906320042},{"_id":"public/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1538906320042},{"_id":"public/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1538906320042},{"_id":"public/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1538906320042},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"5281d2cfb0ef278940c4860ea9aa7ef86d3dbc8d","modified":1538906320042},{"_id":"public/libs/lightgallery/css/lg-transitions.css.map","hash":"6ee19f99bca3ecf2fa0d6f07fb5c200db07ddd11","modified":1538906320042},{"_id":"public/libs/lightgallery/css/lightgallery.css.map","hash":"91788030e3c7107b6b4bf50a82d4309368850488","modified":1538906320042},{"_id":"public/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1538906320042},{"_id":"public/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1538906320042},{"_id":"public/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1538906320042},{"_id":"public/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1538906320042},{"_id":"public/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1538906320042},{"_id":"public/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1538906320043},{"_id":"public/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1538906320043},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1538906320043},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1538906320044},{"_id":"public/img/PythonSort/2.gif","hash":"71405a826cbf59fad388c6b8699adbe9b7311b0d","modified":1538906320415},{"_id":"public/img/PythonSort/6.gif","hash":"0115a5312f9769ac3af29ba959726ba65c475b93","modified":1538906320416},{"_id":"public/img/Graphics/PBR/PBR_0.png","hash":"703d987d99ce101b204bd73004bc5b280488fb10","modified":1538906320417},{"_id":"public/img/Graphics/PBR/The_Reflection_Equation_01.png","hash":"fd34cce7926bac42b5cb8e4132be4ef7a760dfdd","modified":1538906320417},{"_id":"public/img/Graphics/RayTracing/RayTracing_1.png","hash":"e8d75c8c7b0862fb04973e2b14033bd8684cd747","modified":1538906320417},{"_id":"public/img/Graphics/RayTracing/RayTracing_5.png","hash":"6c98e66001d3830bd98f9fd033e8eb8d1e9e5105","modified":1538906320417},{"_id":"public/img/Graphics/RayTracing/Ray_box_Intersection_00.png","hash":"c7b2e7daee192eb60a97a757f8773221a25ce981","modified":1538906320417},{"_id":"public/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1538906320417},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1538906320417},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1538906320417},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1538906320417},{"_id":"public/js/insight.js","hash":"c1bafa7f87e9f25fca1e033fc6d1e0c82712ac99","modified":1538906320424},{"_id":"public/js/main.js","hash":"23b373067df0dbac27622bc7537bb4fda243a9c8","modified":1538906320424},{"_id":"public/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1538906320424},{"_id":"public/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1538906320425},{"_id":"public/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1538906320425},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1538906320425},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1538906320425},{"_id":"public/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1538906320425},{"_id":"public/css/style.css","hash":"4141bd636a2a5c879889f6495fdb4946fdaf6a21","modified":1538906320425},{"_id":"public/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1538906320425},{"_id":"public/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1538906320425},{"_id":"public/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1538906320425},{"_id":"public/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1538906320425},{"_id":"public/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1538906320426},{"_id":"public/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1538906320426},{"_id":"public/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1538906320426},{"_id":"public/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1538906320426},{"_id":"public/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1538906320426},{"_id":"public/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1538906320426},{"_id":"public/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1538906320426},{"_id":"public/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1538906320426},{"_id":"public/img/Graphics/PBR/BRDF_00.png","hash":"d897d09a7bf4e8cd5e34118a0dbc24219e064a60","modified":1538906320426},{"_id":"public/img/Graphics/RayTracing/RayTracing_0.png","hash":"f050562b527284a9b76bec5ccb9857b58850b9b9","modified":1538906320426},{"_id":"public/img/Graphics/RayTracing/RayTracing_4.png","hash":"6f436edc58161262ec6b726e6bf8eb34582a0068","modified":1538906320426},{"_id":"public/img/Graphics/RayTracing/RayTracing_3.png","hash":"caf63df55a8d9f6247249481500d53aaba6c40a7","modified":1538906320426},{"_id":"public/img/Graphics/RayTracing/RayTracing_6.png","hash":"245764b151284dc8d8dde9f5bb6ec9713361cf6e","modified":1538906320426},{"_id":"public/img/Graphics/RayTracing/RayTracing_8.png","hash":"a30c12b747043a442d66e9910adcbe39babacd8a","modified":1538906320426},{"_id":"public/img/Graphics/RayTracing/ray_02.png","hash":"2c87a727b697bf883b5838cb6abe742a02a2b570","modified":1538906320426},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1538906320426},{"_id":"public/img/Graphics/PBR/Threoy_of_PBR_00.png","hash":"598d37c32c06960d34d0ad3e348fe9fe813eab35","modified":1538906320448},{"_id":"public/img/Graphics/RayTracing/DoRayTracing_00.png","hash":"18fe9f9f8c4b6ac17d65589f242b03619e2c91d0","modified":1538906320449},{"_id":"public/img/Graphics/RayTracing/DoRayTracing_01.png","hash":"1c977d540b9d9fe95d3dc8b28571cf5f4517c41d","modified":1538906320449},{"_id":"public/img/Graphics/RayTracing/epslion_problem_01.png","hash":"386383a8c09afb13baa0bb395751f1a83aceaea3","modified":1538906320449},{"_id":"public/img/PythonSort/4.gif","hash":"d70822274ca52ebc2c925fb94e81dc6a11591afa","modified":1538906320485},{"_id":"public/img/about_img/EL_3.PNG","hash":"7aa08b67da917fc579691275a3443a27c96ac6d5","modified":1538906320489},{"_id":"public/img/about_img/PA_0.PNG","hash":"853a41ae658f0c0a8313a3ea145e8a045f1c7b8b","modified":1538906320489},{"_id":"public/img/Graphics/RayTracing/RayTracing_2.png","hash":"e6ff16ccc916af662c330f80d48e00c312935c2b","modified":1538906320489},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"964e8dac2cee79c4b49b5bc300675773f6518812","modified":1538906320489},{"_id":"public/img/about_img/EL_4.PNG","hash":"675e70abd06119df33b9b51abe3611aece03872d","modified":1538906320496},{"_id":"public/img/Graphics/RayTracing/RayTracing_10.png","hash":"8483cae98c3e9d7bc80b068e2ec643797160e1cb","modified":1538906320536},{"_id":"public/img/about_img/EL_1.PNG","hash":"068136d92ab86383eb7e1a63bc92d23ce97bf3b2","modified":1538906320539},{"_id":"public/img/PythonSort/1.gif","hash":"6393fd6978c778adeb8e449f2c2c41d8fee5164d","modified":1538906320540},{"_id":"public/img/about_img/EL_2.PNG","hash":"ac2962b5a980a618d36d4e33ccf90f3e7002c77c","modified":1538906320542},{"_id":"public/img/about_img/EL_0.PNG","hash":"259c77d58a222f82c205befc5e9ab45c10dbc41a","modified":1538906320543},{"_id":"public/file/lec09_ray_tracing.pdf","hash":"44f9cc621dd50937ecccc188f73daabef4ed8e82","modified":1538906320549}],"Category":[{"name":"Data Structure","_id":"cjmyp36to0003ssb99eiuuntv"},{"name":"Algorithm","_id":"cjmyp36tt0008ssb9cnqtx5p2"},{"name":"Graphics","_id":"cjmyp36u0000gssb90nhbobhc"},{"name":"Graph","parent":"cjmyp36to0003ssb99eiuuntv","_id":"cjmyp36u3000mssb95frocty9"},{"name":"Search","parent":"cjmyp36tt0008ssb9cnqtx5p2","_id":"cjmyp36ua000vssb9l62vaqzf"},{"name":"Problems","parent":"cjmyp36tt0008ssb9cnqtx5p2","_id":"cjmyp36uq001tssb9lo1n28e7"},{"name":"Ray Tracing","parent":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36us001yssb98afd4xuh"},{"name":"PBR","parent":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36ut0023ssb9krm6kx33"},{"name":"Tree","parent":"cjmyp36to0003ssb99eiuuntv","_id":"cjmyp36ux002jssb9hzp08a3i"},{"name":"SIMD","_id":"cjmyp36v3002yssb9j9q3givm"},{"name":"Sort","parent":"cjmyp36tt0008ssb9cnqtx5p2","_id":"cjmyp36v50035ssb9irmgvpqk"},{"name":"SSE","parent":"cjmyp36v3002yssb9j9q3givm","_id":"cjmyp36vg0047ssb94f2gq7r3"}],"Data":[],"Page":[{"title":"about","date":"2018-03-01T15:06:49.000Z","_content":"\n# About Me","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-03-01 23:06:49\n---\n\n# About Me","updated":"2018-08-26T13:53:29.674Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjmyp36tm0001ssb9t88fbjnp","content":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1>"}],"Post":[{"title":"Adjacency List Graph","date":"2018-03-05T16:40:11.000Z","thumbnail":"http://hucoco.com/img/Graph/UDG.png","_content":"\n[Adjacency List Graph Chinese version address](http://hucoco.coding.me/2016/11/18/Graph/GraphByList/)\n\n# Adjacency List Graph\n\n## Adjacency List Undirected Graph\n\nAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency list.\n\n![Adjacency Matrix Undirected Graph](http://hucoco.com/img/Graph/UDG.png)\n\nThe above graph contains 7 vertices of `A, B, C, D, E, F, G`, and it also contains`<A,C>, <A,D>, <A,F>, <B,C>, <C,D>, <E,G>, <F,G>`, in total 7 edges. Since this is an undirected graph, the edge `<A,C>` and the edge `<C,A>` are the same edges. The table of edges is listed in alphabetical order..\n\n<!--more-->\n\n![Undirected Adjacency List](http://hucoco.com/img/Graph/UDGL.png)\n\nEach vertex contains a linked list that records the index of vertexs. For example, the data of the nodes included in the linked list included in the second vertex (vertex C) is `0, 1, 3`, and `0, 1, 3` corresponds to the index of `A, B, D`.\n\n### C++ Definition\n\n```\n// Work in progress\n```\n\n### C++ Implementation\n\n```\n// Work in progress\n```\n\n## Adjacency Matrix Directed Graph\n\nAdjacency matrix directed graph refers to an directed graph represented by an adjacency list.\n\n![Adjacency Matrix Directed Graph](http://hucoco.com/img/Graph/DG.png)\n\nThe above graph contains 7 vertices of `A, B, C, D, E, F, G`, and it also contains `<A,B>, <B,C>, <B,E>, <B,F>, <C,E>, <D,C>, <E,B>, <E,D>, <F,G>`, in total 7 edges.\n\n![Directed Adjacency Matrix](http://hucoco.com/img/Graph/DGL.png)\n\nEach vertex contains a linked list that records the index of vertexs.\n\nThe linked list contains the index of the other vertex of the out-edge corresponding to this vertex. For example, the data of the first vertex (vertex B) in list is `2,4,5`, this `2,4,5` corresponds to index of `C, E, F`, and `C, E, F` are the other vertices of B vertex's out-edge.\n\n### C++ Definition\n\n```\n// Work in progress\n```\n\n### C++ Implementation\n\n```\n// Work in progress\n```","source":"_posts/Adjacency-List-Graph.md","raw":"---\ntitle: Adjacency List Graph\ndate: 2018-03-06 00:40:11\nthumbnail: http://hucoco.com/img/Graph/UDG.png\ntags: \n- C++\n- Data Structure\n- Graph\ncategories:\n- Data Structure\n- Graph\n---\n\n[Adjacency List Graph Chinese version address](http://hucoco.coding.me/2016/11/18/Graph/GraphByList/)\n\n# Adjacency List Graph\n\n## Adjacency List Undirected Graph\n\nAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency list.\n\n![Adjacency Matrix Undirected Graph](http://hucoco.com/img/Graph/UDG.png)\n\nThe above graph contains 7 vertices of `A, B, C, D, E, F, G`, and it also contains`<A,C>, <A,D>, <A,F>, <B,C>, <C,D>, <E,G>, <F,G>`, in total 7 edges. Since this is an undirected graph, the edge `<A,C>` and the edge `<C,A>` are the same edges. The table of edges is listed in alphabetical order..\n\n<!--more-->\n\n![Undirected Adjacency List](http://hucoco.com/img/Graph/UDGL.png)\n\nEach vertex contains a linked list that records the index of vertexs. For example, the data of the nodes included in the linked list included in the second vertex (vertex C) is `0, 1, 3`, and `0, 1, 3` corresponds to the index of `A, B, D`.\n\n### C++ Definition\n\n```\n// Work in progress\n```\n\n### C++ Implementation\n\n```\n// Work in progress\n```\n\n## Adjacency Matrix Directed Graph\n\nAdjacency matrix directed graph refers to an directed graph represented by an adjacency list.\n\n![Adjacency Matrix Directed Graph](http://hucoco.com/img/Graph/DG.png)\n\nThe above graph contains 7 vertices of `A, B, C, D, E, F, G`, and it also contains `<A,B>, <B,C>, <B,E>, <B,F>, <C,E>, <D,C>, <E,B>, <E,D>, <F,G>`, in total 7 edges.\n\n![Directed Adjacency Matrix](http://hucoco.com/img/Graph/DGL.png)\n\nEach vertex contains a linked list that records the index of vertexs.\n\nThe linked list contains the index of the other vertex of the out-edge corresponding to this vertex. For example, the data of the first vertex (vertex B) in list is `2,4,5`, this `2,4,5` corresponds to index of `C, E, F`, and `C, E, F` are the other vertices of B vertex's out-edge.\n\n### C++ Definition\n\n```\n// Work in progress\n```\n\n### C++ Implementation\n\n```\n// Work in progress\n```","slug":"Adjacency-List-Graph","published":1,"updated":"2018-03-07T16:04:09.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36ti0000ssb9stwd6acs","content":"<p><a href=\"http://hucoco.coding.me/2016/11/18/Graph/GraphByList/\" target=\"_blank\" rel=\"noopener\">Adjacency List Graph Chinese version address</a></p>\n<h1 id=\"Adjacency-List-Graph\"><a href=\"#Adjacency-List-Graph\" class=\"headerlink\" title=\"Adjacency List Graph\"></a>Adjacency List Graph</h1><h2 id=\"Adjacency-List-Undirected-Graph\"><a href=\"#Adjacency-List-Undirected-Graph\" class=\"headerlink\" title=\"Adjacency List Undirected Graph\"></a>Adjacency List Undirected Graph</h2><p>Adjacency matrix undirected graph refers to an undirected graph represented by an adjacency list.</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Adjacency Matrix Undirected Graph\"></p>\n<p>The above graph contains 7 vertices of <code>A, B, C, D, E, F, G</code>, and it also contains<code>&lt;A,C&gt;, &lt;A,D&gt;, &lt;A,F&gt;, &lt;B,C&gt;, &lt;C,D&gt;, &lt;E,G&gt;, &lt;F,G&gt;</code>, in total 7 edges. Since this is an undirected graph, the edge <code>&lt;A,C&gt;</code> and the edge <code>&lt;C,A&gt;</code> are the same edges. The table of edges is listed in alphabetical order..</p>\n<a id=\"more\"></a>\n<p><img src=\"http://hucoco.com/img/Graph/UDGL.png\" alt=\"Undirected Adjacency List\"></p>\n<p>Each vertex contains a linked list that records the index of vertexs. For example, the data of the nodes included in the linked list included in the second vertex (vertex C) is <code>0, 1, 3</code>, and <code>0, 1, 3</code> corresponds to the index of <code>A, B, D</code>.</p>\n<h3 id=\"C-Definition\"><a href=\"#C-Definition\" class=\"headerlink\" title=\"C++ Definition\"></a>C++ Definition</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-Implementation\"><a href=\"#C-Implementation\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h2 id=\"Adjacency-Matrix-Directed-Graph\"><a href=\"#Adjacency-Matrix-Directed-Graph\" class=\"headerlink\" title=\"Adjacency Matrix Directed Graph\"></a>Adjacency Matrix Directed Graph</h2><p>Adjacency matrix directed graph refers to an directed graph represented by an adjacency list.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Adjacency Matrix Directed Graph\"></p>\n<p>The above graph contains 7 vertices of <code>A, B, C, D, E, F, G</code>, and it also contains <code>&lt;A,B&gt;, &lt;B,C&gt;, &lt;B,E&gt;, &lt;B,F&gt;, &lt;C,E&gt;, &lt;D,C&gt;, &lt;E,B&gt;, &lt;E,D&gt;, &lt;F,G&gt;</code>, in total 7 edges.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGL.png\" alt=\"Directed Adjacency Matrix\"></p>\n<p>Each vertex contains a linked list that records the index of vertexs.</p>\n<p>The linked list contains the index of the other vertex of the out-edge corresponding to this vertex. For example, the data of the first vertex (vertex B) in list is <code>2,4,5</code>, this <code>2,4,5</code> corresponds to index of <code>C, E, F</code>, and <code>C, E, F</code> are the other vertices of B vertex’s out-edge.</p>\n<h3 id=\"C-Definition-1\"><a href=\"#C-Definition-1\" class=\"headerlink\" title=\"C++ Definition\"></a>C++ Definition</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-Implementation-1\"><a href=\"#C-Implementation-1\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/18/Graph/GraphByList/\" target=\"_blank\" rel=\"noopener\">Adjacency List Graph Chinese version address</a></p>\n<h1 id=\"Adjacency-List-Graph\"><a href=\"#Adjacency-List-Graph\" class=\"headerlink\" title=\"Adjacency List Graph\"></a>Adjacency List Graph</h1><h2 id=\"Adjacency-List-Undirected-Graph\"><a href=\"#Adjacency-List-Undirected-Graph\" class=\"headerlink\" title=\"Adjacency List Undirected Graph\"></a>Adjacency List Undirected Graph</h2><p>Adjacency matrix undirected graph refers to an undirected graph represented by an adjacency list.</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Adjacency Matrix Undirected Graph\"></p>\n<p>The above graph contains 7 vertices of <code>A, B, C, D, E, F, G</code>, and it also contains<code>&lt;A,C&gt;, &lt;A,D&gt;, &lt;A,F&gt;, &lt;B,C&gt;, &lt;C,D&gt;, &lt;E,G&gt;, &lt;F,G&gt;</code>, in total 7 edges. Since this is an undirected graph, the edge <code>&lt;A,C&gt;</code> and the edge <code>&lt;C,A&gt;</code> are the same edges. The table of edges is listed in alphabetical order..</p>","more":"<p><img src=\"http://hucoco.com/img/Graph/UDGL.png\" alt=\"Undirected Adjacency List\"></p>\n<p>Each vertex contains a linked list that records the index of vertexs. For example, the data of the nodes included in the linked list included in the second vertex (vertex C) is <code>0, 1, 3</code>, and <code>0, 1, 3</code> corresponds to the index of <code>A, B, D</code>.</p>\n<h3 id=\"C-Definition\"><a href=\"#C-Definition\" class=\"headerlink\" title=\"C++ Definition\"></a>C++ Definition</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-Implementation\"><a href=\"#C-Implementation\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h2 id=\"Adjacency-Matrix-Directed-Graph\"><a href=\"#Adjacency-Matrix-Directed-Graph\" class=\"headerlink\" title=\"Adjacency Matrix Directed Graph\"></a>Adjacency Matrix Directed Graph</h2><p>Adjacency matrix directed graph refers to an directed graph represented by an adjacency list.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Adjacency Matrix Directed Graph\"></p>\n<p>The above graph contains 7 vertices of <code>A, B, C, D, E, F, G</code>, and it also contains <code>&lt;A,B&gt;, &lt;B,C&gt;, &lt;B,E&gt;, &lt;B,F&gt;, &lt;C,E&gt;, &lt;D,C&gt;, &lt;E,B&gt;, &lt;E,D&gt;, &lt;F,G&gt;</code>, in total 7 edges.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGL.png\" alt=\"Directed Adjacency Matrix\"></p>\n<p>Each vertex contains a linked list that records the index of vertexs.</p>\n<p>The linked list contains the index of the other vertex of the out-edge corresponding to this vertex. For example, the data of the first vertex (vertex B) in list is <code>2,4,5</code>, this <code>2,4,5</code> corresponds to index of <code>C, E, F</code>, and <code>C, E, F</code> are the other vertices of B vertex’s out-edge.</p>\n<h3 id=\"C-Definition-1\"><a href=\"#C-Definition-1\" class=\"headerlink\" title=\"C++ Definition\"></a>C++ Definition</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-Implementation-1\"><a href=\"#C-Implementation-1\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>"},{"title":"Breadth First Search","date":"2018-03-07T15:18:11.000Z","thumbnail":"http://hucoco.com/img/Graph/DGBFS.png","_content":"\n[Breadth First Search Chinese version address](http://hucoco.coding.me/2016/11/22/Graph/BFS/)\n\n# Breadth First Search\n\n## Overview\n\nThe breadth first search algorithm, also known as \"width first search\" or \"horizontal priority search\", is called BFS.\n\nFrom a vertex in the graph, each of the not visited adjacent points of the V is accessed in turn after accessing the starting vertex, then the adjacency points are accessed in turn from these adjacent points, and the adjacent points of the vertex to be accessed are accessed before the adjacent points of the vertices that are accessed, until all the adjacent points of the vertices are accessed. If the vertices are not accessed at this time, we need to select another vertex which has never been visited as a new starting point, repeat the above process until all the vertices in the graph are accessed.\n\nIn other words, the process of breadth first search is the starting point and from near to far, access to the path and the path length of the starting vertex and the path length of 1,2...\n\n## Diagram\n\n### Breadth first search for undirected graphs\n\nThe following is an example of undirected graph, to demonstrate the depth-first search.\n\n![Undirected Graphs](http://hucoco.com/img/Graph/UDG.png)\n\n<!--more-->\n\nBreadth first search of the graph above, starting with vertex A:\n\n![Step Diagram](http://hucoco.com/img/Graph/UDGBFS.png)\n\n#### Steps:\n\n1. Access to A.\n2. Access C, D, F in turn. After visiting A, next visit A's adjoining point. the vertices A,B,C,D,E,F,G are stored in order, so first visit C, after visiting C, next to visit D and F.\n3. Access B, G, in turn. After C, D, and F are accessed in the second step, then their adjacency points are accessed in turn. Next first access the adjacency point B of C, and then access the adjacency point G of the F.\n4. Access to E. After accessing B and G in the third step, the adjacent points are accessed in turn. Only G has a adjacency point E, so access to the adjacency point E of the G.\n\n#### C++ Implememtation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```\n\n\n### Breadth first search for undirected graphs\n\nThe following is an example of directed graph, to demonstrate the Breadth first search.\n\n![Directed Graphs](http://hucoco.com/img/Graph/DG.png)\n\n<!--more-->\n\nBreadth first search of the graph above, starting with vertex A:\n\n![Step Diagram](http://hucoco.com/img/Graph/DGBFS.png)\n\n#### Steps:\n\n1. Access to A.\n2. Access to B.\n3. Access C, E, F in turn. After accessing the B, next to the other vertex of the B's out-edge, that is, C, E, and F.\n4. Access D, G in turn. After accessing C, E, and F, the other vertices of the out-edge of their are accessed in turn.\n\n#### C++ Implememtation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```","source":"_posts/Breadth-First-Search.md","raw":"---\ntitle: Breadth First Search\ndate: 2018-03-07 23:18:11\nthumbnail: http://hucoco.com/img/Graph/DGBFS.png\ntags: \n- C++\n- Algorithm\n- Graph\ncategories:\n- Algorithm\n- Search\n---\n\n[Breadth First Search Chinese version address](http://hucoco.coding.me/2016/11/22/Graph/BFS/)\n\n# Breadth First Search\n\n## Overview\n\nThe breadth first search algorithm, also known as \"width first search\" or \"horizontal priority search\", is called BFS.\n\nFrom a vertex in the graph, each of the not visited adjacent points of the V is accessed in turn after accessing the starting vertex, then the adjacency points are accessed in turn from these adjacent points, and the adjacent points of the vertex to be accessed are accessed before the adjacent points of the vertices that are accessed, until all the adjacent points of the vertices are accessed. If the vertices are not accessed at this time, we need to select another vertex which has never been visited as a new starting point, repeat the above process until all the vertices in the graph are accessed.\n\nIn other words, the process of breadth first search is the starting point and from near to far, access to the path and the path length of the starting vertex and the path length of 1,2...\n\n## Diagram\n\n### Breadth first search for undirected graphs\n\nThe following is an example of undirected graph, to demonstrate the depth-first search.\n\n![Undirected Graphs](http://hucoco.com/img/Graph/UDG.png)\n\n<!--more-->\n\nBreadth first search of the graph above, starting with vertex A:\n\n![Step Diagram](http://hucoco.com/img/Graph/UDGBFS.png)\n\n#### Steps:\n\n1. Access to A.\n2. Access C, D, F in turn. After visiting A, next visit A's adjoining point. the vertices A,B,C,D,E,F,G are stored in order, so first visit C, after visiting C, next to visit D and F.\n3. Access B, G, in turn. After C, D, and F are accessed in the second step, then their adjacency points are accessed in turn. Next first access the adjacency point B of C, and then access the adjacency point G of the F.\n4. Access to E. After accessing B and G in the third step, the adjacent points are accessed in turn. Only G has a adjacency point E, so access to the adjacency point E of the G.\n\n#### C++ Implememtation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```\n\n\n### Breadth first search for undirected graphs\n\nThe following is an example of directed graph, to demonstrate the Breadth first search.\n\n![Directed Graphs](http://hucoco.com/img/Graph/DG.png)\n\n<!--more-->\n\nBreadth first search of the graph above, starting with vertex A:\n\n![Step Diagram](http://hucoco.com/img/Graph/DGBFS.png)\n\n#### Steps:\n\n1. Access to A.\n2. Access to B.\n3. Access C, E, F in turn. After accessing the B, next to the other vertex of the B's out-edge, that is, C, E, and F.\n4. Access D, G in turn. After accessing C, E, and F, the other vertices of the out-edge of their are accessed in turn.\n\n#### C++ Implememtation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```","slug":"Breadth-First-Search","published":1,"updated":"2018-03-07T16:04:30.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36tn0002ssb90oto3efv","content":"<p><a href=\"http://hucoco.coding.me/2016/11/22/Graph/BFS/\" target=\"_blank\" rel=\"noopener\">Breadth First Search Chinese version address</a></p>\n<h1 id=\"Breadth-First-Search\"><a href=\"#Breadth-First-Search\" class=\"headerlink\" title=\"Breadth First Search\"></a>Breadth First Search</h1><h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>The breadth first search algorithm, also known as “width first search” or “horizontal priority search”, is called BFS.</p>\n<p>From a vertex in the graph, each of the not visited adjacent points of the V is accessed in turn after accessing the starting vertex, then the adjacency points are accessed in turn from these adjacent points, and the adjacent points of the vertex to be accessed are accessed before the adjacent points of the vertices that are accessed, until all the adjacent points of the vertices are accessed. If the vertices are not accessed at this time, we need to select another vertex which has never been visited as a new starting point, repeat the above process until all the vertices in the graph are accessed.</p>\n<p>In other words, the process of breadth first search is the starting point and from near to far, access to the path and the path length of the starting vertex and the path length of 1,2…</p>\n<h2 id=\"Diagram\"><a href=\"#Diagram\" class=\"headerlink\" title=\"Diagram\"></a>Diagram</h2><h3 id=\"Breadth-first-search-for-undirected-graphs\"><a href=\"#Breadth-first-search-for-undirected-graphs\" class=\"headerlink\" title=\"Breadth first search for undirected graphs\"></a>Breadth first search for undirected graphs</h3><p>The following is an example of undirected graph, to demonstrate the depth-first search.</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Undirected Graphs\"></p>\n<a id=\"more\"></a>\n<p>Breadth first search of the graph above, starting with vertex A:</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDGBFS.png\" alt=\"Step Diagram\"></p>\n<h4 id=\"Steps\"><a href=\"#Steps\" class=\"headerlink\" title=\"Steps:\"></a>Steps:</h4><ol>\n<li>Access to A.</li>\n<li>Access C, D, F in turn. After visiting A, next visit A’s adjoining point. the vertices A,B,C,D,E,F,G are stored in order, so first visit C, after visiting C, next to visit D and F.</li>\n<li>Access B, G, in turn. After C, D, and F are accessed in the second step, then their adjacency points are accessed in turn. Next first access the adjacency point B of C, and then access the adjacency point G of the F.</li>\n<li>Access to E. After accessing B and G in the third step, the adjacent points are accessed in turn. Only G has a adjacency point E, so access to the adjacency point E of the G.</li>\n</ol>\n<h4 id=\"C-Implememtation\"><a href=\"#C-Implememtation\" class=\"headerlink\" title=\"C++ Implememtation\"></a>C++ Implememtation</h4><h5 id=\"Adjacency-Matrix-Version\"><a href=\"#Adjacency-Matrix-Version\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version\"><a href=\"#Adjacency-List-Version\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"Breadth-first-search-for-undirected-graphs-1\"><a href=\"#Breadth-first-search-for-undirected-graphs-1\" class=\"headerlink\" title=\"Breadth first search for undirected graphs\"></a>Breadth first search for undirected graphs</h3><p>The following is an example of directed graph, to demonstrate the Breadth first search.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Directed Graphs\"></p>\n<!--more-->\n<p>Breadth first search of the graph above, starting with vertex A:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGBFS.png\" alt=\"Step Diagram\"></p>\n<h4 id=\"Steps-1\"><a href=\"#Steps-1\" class=\"headerlink\" title=\"Steps:\"></a>Steps:</h4><ol>\n<li>Access to A.</li>\n<li>Access to B.</li>\n<li>Access C, E, F in turn. After accessing the B, next to the other vertex of the B’s out-edge, that is, C, E, and F.</li>\n<li>Access D, G in turn. After accessing C, E, and F, the other vertices of the out-edge of their are accessed in turn.</li>\n</ol>\n<h4 id=\"C-Implememtation-1\"><a href=\"#C-Implememtation-1\" class=\"headerlink\" title=\"C++ Implememtation\"></a>C++ Implememtation</h4><h5 id=\"Adjacency-Matrix-Version-1\"><a href=\"#Adjacency-Matrix-Version-1\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version-1\"><a href=\"#Adjacency-List-Version-1\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/22/Graph/BFS/\" target=\"_blank\" rel=\"noopener\">Breadth First Search Chinese version address</a></p>\n<h1 id=\"Breadth-First-Search\"><a href=\"#Breadth-First-Search\" class=\"headerlink\" title=\"Breadth First Search\"></a>Breadth First Search</h1><h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>The breadth first search algorithm, also known as “width first search” or “horizontal priority search”, is called BFS.</p>\n<p>From a vertex in the graph, each of the not visited adjacent points of the V is accessed in turn after accessing the starting vertex, then the adjacency points are accessed in turn from these adjacent points, and the adjacent points of the vertex to be accessed are accessed before the adjacent points of the vertices that are accessed, until all the adjacent points of the vertices are accessed. If the vertices are not accessed at this time, we need to select another vertex which has never been visited as a new starting point, repeat the above process until all the vertices in the graph are accessed.</p>\n<p>In other words, the process of breadth first search is the starting point and from near to far, access to the path and the path length of the starting vertex and the path length of 1,2…</p>\n<h2 id=\"Diagram\"><a href=\"#Diagram\" class=\"headerlink\" title=\"Diagram\"></a>Diagram</h2><h3 id=\"Breadth-first-search-for-undirected-graphs\"><a href=\"#Breadth-first-search-for-undirected-graphs\" class=\"headerlink\" title=\"Breadth first search for undirected graphs\"></a>Breadth first search for undirected graphs</h3><p>The following is an example of undirected graph, to demonstrate the depth-first search.</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Undirected Graphs\"></p>","more":"<p>Breadth first search of the graph above, starting with vertex A:</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDGBFS.png\" alt=\"Step Diagram\"></p>\n<h4 id=\"Steps\"><a href=\"#Steps\" class=\"headerlink\" title=\"Steps:\"></a>Steps:</h4><ol>\n<li>Access to A.</li>\n<li>Access C, D, F in turn. After visiting A, next visit A’s adjoining point. the vertices A,B,C,D,E,F,G are stored in order, so first visit C, after visiting C, next to visit D and F.</li>\n<li>Access B, G, in turn. After C, D, and F are accessed in the second step, then their adjacency points are accessed in turn. Next first access the adjacency point B of C, and then access the adjacency point G of the F.</li>\n<li>Access to E. After accessing B and G in the third step, the adjacent points are accessed in turn. Only G has a adjacency point E, so access to the adjacency point E of the G.</li>\n</ol>\n<h4 id=\"C-Implememtation\"><a href=\"#C-Implememtation\" class=\"headerlink\" title=\"C++ Implememtation\"></a>C++ Implememtation</h4><h5 id=\"Adjacency-Matrix-Version\"><a href=\"#Adjacency-Matrix-Version\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version\"><a href=\"#Adjacency-List-Version\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"Breadth-first-search-for-undirected-graphs-1\"><a href=\"#Breadth-first-search-for-undirected-graphs-1\" class=\"headerlink\" title=\"Breadth first search for undirected graphs\"></a>Breadth first search for undirected graphs</h3><p>The following is an example of directed graph, to demonstrate the Breadth first search.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Directed Graphs\"></p>\n<!--more-->\n<p>Breadth first search of the graph above, starting with vertex A:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGBFS.png\" alt=\"Step Diagram\"></p>\n<h4 id=\"Steps-1\"><a href=\"#Steps-1\" class=\"headerlink\" title=\"Steps:\"></a>Steps:</h4><ol>\n<li>Access to A.</li>\n<li>Access to B.</li>\n<li>Access C, E, F in turn. After accessing the B, next to the other vertex of the B’s out-edge, that is, C, E, and F.</li>\n<li>Access D, G in turn. After accessing C, E, and F, the other vertices of the out-edge of their are accessed in turn.</li>\n</ol>\n<h4 id=\"C-Implememtation-1\"><a href=\"#C-Implememtation-1\" class=\"headerlink\" title=\"C++ Implememtation\"></a>C++ Implememtation</h4><h5 id=\"Adjacency-Matrix-Version-1\"><a href=\"#Adjacency-Matrix-Version-1\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version-1\"><a href=\"#Adjacency-List-Version-1\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>"},{"title":"Adjacency Matrix Graph","date":"2018-03-05T16:40:02.000Z","thumbnail":"http://hucoco.com/img/Graph/UDG.png","_content":"\n[Adjacency Matrix Graph Chinese version address](http://hucoco.coding.me/2016/11/16/Graph/GraphByMatrix/)\n\n# Adjacency Matrix Graph\n\n## Adjacency Matrix Undirected Graph\n\nAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency matrix.\n\n![Adjacency Matrix Undirected Graph](http://hucoco.com/img/Graph/UDG.png)\n\nThe above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains<A,C>, <A,D>, <A,F>, <B,C>, <C,D>, <E,G>, <F,G>, in total 7 edges. Since this is an undirected graph, the edge <A,C> and the edge <C,A>are the same edges. The table of edges is listed in alphabetical order.\n\n<!--more-->\n\n|N/A|A|B|C|D|E|F|G|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|A|0|0|1|1|0|1|0|\n|B|0|0|1|0|0|0|0|\n|C|1|1|0|1|0|0|0|\n|D|1|0|1|0|0|0|0|\n|E|0|0|0|0|0|0|1|\n|F|1|0|0|0|0|0|1|\n|G|0|0|0|0|1|1|0|\n\nThe matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that from the ith vertex to the jth vertex is a edge. A[i][j] = 0 indicates that they are not adjacent points.\n\n### C++ Definition\n\n```\n// Work in progress\n```\n\n### C++ Implementation\n\n```\n// Work in progress\n```\n\n## Adjacency Matrix Directed Graph\n\nAdjacency matrix undirected graph refers to an directed graph represented by an adjacency matrix.\n\n![Adjacency Matrix Directed Graph](http://hucoco.com/img/Graph/DG.png)\n\nThe above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains <A,B>, <B,C>, <B,E>, <B,F>, <C,E>, <D,C>, <E,B>, <E,D>, <F,G>, in total 7 edges.\n\n|N/A|A|B|C|D|E|F|G|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|A|0|0|1|0|0|0|0|\n|B|0|0|1|0|1|1|0|\n|C|0|0|0|0|1|0|0|\n|D|0|0|1|0|0|0|0|\n|E|0|1|0|1|0|0|1|\n|F|0|0|0|0|0|0|1|\n|G|0|0|0|0|0|0|0|\n\nThe matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that the ith vertex and the jth vertex are adjacent points. A[i][j] = 0 indicates that not a edge.\n\n### C++ Definition\n\n```\n// Work in progress\n```\n\n### C++ Implementation\n\n```\n// Work in progress\n```","source":"_posts/Adjacency-Matrix-Graph.md","raw":"---\ntitle: Adjacency Matrix Graph\ndate: 2018-03-06 00:40:02\nthumbnail: http://hucoco.com/img/Graph/UDG.png\ntags: \n- C++\n- Data Structure\n- Graph\ncategories:\n- Data Structure\n- Graph\n---\n\n[Adjacency Matrix Graph Chinese version address](http://hucoco.coding.me/2016/11/16/Graph/GraphByMatrix/)\n\n# Adjacency Matrix Graph\n\n## Adjacency Matrix Undirected Graph\n\nAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency matrix.\n\n![Adjacency Matrix Undirected Graph](http://hucoco.com/img/Graph/UDG.png)\n\nThe above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains<A,C>, <A,D>, <A,F>, <B,C>, <C,D>, <E,G>, <F,G>, in total 7 edges. Since this is an undirected graph, the edge <A,C> and the edge <C,A>are the same edges. The table of edges is listed in alphabetical order.\n\n<!--more-->\n\n|N/A|A|B|C|D|E|F|G|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|A|0|0|1|1|0|1|0|\n|B|0|0|1|0|0|0|0|\n|C|1|1|0|1|0|0|0|\n|D|1|0|1|0|0|0|0|\n|E|0|0|0|0|0|0|1|\n|F|1|0|0|0|0|0|1|\n|G|0|0|0|0|1|1|0|\n\nThe matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that from the ith vertex to the jth vertex is a edge. A[i][j] = 0 indicates that they are not adjacent points.\n\n### C++ Definition\n\n```\n// Work in progress\n```\n\n### C++ Implementation\n\n```\n// Work in progress\n```\n\n## Adjacency Matrix Directed Graph\n\nAdjacency matrix undirected graph refers to an directed graph represented by an adjacency matrix.\n\n![Adjacency Matrix Directed Graph](http://hucoco.com/img/Graph/DG.png)\n\nThe above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains <A,B>, <B,C>, <B,E>, <B,F>, <C,E>, <D,C>, <E,B>, <E,D>, <F,G>, in total 7 edges.\n\n|N/A|A|B|C|D|E|F|G|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|A|0|0|1|0|0|0|0|\n|B|0|0|1|0|1|1|0|\n|C|0|0|0|0|1|0|0|\n|D|0|0|1|0|0|0|0|\n|E|0|1|0|1|0|0|1|\n|F|0|0|0|0|0|0|1|\n|G|0|0|0|0|0|0|0|\n\nThe matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that the ith vertex and the jth vertex are adjacent points. A[i][j] = 0 indicates that not a edge.\n\n### C++ Definition\n\n```\n// Work in progress\n```\n\n### C++ Implementation\n\n```\n// Work in progress\n```","slug":"Adjacency-Matrix-Graph","published":1,"updated":"2018-03-07T16:03:45.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36tq0005ssb9t2ldbzkd","content":"<p><a href=\"http://hucoco.coding.me/2016/11/16/Graph/GraphByMatrix/\" target=\"_blank\" rel=\"noopener\">Adjacency Matrix Graph Chinese version address</a></p>\n<h1 id=\"Adjacency-Matrix-Graph\"><a href=\"#Adjacency-Matrix-Graph\" class=\"headerlink\" title=\"Adjacency Matrix Graph\"></a>Adjacency Matrix Graph</h1><h2 id=\"Adjacency-Matrix-Undirected-Graph\"><a href=\"#Adjacency-Matrix-Undirected-Graph\" class=\"headerlink\" title=\"Adjacency Matrix Undirected Graph\"></a>Adjacency Matrix Undirected Graph</h2><p>Adjacency matrix undirected graph refers to an undirected graph represented by an adjacency matrix.</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Adjacency Matrix Undirected Graph\"></p>\n<p>The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains<a,c>, <a,d>, <a,f>, <b,c>, <c,d>, <e,g>, <f,g>, in total 7 edges. Since this is an undirected graph, the edge <a,c> and the edge <c,a>are the same edges. The table of edges is listed in alphabetical order.</c,a></a,c></f,g></e,g></c,d></b,c></a,f></a,d></a,c></p>\n<a id=\"more\"></a>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">N/A</th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>The matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that from the ith vertex to the jth vertex is a edge. A[i][j] = 0 indicates that they are not adjacent points.</p>\n<h3 id=\"C-Definition\"><a href=\"#C-Definition\" class=\"headerlink\" title=\"C++ Definition\"></a>C++ Definition</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-Implementation\"><a href=\"#C-Implementation\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h2 id=\"Adjacency-Matrix-Directed-Graph\"><a href=\"#Adjacency-Matrix-Directed-Graph\" class=\"headerlink\" title=\"Adjacency Matrix Directed Graph\"></a>Adjacency Matrix Directed Graph</h2><p>Adjacency matrix undirected graph refers to an directed graph represented by an adjacency matrix.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Adjacency Matrix Directed Graph\"></p>\n<p>The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains <a,b>, <b,c>, <b,e>, <b,f>, <c,e>, <d,c>, <e,b>, <e,d>, <f,g>, in total 7 edges.</f,g></e,d></e,b></d,c></c,e></b,f></b,e></b,c></a,b></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">N/A</th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>The matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that the ith vertex and the jth vertex are adjacent points. A[i][j] = 0 indicates that not a edge.</p>\n<h3 id=\"C-Definition-1\"><a href=\"#C-Definition-1\" class=\"headerlink\" title=\"C++ Definition\"></a>C++ Definition</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-Implementation-1\"><a href=\"#C-Implementation-1\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/16/Graph/GraphByMatrix/\" target=\"_blank\" rel=\"noopener\">Adjacency Matrix Graph Chinese version address</a></p>\n<h1 id=\"Adjacency-Matrix-Graph\"><a href=\"#Adjacency-Matrix-Graph\" class=\"headerlink\" title=\"Adjacency Matrix Graph\"></a>Adjacency Matrix Graph</h1><h2 id=\"Adjacency-Matrix-Undirected-Graph\"><a href=\"#Adjacency-Matrix-Undirected-Graph\" class=\"headerlink\" title=\"Adjacency Matrix Undirected Graph\"></a>Adjacency Matrix Undirected Graph</h2><p>Adjacency matrix undirected graph refers to an undirected graph represented by an adjacency matrix.</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Adjacency Matrix Undirected Graph\"></p>\n<p>The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains<a,c>, <a,d>, <a,f>, <b,c>, <c,d>, <e,g>, <f,g>, in total 7 edges. Since this is an undirected graph, the edge <a,c> and the edge <c,a>are the same edges. The table of edges is listed in alphabetical order.</c,a></a,c></f,g></e,g></c,d></b,c></a,f></a,d></a,c></p>","more":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">N/A</th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>The matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that from the ith vertex to the jth vertex is a edge. A[i][j] = 0 indicates that they are not adjacent points.</p>\n<h3 id=\"C-Definition\"><a href=\"#C-Definition\" class=\"headerlink\" title=\"C++ Definition\"></a>C++ Definition</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-Implementation\"><a href=\"#C-Implementation\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h2 id=\"Adjacency-Matrix-Directed-Graph\"><a href=\"#Adjacency-Matrix-Directed-Graph\" class=\"headerlink\" title=\"Adjacency Matrix Directed Graph\"></a>Adjacency Matrix Directed Graph</h2><p>Adjacency matrix undirected graph refers to an directed graph represented by an adjacency matrix.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Adjacency Matrix Directed Graph\"></p>\n<p>The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains <a,b>, <b,c>, <b,e>, <b,f>, <c,e>, <d,c>, <e,b>, <e,d>, <f,g>, in total 7 edges.</f,g></e,d></e,b></d,c></c,e></b,f></b,e></b,c></a,b></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">N/A</th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>The matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that the ith vertex and the jth vertex are adjacent points. A[i][j] = 0 indicates that not a edge.</p>\n<h3 id=\"C-Definition-1\"><a href=\"#C-Definition-1\" class=\"headerlink\" title=\"C++ Definition\"></a>C++ Definition</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-Implementation-1\"><a href=\"#C-Implementation-1\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>"},{"title":"BRDF","date":"2018-07-12T14:07:13.000Z","thumbnail":"http://hucoco.com/img/Graphics/PBR/BRDF_00.png","mathjax":true,"_content":"\nThe **BRDF**, or **Bidirectional Reflective Distribution Function** is a function that takes as input the incoming (light) direction $\\omega_i$, the outgoing (view) direction $\\omega_o$, the surface normal $n$ and a surface parameter a that represents the microsurface's roughness. The BRDF approximates how much each individual light ray $\\omega_i$ contributes to the final reflected light of an opaque surface given its material properties. For instance, if the surface has a perfectly smooth surface (like a mirror) the BRDF function would return 0.0 for all incoming light rays $\\omega_i$ except the one ray that has the same (reflected) angle as the outgoing ray $\\omega_o$ at which the function returns 1.0.\n\nA BRDF approximates the material's reflective and refractive properties based on the previously discussed microfacet theory. For a BRDF to be physically plausible it has to respect the law of energy conservation i.e. the sum of reflected light should never exceed the amount of incoming light. Technically, Blinn-Phong is considered a BRDF taking the same $\\omega_i$ and $\\omega_o$ as inputs. However, Blinn-Phong is not considered physically based as it doesn't adhere to the energy conservation principle. There are several physically based BRDFs out there to approximate the surface's reaction to light. However, almost all real-time render pipelines use a BRDF known as the **Cook-Torrance BRDF**.\n\nThe Cook-Torrance BRDF contains both a diffuse and specular part:\n\n$$f_r = k_d f_{lambert} + k_s f_{cook-torrance}$$\n\n<!--more-->\n\n## Diffuse Part\n\nHere kd is the earlier mentioned ratio of incoming light energy that gets refracted with ks being the ratio that gets reflected. The left side of the BRDF states the diffuse part of the equation denoted here as flambert. This is known as Lambertian diffuse similar to what we used for diffuse shading which is a constant factor denoted as:\n\n$$f_{lambert} = \\frac{c}{\\pi}$$\n\nWith c being the albedo or surface color (think of the diffuse surface texture). The divide by pi is there to normalize the diffuse light as the earlier denoted integral that contains the BRDF is scaled by $\\pi$\n\nYou might wonder how this Lambertian diffuse relates to the diffuse term we've been using before: the surface color multiplied by the dot product between the surface's normal and the light direction. The dot product is still there, but moved out of the BRDF as we find $n \\cdot \\omega_i$ at the end of the $L_o$ integral.\n\nThere exist different equations for the diffuse part of the BRDF which tend to look more realistic, but are also more computationally expensive. As concluded by Epic Games however, the Lambertian diffuse is sufficient enough for most real-time rendering purposes.\n\n## Specluar Part\n\nThe specular part of the BRDF is a bit more advanced and is described as:\n\n$$f_{cook-torrance} = \\frac{DFG}{4(\\omega_o \\cdot n)(\\omega_i \\cdot n)} $$\n\nhe Cook-Torrance specular BRDF consists of three functions and a normalization factor in the denominator. Each of the D, F and G symbols represent a type of function that approximates a specific part of the surface's reflective properties. These are defined as the normal **D**istribution function, the **F**resnel equation and the **G**eometry function:\n\n* **Normal distribution function:** approximates the amount the surface's microfacets are aligned to the halfway vector influenced by the roughness of the surface; this is the primary function approximating the microfacets.\n* **Geometry function:** describes the self-shadowing property of the microfacets. When a surface is relatively rough the surface's microfacets can overshadow other microfacets thereby reducing the light the surface reflects.\n* **Fresnel equation:** The Fresnel equation describes the ratio of surface reflection at different surface angles.\n\n### Normal distribution function\n\nThe normal distribution function **D** statistically approximates the relative surface area of microfacets exactly aligned to the (halfway) vector $h$. There are a multitude of NDFs defined that statistically approximate the general alignment of the microfacets given some roughness parameter and the one we'll be using is known as the Trowbridge-Reitz GGX:\n\n$$NDF_{GGX}(n,h,\\alpha) = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2 - 1) + 1)^2}$$\n\nHere $h$ is the halfway vector to measure against the surface's microfacets, with a being a measure of the surface's roughness. If we take $h$ as the halfway vector between the surface normal and light direction over varying roughness parameters we get the following visual result:\n\n![](http://hucoco.com/img/Graphics/PBR/BRDF_01.png)\n\nWhen the roughness is low (thus the surface is smooth) a highly concentrated number of microfacets are aligned to halfway vectors over a small radius. Due to this high concentration the NDF displays a very bright spot. On a rough surface however, where the microfacets are aligned in much more random directions, you'll find a much larger number of halfway vectors h somewhat aligned to the microfacets, but less concentrated giving us the more grayish results.\n\nIn GLSL code the Trowbridge-Reitz GGX normal distribution function would look a bit like this:\n\n```c\nfloat NormalDistributionFunction(float NoH, float Roughness)\n{\n    float a = Roughness * Roughness;\n    float a2 = a * a;\n    float NdotH = max(NoH, 0.0f);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = 3.141592 * denom * denom;\n\n    return nom / denom;\n}\n```\n\n### Geometry function\n\nThe geometry function statistically approximates the relative surface area where its micro surface-details overshadow each other causing light rays to be occluded.\n\n![](http://hucoco.com/img/Graphics/PBR/BRDF_02.png)\n\nSimilar to the NDF, the Geometry function takes a material's roughness parameter as input with rougher surfaces having a higher probability of overshadowing microfacets. The geometry function we will use is a combination of the GGX and Schlick-Beckmann approximation known as Schlick-GGX:\n\n$$G_{schlickGGX}(n,v,k) = \\frac{n \\cdot v}{(n \\cdot v)(1-k) + k}$$\n\nHere $k$ is a remapping of α based on whether we're using the geometry function for either direct lighting or IBL lighting:\n\n$$k_{direct} = \\frac{(\\alpha + 1)^2}{8}$$\n\n$$k_{IBL} = \\frac{\\alpha^2}{2} $$\n\nNote that the value of $\\alpha$ might differ based on how your engine translates roughness to $\\alpha$. In the following tutorials we'll extensively discuss how and where this remapping becomes relevant.\n\nTo effectively approximate the geometry we need to take account of both the view direction (geometry obstruction) and the light direction vector (geometry shadowing). We can take both into account using Smith's method:\n\n$$G(n,v,l,k) = G_{sub}(n,v,k)G_{sub}(n,l,k)$$\n\nUsing Smith's method with Schlick-GGX as $G_{sub}$ gives the following visual appearance over varying roughness R:\n\n![](http://hucoco.com/img/Graphics/PBR/BRDF_03.png)\n\nThe geometry function is a multiplier between [0.0, 1.0] with white or 1.0 measuring no microfacet shadowing and black or 0.0 complete microfacet shadowing.\n\nIn GLSL the geometry function translates to the following code:\n\n```c\nfloat GeometrychlickGGX(float NoV, float k)\n{\n    float nom = NoV;\n    float denom = NoV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometryFunction(vec3 N, vec3 V, vec3 L, float Roughness)\n{\n    float k = pow(Roughness + 1, 2) / 8.0f;\n    float NoV = max(dot(N, V), 0.0);\n    float NoL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrychlickGGX(NoV, k);\n    float ggx2 = GeometrychlickGGX(NoL, k);\n\n    return ggx1 * ggx2;\n}\n```\n\n### Fresnel equation\n\nThe Fresnel equation (pronounced as Freh-nel) describes the ratio of light that gets reflected over the light that gets refracted, which varies over the angle we're looking at a surface. The moment light hits a surface, based on the surface to view angle the Fresnel equation tells us the percentage of light that gets reflected. From this ratio of reflection and the energy conservation principle we can directly obtain the refracted portion of light from its remaining energy.\n\nEvery surface or material has a level of base reflectivity when looking straight at its surface, but when looking at the surface from an angle all reflections become more apparent compared to the surface's base reflectivity. You can check this for yourself by looking at your presumably wooden/metallic desk which has a certain level of base reflectivity from a perpendicular view angle, but by looking at your desk from an almost 90 degree angle you'll see the reflections become much more apparent. All surfaces theoretically fully reflect light if seen from perfect 90-degree angles. This phenomenon is known as Fresnel and is described by the Fresnel equation.\n\nThe Fresnel equation is a rather complex equation, but luckily the Fresnel equation can be approximated using the Fresnel-Schlick approximation:\n\n$$F_{schlick}(h,v,F_0) = F_0 + (1 - F_0)(1 - (h \\cdot v))^5$$\n\n$F_0$ represents the base reflectivity of the surface, which we calculate using something called the indices of refraction or IOR and as you can see on a sphere surface, the more we look towards the surface's grazing angles (with the halfway-view angle reaching 90 degrees) the stronger the Fresnel and thus the reflections:\n\n![](http://hucoco.com/img/Graphics/PBR/BRDF_04.png)\n\nThere are a few subtleties involved with the Fresnel equation. One is that the Fresnel-Schlick approximation is only really defined for dielectric or non-metal surfaces. For conductor surfaces (metals) calculating the base reflectivity using their indices of refraction doesn't properly hold and we need to use a different Fresnel equation for conductors altogether. As this is inconvenient we further approximate by pre-computing the surface's response at normal incidence ($F0$) (at a 0 degree angle as if looking directly onto a surface) and interpolate this value based on the view angle as per the Fresnel-Schlick approximation such that we can use the same equation for both metals and non-metals.\n\nThese specific attributes of metallic surfaces compared to dielectric surfaces gave rise to something called the metallic workflow where we author surface materials with an extra parameter known as metalness that describes whether a surface is either a metallic or a non-metallic surface.\n\nTheoretically the metalness of a surface is binary: it's either a metal or it isn't; it can't be both. However, most render pipelines allow configuring the metalness of a surface linearly between 0.0 and 1.0. This is mostly because of the lack of material texture precision to describe for instance a surface having small dust/sand-like particles/scratches over a metallic surface. By balancing the metalness value around these small non-metallic like particles/scratches we get visually pleasable results.\n\n```c\nvec3 FresnelEquation(vec3 N, vec3 V, vec3 F)\n{\n    float NoV = dot(N, V);\n    vec3 res = F + (vec3(1.0f) - F) * pow(1.0f - NoV, 5);\n    return res;\n}\n```\n\n### Cook-Torrance reflectance equation\n\nWith every component of the Cook-Torrance BRDF described we can include the physically based BRDF into the now final reflectance equation:\n\n$$L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + k_s \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_i$$\n\nThis equation is however not fully mathematically correct. You may remember that the Fresnel term $F$ represents the ratio of light that gets reflected on a surface. This is effectively our ratio $k_s$, meaning the specular part of the reflectance equation implicitly contains the reflectance ratio $k_s$. Given this, our final final reflectance equation becomes:\n\n$$L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_i$$\n\nThis equation now completely describes a physically based render model that is generally recognized as what we commonly understand as physically based rendering or PBR. Don't worry if you didn't yet completely understand how we'll need to fit all the discussed mathematics together in code. In the next tutorials, we'll explore how to utilize the reflectance equation to get much more physically plausible results in our rendered lighting and all the bits and pieces should slowly start to fit together.\n\n## Reference\n\n**[Learn OpenGL PBR Theory](https://learnopengl.com/PBR/Theory) **","source":"_posts/BRDF.md","raw":"---\ntitle: BRDF\ndate: 2018-07-12 22:07:13\nthumbnail: http://hucoco.com/img/Graphics/PBR/BRDF_00.png\nmathjax: true\ntags: \n- Graphics\n- PBR\ncategories:\n- Graphics\n- PBR\n---\n\nThe **BRDF**, or **Bidirectional Reflective Distribution Function** is a function that takes as input the incoming (light) direction $\\omega_i$, the outgoing (view) direction $\\omega_o$, the surface normal $n$ and a surface parameter a that represents the microsurface's roughness. The BRDF approximates how much each individual light ray $\\omega_i$ contributes to the final reflected light of an opaque surface given its material properties. For instance, if the surface has a perfectly smooth surface (like a mirror) the BRDF function would return 0.0 for all incoming light rays $\\omega_i$ except the one ray that has the same (reflected) angle as the outgoing ray $\\omega_o$ at which the function returns 1.0.\n\nA BRDF approximates the material's reflective and refractive properties based on the previously discussed microfacet theory. For a BRDF to be physically plausible it has to respect the law of energy conservation i.e. the sum of reflected light should never exceed the amount of incoming light. Technically, Blinn-Phong is considered a BRDF taking the same $\\omega_i$ and $\\omega_o$ as inputs. However, Blinn-Phong is not considered physically based as it doesn't adhere to the energy conservation principle. There are several physically based BRDFs out there to approximate the surface's reaction to light. However, almost all real-time render pipelines use a BRDF known as the **Cook-Torrance BRDF**.\n\nThe Cook-Torrance BRDF contains both a diffuse and specular part:\n\n$$f_r = k_d f_{lambert} + k_s f_{cook-torrance}$$\n\n<!--more-->\n\n## Diffuse Part\n\nHere kd is the earlier mentioned ratio of incoming light energy that gets refracted with ks being the ratio that gets reflected. The left side of the BRDF states the diffuse part of the equation denoted here as flambert. This is known as Lambertian diffuse similar to what we used for diffuse shading which is a constant factor denoted as:\n\n$$f_{lambert} = \\frac{c}{\\pi}$$\n\nWith c being the albedo or surface color (think of the diffuse surface texture). The divide by pi is there to normalize the diffuse light as the earlier denoted integral that contains the BRDF is scaled by $\\pi$\n\nYou might wonder how this Lambertian diffuse relates to the diffuse term we've been using before: the surface color multiplied by the dot product between the surface's normal and the light direction. The dot product is still there, but moved out of the BRDF as we find $n \\cdot \\omega_i$ at the end of the $L_o$ integral.\n\nThere exist different equations for the diffuse part of the BRDF which tend to look more realistic, but are also more computationally expensive. As concluded by Epic Games however, the Lambertian diffuse is sufficient enough for most real-time rendering purposes.\n\n## Specluar Part\n\nThe specular part of the BRDF is a bit more advanced and is described as:\n\n$$f_{cook-torrance} = \\frac{DFG}{4(\\omega_o \\cdot n)(\\omega_i \\cdot n)} $$\n\nhe Cook-Torrance specular BRDF consists of three functions and a normalization factor in the denominator. Each of the D, F and G symbols represent a type of function that approximates a specific part of the surface's reflective properties. These are defined as the normal **D**istribution function, the **F**resnel equation and the **G**eometry function:\n\n* **Normal distribution function:** approximates the amount the surface's microfacets are aligned to the halfway vector influenced by the roughness of the surface; this is the primary function approximating the microfacets.\n* **Geometry function:** describes the self-shadowing property of the microfacets. When a surface is relatively rough the surface's microfacets can overshadow other microfacets thereby reducing the light the surface reflects.\n* **Fresnel equation:** The Fresnel equation describes the ratio of surface reflection at different surface angles.\n\n### Normal distribution function\n\nThe normal distribution function **D** statistically approximates the relative surface area of microfacets exactly aligned to the (halfway) vector $h$. There are a multitude of NDFs defined that statistically approximate the general alignment of the microfacets given some roughness parameter and the one we'll be using is known as the Trowbridge-Reitz GGX:\n\n$$NDF_{GGX}(n,h,\\alpha) = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2 - 1) + 1)^2}$$\n\nHere $h$ is the halfway vector to measure against the surface's microfacets, with a being a measure of the surface's roughness. If we take $h$ as the halfway vector between the surface normal and light direction over varying roughness parameters we get the following visual result:\n\n![](http://hucoco.com/img/Graphics/PBR/BRDF_01.png)\n\nWhen the roughness is low (thus the surface is smooth) a highly concentrated number of microfacets are aligned to halfway vectors over a small radius. Due to this high concentration the NDF displays a very bright spot. On a rough surface however, where the microfacets are aligned in much more random directions, you'll find a much larger number of halfway vectors h somewhat aligned to the microfacets, but less concentrated giving us the more grayish results.\n\nIn GLSL code the Trowbridge-Reitz GGX normal distribution function would look a bit like this:\n\n```c\nfloat NormalDistributionFunction(float NoH, float Roughness)\n{\n    float a = Roughness * Roughness;\n    float a2 = a * a;\n    float NdotH = max(NoH, 0.0f);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = 3.141592 * denom * denom;\n\n    return nom / denom;\n}\n```\n\n### Geometry function\n\nThe geometry function statistically approximates the relative surface area where its micro surface-details overshadow each other causing light rays to be occluded.\n\n![](http://hucoco.com/img/Graphics/PBR/BRDF_02.png)\n\nSimilar to the NDF, the Geometry function takes a material's roughness parameter as input with rougher surfaces having a higher probability of overshadowing microfacets. The geometry function we will use is a combination of the GGX and Schlick-Beckmann approximation known as Schlick-GGX:\n\n$$G_{schlickGGX}(n,v,k) = \\frac{n \\cdot v}{(n \\cdot v)(1-k) + k}$$\n\nHere $k$ is a remapping of α based on whether we're using the geometry function for either direct lighting or IBL lighting:\n\n$$k_{direct} = \\frac{(\\alpha + 1)^2}{8}$$\n\n$$k_{IBL} = \\frac{\\alpha^2}{2} $$\n\nNote that the value of $\\alpha$ might differ based on how your engine translates roughness to $\\alpha$. In the following tutorials we'll extensively discuss how and where this remapping becomes relevant.\n\nTo effectively approximate the geometry we need to take account of both the view direction (geometry obstruction) and the light direction vector (geometry shadowing). We can take both into account using Smith's method:\n\n$$G(n,v,l,k) = G_{sub}(n,v,k)G_{sub}(n,l,k)$$\n\nUsing Smith's method with Schlick-GGX as $G_{sub}$ gives the following visual appearance over varying roughness R:\n\n![](http://hucoco.com/img/Graphics/PBR/BRDF_03.png)\n\nThe geometry function is a multiplier between [0.0, 1.0] with white or 1.0 measuring no microfacet shadowing and black or 0.0 complete microfacet shadowing.\n\nIn GLSL the geometry function translates to the following code:\n\n```c\nfloat GeometrychlickGGX(float NoV, float k)\n{\n    float nom = NoV;\n    float denom = NoV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometryFunction(vec3 N, vec3 V, vec3 L, float Roughness)\n{\n    float k = pow(Roughness + 1, 2) / 8.0f;\n    float NoV = max(dot(N, V), 0.0);\n    float NoL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrychlickGGX(NoV, k);\n    float ggx2 = GeometrychlickGGX(NoL, k);\n\n    return ggx1 * ggx2;\n}\n```\n\n### Fresnel equation\n\nThe Fresnel equation (pronounced as Freh-nel) describes the ratio of light that gets reflected over the light that gets refracted, which varies over the angle we're looking at a surface. The moment light hits a surface, based on the surface to view angle the Fresnel equation tells us the percentage of light that gets reflected. From this ratio of reflection and the energy conservation principle we can directly obtain the refracted portion of light from its remaining energy.\n\nEvery surface or material has a level of base reflectivity when looking straight at its surface, but when looking at the surface from an angle all reflections become more apparent compared to the surface's base reflectivity. You can check this for yourself by looking at your presumably wooden/metallic desk which has a certain level of base reflectivity from a perpendicular view angle, but by looking at your desk from an almost 90 degree angle you'll see the reflections become much more apparent. All surfaces theoretically fully reflect light if seen from perfect 90-degree angles. This phenomenon is known as Fresnel and is described by the Fresnel equation.\n\nThe Fresnel equation is a rather complex equation, but luckily the Fresnel equation can be approximated using the Fresnel-Schlick approximation:\n\n$$F_{schlick}(h,v,F_0) = F_0 + (1 - F_0)(1 - (h \\cdot v))^5$$\n\n$F_0$ represents the base reflectivity of the surface, which we calculate using something called the indices of refraction or IOR and as you can see on a sphere surface, the more we look towards the surface's grazing angles (with the halfway-view angle reaching 90 degrees) the stronger the Fresnel and thus the reflections:\n\n![](http://hucoco.com/img/Graphics/PBR/BRDF_04.png)\n\nThere are a few subtleties involved with the Fresnel equation. One is that the Fresnel-Schlick approximation is only really defined for dielectric or non-metal surfaces. For conductor surfaces (metals) calculating the base reflectivity using their indices of refraction doesn't properly hold and we need to use a different Fresnel equation for conductors altogether. As this is inconvenient we further approximate by pre-computing the surface's response at normal incidence ($F0$) (at a 0 degree angle as if looking directly onto a surface) and interpolate this value based on the view angle as per the Fresnel-Schlick approximation such that we can use the same equation for both metals and non-metals.\n\nThese specific attributes of metallic surfaces compared to dielectric surfaces gave rise to something called the metallic workflow where we author surface materials with an extra parameter known as metalness that describes whether a surface is either a metallic or a non-metallic surface.\n\nTheoretically the metalness of a surface is binary: it's either a metal or it isn't; it can't be both. However, most render pipelines allow configuring the metalness of a surface linearly between 0.0 and 1.0. This is mostly because of the lack of material texture precision to describe for instance a surface having small dust/sand-like particles/scratches over a metallic surface. By balancing the metalness value around these small non-metallic like particles/scratches we get visually pleasable results.\n\n```c\nvec3 FresnelEquation(vec3 N, vec3 V, vec3 F)\n{\n    float NoV = dot(N, V);\n    vec3 res = F + (vec3(1.0f) - F) * pow(1.0f - NoV, 5);\n    return res;\n}\n```\n\n### Cook-Torrance reflectance equation\n\nWith every component of the Cook-Torrance BRDF described we can include the physically based BRDF into the now final reflectance equation:\n\n$$L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + k_s \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_i$$\n\nThis equation is however not fully mathematically correct. You may remember that the Fresnel term $F$ represents the ratio of light that gets reflected on a surface. This is effectively our ratio $k_s$, meaning the specular part of the reflectance equation implicitly contains the reflectance ratio $k_s$. Given this, our final final reflectance equation becomes:\n\n$$L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_i$$\n\nThis equation now completely describes a physically based render model that is generally recognized as what we commonly understand as physically based rendering or PBR. Don't worry if you didn't yet completely understand how we'll need to fit all the discussed mathematics together in code. In the next tutorials, we'll explore how to utilize the reflectance equation to get much more physically plausible results in our rendered lighting and all the bits and pieces should slowly start to fit together.\n\n## Reference\n\n**[Learn OpenGL PBR Theory](https://learnopengl.com/PBR/Theory) **","slug":"BRDF","published":1,"updated":"2018-07-15T13:11:41.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36tr0006ssb9ouvkeetm","content":"<p>The <strong>BRDF</strong>, or <strong>Bidirectional Reflective Distribution Function</strong> is a function that takes as input the incoming (light) direction $\\omega_i$, the outgoing (view) direction $\\omega_o$, the surface normal $n$ and a surface parameter a that represents the microsurface’s roughness. The BRDF approximates how much each individual light ray $\\omega_i$ contributes to the final reflected light of an opaque surface given its material properties. For instance, if the surface has a perfectly smooth surface (like a mirror) the BRDF function would return 0.0 for all incoming light rays $\\omega_i$ except the one ray that has the same (reflected) angle as the outgoing ray $\\omega_o$ at which the function returns 1.0.</p>\n<p>A BRDF approximates the material’s reflective and refractive properties based on the previously discussed microfacet theory. For a BRDF to be physically plausible it has to respect the law of energy conservation i.e. the sum of reflected light should never exceed the amount of incoming light. Technically, Blinn-Phong is considered a BRDF taking the same $\\omega_i$ and $\\omega_o$ as inputs. However, Blinn-Phong is not considered physically based as it doesn’t adhere to the energy conservation principle. There are several physically based BRDFs out there to approximate the surface’s reaction to light. However, almost all real-time render pipelines use a BRDF known as the <strong>Cook-Torrance BRDF</strong>.</p>\n<p>The Cook-Torrance BRDF contains both a diffuse and specular part:</p>\n<script type=\"math/tex; mode=display\">f_r = k_d f_{lambert} + k_s f_{cook-torrance}</script><a id=\"more\"></a>\n<h2 id=\"Diffuse-Part\"><a href=\"#Diffuse-Part\" class=\"headerlink\" title=\"Diffuse Part\"></a>Diffuse Part</h2><p>Here kd is the earlier mentioned ratio of incoming light energy that gets refracted with ks being the ratio that gets reflected. The left side of the BRDF states the diffuse part of the equation denoted here as flambert. This is known as Lambertian diffuse similar to what we used for diffuse shading which is a constant factor denoted as:</p>\n<script type=\"math/tex; mode=display\">f_{lambert} = \\frac{c}{\\pi}</script><p>With c being the albedo or surface color (think of the diffuse surface texture). The divide by pi is there to normalize the diffuse light as the earlier denoted integral that contains the BRDF is scaled by $\\pi$</p>\n<p>You might wonder how this Lambertian diffuse relates to the diffuse term we’ve been using before: the surface color multiplied by the dot product between the surface’s normal and the light direction. The dot product is still there, but moved out of the BRDF as we find $n \\cdot \\omega_i$ at the end of the $L_o$ integral.</p>\n<p>There exist different equations for the diffuse part of the BRDF which tend to look more realistic, but are also more computationally expensive. As concluded by Epic Games however, the Lambertian diffuse is sufficient enough for most real-time rendering purposes.</p>\n<h2 id=\"Specluar-Part\"><a href=\"#Specluar-Part\" class=\"headerlink\" title=\"Specluar Part\"></a>Specluar Part</h2><p>The specular part of the BRDF is a bit more advanced and is described as:</p>\n<script type=\"math/tex; mode=display\">f_{cook-torrance} = \\frac{DFG}{4(\\omega_o \\cdot n)(\\omega_i \\cdot n)}</script><p>he Cook-Torrance specular BRDF consists of three functions and a normalization factor in the denominator. Each of the D, F and G symbols represent a type of function that approximates a specific part of the surface’s reflective properties. These are defined as the normal <strong>D</strong>istribution function, the <strong>F</strong>resnel equation and the <strong>G</strong>eometry function:</p>\n<ul>\n<li><strong>Normal distribution function:</strong> approximates the amount the surface’s microfacets are aligned to the halfway vector influenced by the roughness of the surface; this is the primary function approximating the microfacets.</li>\n<li><strong>Geometry function:</strong> describes the self-shadowing property of the microfacets. When a surface is relatively rough the surface’s microfacets can overshadow other microfacets thereby reducing the light the surface reflects.</li>\n<li><strong>Fresnel equation:</strong> The Fresnel equation describes the ratio of surface reflection at different surface angles.</li>\n</ul>\n<h3 id=\"Normal-distribution-function\"><a href=\"#Normal-distribution-function\" class=\"headerlink\" title=\"Normal distribution function\"></a>Normal distribution function</h3><p>The normal distribution function <strong>D</strong> statistically approximates the relative surface area of microfacets exactly aligned to the (halfway) vector $h$. There are a multitude of NDFs defined that statistically approximate the general alignment of the microfacets given some roughness parameter and the one we’ll be using is known as the Trowbridge-Reitz GGX:</p>\n<script type=\"math/tex; mode=display\">NDF_{GGX}(n,h,\\alpha) = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2 - 1) + 1)^2}</script><p>Here $h$ is the halfway vector to measure against the surface’s microfacets, with a being a measure of the surface’s roughness. If we take $h$ as the halfway vector between the surface normal and light direction over varying roughness parameters we get the following visual result:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/BRDF_01.png\" alt=\"\"></p>\n<p>When the roughness is low (thus the surface is smooth) a highly concentrated number of microfacets are aligned to halfway vectors over a small radius. Due to this high concentration the NDF displays a very bright spot. On a rough surface however, where the microfacets are aligned in much more random directions, you’ll find a much larger number of halfway vectors h somewhat aligned to the microfacets, but less concentrated giving us the more grayish results.</p>\n<p>In GLSL code the Trowbridge-Reitz GGX normal distribution function would look a bit like this:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">NormalDistributionFunction</span><span class=\"params\">(<span class=\"keyword\">float</span> NoH, <span class=\"keyword\">float</span> Roughness)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> a = Roughness * Roughness;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> a2 = a * a;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NdotH = max(NoH, <span class=\"number\">0.0f</span>);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NdotH2 = NdotH * NdotH;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">float</span> nom = a2;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> denom = (NdotH2 * (a2 - <span class=\"number\">1.0</span>) + <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    denom = <span class=\"number\">3.141592</span> * denom * denom;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nom / denom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Geometry-function\"><a href=\"#Geometry-function\" class=\"headerlink\" title=\"Geometry function\"></a>Geometry function</h3><p>The geometry function statistically approximates the relative surface area where its micro surface-details overshadow each other causing light rays to be occluded.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/BRDF_02.png\" alt=\"\"></p>\n<p>Similar to the NDF, the Geometry function takes a material’s roughness parameter as input with rougher surfaces having a higher probability of overshadowing microfacets. The geometry function we will use is a combination of the GGX and Schlick-Beckmann approximation known as Schlick-GGX:</p>\n<script type=\"math/tex; mode=display\">G_{schlickGGX}(n,v,k) = \\frac{n \\cdot v}{(n \\cdot v)(1-k) + k}</script><p>Here $k$ is a remapping of α based on whether we’re using the geometry function for either direct lighting or IBL lighting:</p>\n<script type=\"math/tex; mode=display\">k_{direct} = \\frac{(\\alpha + 1)^2}{8}</script><script type=\"math/tex; mode=display\">k_{IBL} = \\frac{\\alpha^2}{2}</script><p>Note that the value of $\\alpha$ might differ based on how your engine translates roughness to $\\alpha$. In the following tutorials we’ll extensively discuss how and where this remapping becomes relevant.</p>\n<p>To effectively approximate the geometry we need to take account of both the view direction (geometry obstruction) and the light direction vector (geometry shadowing). We can take both into account using Smith’s method:</p>\n<script type=\"math/tex; mode=display\">G(n,v,l,k) = G_{sub}(n,v,k)G_{sub}(n,l,k)</script><p>Using Smith’s method with Schlick-GGX as $G_{sub}$ gives the following visual appearance over varying roughness R:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/BRDF_03.png\" alt=\"\"></p>\n<p>The geometry function is a multiplier between [0.0, 1.0] with white or 1.0 measuring no microfacet shadowing and black or 0.0 complete microfacet shadowing.</p>\n<p>In GLSL the geometry function translates to the following code:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">GeometrychlickGGX</span><span class=\"params\">(<span class=\"keyword\">float</span> NoV, <span class=\"keyword\">float</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> nom = NoV;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> denom = NoV * (<span class=\"number\">1.0</span> - k) + k;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nom / denom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">GeometryFunction</span><span class=\"params\">(vec3 N, vec3 V, vec3 L, <span class=\"keyword\">float</span> Roughness)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> k = <span class=\"built_in\">pow</span>(Roughness + <span class=\"number\">1</span>, <span class=\"number\">2</span>) / <span class=\"number\">8.0f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NoV = max(dot(N, V), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NoL = max(dot(N, L), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> ggx1 = GeometrychlickGGX(NoV, k);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> ggx2 = GeometrychlickGGX(NoL, k);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ggx1 * ggx2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Fresnel-equation\"><a href=\"#Fresnel-equation\" class=\"headerlink\" title=\"Fresnel equation\"></a>Fresnel equation</h3><p>The Fresnel equation (pronounced as Freh-nel) describes the ratio of light that gets reflected over the light that gets refracted, which varies over the angle we’re looking at a surface. The moment light hits a surface, based on the surface to view angle the Fresnel equation tells us the percentage of light that gets reflected. From this ratio of reflection and the energy conservation principle we can directly obtain the refracted portion of light from its remaining energy.</p>\n<p>Every surface or material has a level of base reflectivity when looking straight at its surface, but when looking at the surface from an angle all reflections become more apparent compared to the surface’s base reflectivity. You can check this for yourself by looking at your presumably wooden/metallic desk which has a certain level of base reflectivity from a perpendicular view angle, but by looking at your desk from an almost 90 degree angle you’ll see the reflections become much more apparent. All surfaces theoretically fully reflect light if seen from perfect 90-degree angles. This phenomenon is known as Fresnel and is described by the Fresnel equation.</p>\n<p>The Fresnel equation is a rather complex equation, but luckily the Fresnel equation can be approximated using the Fresnel-Schlick approximation:</p>\n<script type=\"math/tex; mode=display\">F_{schlick}(h,v,F_0) = F_0 + (1 - F_0)(1 - (h \\cdot v))^5</script><p>$F_0$ represents the base reflectivity of the surface, which we calculate using something called the indices of refraction or IOR and as you can see on a sphere surface, the more we look towards the surface’s grazing angles (with the halfway-view angle reaching 90 degrees) the stronger the Fresnel and thus the reflections:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/BRDF_04.png\" alt=\"\"></p>\n<p>There are a few subtleties involved with the Fresnel equation. One is that the Fresnel-Schlick approximation is only really defined for dielectric or non-metal surfaces. For conductor surfaces (metals) calculating the base reflectivity using their indices of refraction doesn’t properly hold and we need to use a different Fresnel equation for conductors altogether. As this is inconvenient we further approximate by pre-computing the surface’s response at normal incidence ($F0$) (at a 0 degree angle as if looking directly onto a surface) and interpolate this value based on the view angle as per the Fresnel-Schlick approximation such that we can use the same equation for both metals and non-metals.</p>\n<p>These specific attributes of metallic surfaces compared to dielectric surfaces gave rise to something called the metallic workflow where we author surface materials with an extra parameter known as metalness that describes whether a surface is either a metallic or a non-metallic surface.</p>\n<p>Theoretically the metalness of a surface is binary: it’s either a metal or it isn’t; it can’t be both. However, most render pipelines allow configuring the metalness of a surface linearly between 0.0 and 1.0. This is mostly because of the lack of material texture precision to describe for instance a surface having small dust/sand-like particles/scratches over a metallic surface. By balancing the metalness value around these small non-metallic like particles/scratches we get visually pleasable results.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec3 <span class=\"title\">FresnelEquation</span><span class=\"params\">(vec3 N, vec3 V, vec3 F)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NoV = dot(N, V);</span><br><span class=\"line\">    vec3 res = F + (vec3(<span class=\"number\">1.0f</span>) - F) * <span class=\"built_in\">pow</span>(<span class=\"number\">1.0f</span> - NoV, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cook-Torrance-reflectance-equation\"><a href=\"#Cook-Torrance-reflectance-equation\" class=\"headerlink\" title=\"Cook-Torrance reflectance equation\"></a>Cook-Torrance reflectance equation</h3><p>With every component of the Cook-Torrance BRDF described we can include the physically based BRDF into the now final reflectance equation:</p>\n<script type=\"math/tex; mode=display\">L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + k_s \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_i</script><p>This equation is however not fully mathematically correct. You may remember that the Fresnel term $F$ represents the ratio of light that gets reflected on a surface. This is effectively our ratio $k_s$, meaning the specular part of the reflectance equation implicitly contains the reflectance ratio $k_s$. Given this, our final final reflectance equation becomes:</p>\n<script type=\"math/tex; mode=display\">L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_i</script><p>This equation now completely describes a physically based render model that is generally recognized as what we commonly understand as physically based rendering or PBR. Don’t worry if you didn’t yet completely understand how we’ll need to fit all the discussed mathematics together in code. In the next tutorials, we’ll explore how to utilize the reflectance equation to get much more physically plausible results in our rendered lighting and all the bits and pieces should slowly start to fit together.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/PBR/Theory\" target=\"_blank\" rel=\"noopener\">Learn OpenGL PBR Theory</a> </strong></p>\n","site":{"data":{}},"excerpt":"<p>The <strong>BRDF</strong>, or <strong>Bidirectional Reflective Distribution Function</strong> is a function that takes as input the incoming (light) direction $\\omega_i$, the outgoing (view) direction $\\omega_o$, the surface normal $n$ and a surface parameter a that represents the microsurface’s roughness. The BRDF approximates how much each individual light ray $\\omega_i$ contributes to the final reflected light of an opaque surface given its material properties. For instance, if the surface has a perfectly smooth surface (like a mirror) the BRDF function would return 0.0 for all incoming light rays $\\omega_i$ except the one ray that has the same (reflected) angle as the outgoing ray $\\omega_o$ at which the function returns 1.0.</p>\n<p>A BRDF approximates the material’s reflective and refractive properties based on the previously discussed microfacet theory. For a BRDF to be physically plausible it has to respect the law of energy conservation i.e. the sum of reflected light should never exceed the amount of incoming light. Technically, Blinn-Phong is considered a BRDF taking the same $\\omega_i$ and $\\omega_o$ as inputs. However, Blinn-Phong is not considered physically based as it doesn’t adhere to the energy conservation principle. There are several physically based BRDFs out there to approximate the surface’s reaction to light. However, almost all real-time render pipelines use a BRDF known as the <strong>Cook-Torrance BRDF</strong>.</p>\n<p>The Cook-Torrance BRDF contains both a diffuse and specular part:</p>\n<script type=\"math/tex; mode=display\">f_r = k_d f_{lambert} + k_s f_{cook-torrance}</script>","more":"<h2 id=\"Diffuse-Part\"><a href=\"#Diffuse-Part\" class=\"headerlink\" title=\"Diffuse Part\"></a>Diffuse Part</h2><p>Here kd is the earlier mentioned ratio of incoming light energy that gets refracted with ks being the ratio that gets reflected. The left side of the BRDF states the diffuse part of the equation denoted here as flambert. This is known as Lambertian diffuse similar to what we used for diffuse shading which is a constant factor denoted as:</p>\n<script type=\"math/tex; mode=display\">f_{lambert} = \\frac{c}{\\pi}</script><p>With c being the albedo or surface color (think of the diffuse surface texture). The divide by pi is there to normalize the diffuse light as the earlier denoted integral that contains the BRDF is scaled by $\\pi$</p>\n<p>You might wonder how this Lambertian diffuse relates to the diffuse term we’ve been using before: the surface color multiplied by the dot product between the surface’s normal and the light direction. The dot product is still there, but moved out of the BRDF as we find $n \\cdot \\omega_i$ at the end of the $L_o$ integral.</p>\n<p>There exist different equations for the diffuse part of the BRDF which tend to look more realistic, but are also more computationally expensive. As concluded by Epic Games however, the Lambertian diffuse is sufficient enough for most real-time rendering purposes.</p>\n<h2 id=\"Specluar-Part\"><a href=\"#Specluar-Part\" class=\"headerlink\" title=\"Specluar Part\"></a>Specluar Part</h2><p>The specular part of the BRDF is a bit more advanced and is described as:</p>\n<script type=\"math/tex; mode=display\">f_{cook-torrance} = \\frac{DFG}{4(\\omega_o \\cdot n)(\\omega_i \\cdot n)}</script><p>he Cook-Torrance specular BRDF consists of three functions and a normalization factor in the denominator. Each of the D, F and G symbols represent a type of function that approximates a specific part of the surface’s reflective properties. These are defined as the normal <strong>D</strong>istribution function, the <strong>F</strong>resnel equation and the <strong>G</strong>eometry function:</p>\n<ul>\n<li><strong>Normal distribution function:</strong> approximates the amount the surface’s microfacets are aligned to the halfway vector influenced by the roughness of the surface; this is the primary function approximating the microfacets.</li>\n<li><strong>Geometry function:</strong> describes the self-shadowing property of the microfacets. When a surface is relatively rough the surface’s microfacets can overshadow other microfacets thereby reducing the light the surface reflects.</li>\n<li><strong>Fresnel equation:</strong> The Fresnel equation describes the ratio of surface reflection at different surface angles.</li>\n</ul>\n<h3 id=\"Normal-distribution-function\"><a href=\"#Normal-distribution-function\" class=\"headerlink\" title=\"Normal distribution function\"></a>Normal distribution function</h3><p>The normal distribution function <strong>D</strong> statistically approximates the relative surface area of microfacets exactly aligned to the (halfway) vector $h$. There are a multitude of NDFs defined that statistically approximate the general alignment of the microfacets given some roughness parameter and the one we’ll be using is known as the Trowbridge-Reitz GGX:</p>\n<script type=\"math/tex; mode=display\">NDF_{GGX}(n,h,\\alpha) = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2 - 1) + 1)^2}</script><p>Here $h$ is the halfway vector to measure against the surface’s microfacets, with a being a measure of the surface’s roughness. If we take $h$ as the halfway vector between the surface normal and light direction over varying roughness parameters we get the following visual result:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/BRDF_01.png\" alt=\"\"></p>\n<p>When the roughness is low (thus the surface is smooth) a highly concentrated number of microfacets are aligned to halfway vectors over a small radius. Due to this high concentration the NDF displays a very bright spot. On a rough surface however, where the microfacets are aligned in much more random directions, you’ll find a much larger number of halfway vectors h somewhat aligned to the microfacets, but less concentrated giving us the more grayish results.</p>\n<p>In GLSL code the Trowbridge-Reitz GGX normal distribution function would look a bit like this:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">NormalDistributionFunction</span><span class=\"params\">(<span class=\"keyword\">float</span> NoH, <span class=\"keyword\">float</span> Roughness)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> a = Roughness * Roughness;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> a2 = a * a;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NdotH = max(NoH, <span class=\"number\">0.0f</span>);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NdotH2 = NdotH * NdotH;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">float</span> nom = a2;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> denom = (NdotH2 * (a2 - <span class=\"number\">1.0</span>) + <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    denom = <span class=\"number\">3.141592</span> * denom * denom;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nom / denom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Geometry-function\"><a href=\"#Geometry-function\" class=\"headerlink\" title=\"Geometry function\"></a>Geometry function</h3><p>The geometry function statistically approximates the relative surface area where its micro surface-details overshadow each other causing light rays to be occluded.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/BRDF_02.png\" alt=\"\"></p>\n<p>Similar to the NDF, the Geometry function takes a material’s roughness parameter as input with rougher surfaces having a higher probability of overshadowing microfacets. The geometry function we will use is a combination of the GGX and Schlick-Beckmann approximation known as Schlick-GGX:</p>\n<script type=\"math/tex; mode=display\">G_{schlickGGX}(n,v,k) = \\frac{n \\cdot v}{(n \\cdot v)(1-k) + k}</script><p>Here $k$ is a remapping of α based on whether we’re using the geometry function for either direct lighting or IBL lighting:</p>\n<script type=\"math/tex; mode=display\">k_{direct} = \\frac{(\\alpha + 1)^2}{8}</script><script type=\"math/tex; mode=display\">k_{IBL} = \\frac{\\alpha^2}{2}</script><p>Note that the value of $\\alpha$ might differ based on how your engine translates roughness to $\\alpha$. In the following tutorials we’ll extensively discuss how and where this remapping becomes relevant.</p>\n<p>To effectively approximate the geometry we need to take account of both the view direction (geometry obstruction) and the light direction vector (geometry shadowing). We can take both into account using Smith’s method:</p>\n<script type=\"math/tex; mode=display\">G(n,v,l,k) = G_{sub}(n,v,k)G_{sub}(n,l,k)</script><p>Using Smith’s method with Schlick-GGX as $G_{sub}$ gives the following visual appearance over varying roughness R:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/BRDF_03.png\" alt=\"\"></p>\n<p>The geometry function is a multiplier between [0.0, 1.0] with white or 1.0 measuring no microfacet shadowing and black or 0.0 complete microfacet shadowing.</p>\n<p>In GLSL the geometry function translates to the following code:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">GeometrychlickGGX</span><span class=\"params\">(<span class=\"keyword\">float</span> NoV, <span class=\"keyword\">float</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> nom = NoV;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> denom = NoV * (<span class=\"number\">1.0</span> - k) + k;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nom / denom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">GeometryFunction</span><span class=\"params\">(vec3 N, vec3 V, vec3 L, <span class=\"keyword\">float</span> Roughness)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> k = <span class=\"built_in\">pow</span>(Roughness + <span class=\"number\">1</span>, <span class=\"number\">2</span>) / <span class=\"number\">8.0f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NoV = max(dot(N, V), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NoL = max(dot(N, L), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> ggx1 = GeometrychlickGGX(NoV, k);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> ggx2 = GeometrychlickGGX(NoL, k);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ggx1 * ggx2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Fresnel-equation\"><a href=\"#Fresnel-equation\" class=\"headerlink\" title=\"Fresnel equation\"></a>Fresnel equation</h3><p>The Fresnel equation (pronounced as Freh-nel) describes the ratio of light that gets reflected over the light that gets refracted, which varies over the angle we’re looking at a surface. The moment light hits a surface, based on the surface to view angle the Fresnel equation tells us the percentage of light that gets reflected. From this ratio of reflection and the energy conservation principle we can directly obtain the refracted portion of light from its remaining energy.</p>\n<p>Every surface or material has a level of base reflectivity when looking straight at its surface, but when looking at the surface from an angle all reflections become more apparent compared to the surface’s base reflectivity. You can check this for yourself by looking at your presumably wooden/metallic desk which has a certain level of base reflectivity from a perpendicular view angle, but by looking at your desk from an almost 90 degree angle you’ll see the reflections become much more apparent. All surfaces theoretically fully reflect light if seen from perfect 90-degree angles. This phenomenon is known as Fresnel and is described by the Fresnel equation.</p>\n<p>The Fresnel equation is a rather complex equation, but luckily the Fresnel equation can be approximated using the Fresnel-Schlick approximation:</p>\n<script type=\"math/tex; mode=display\">F_{schlick}(h,v,F_0) = F_0 + (1 - F_0)(1 - (h \\cdot v))^5</script><p>$F_0$ represents the base reflectivity of the surface, which we calculate using something called the indices of refraction or IOR and as you can see on a sphere surface, the more we look towards the surface’s grazing angles (with the halfway-view angle reaching 90 degrees) the stronger the Fresnel and thus the reflections:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/BRDF_04.png\" alt=\"\"></p>\n<p>There are a few subtleties involved with the Fresnel equation. One is that the Fresnel-Schlick approximation is only really defined for dielectric or non-metal surfaces. For conductor surfaces (metals) calculating the base reflectivity using their indices of refraction doesn’t properly hold and we need to use a different Fresnel equation for conductors altogether. As this is inconvenient we further approximate by pre-computing the surface’s response at normal incidence ($F0$) (at a 0 degree angle as if looking directly onto a surface) and interpolate this value based on the view angle as per the Fresnel-Schlick approximation such that we can use the same equation for both metals and non-metals.</p>\n<p>These specific attributes of metallic surfaces compared to dielectric surfaces gave rise to something called the metallic workflow where we author surface materials with an extra parameter known as metalness that describes whether a surface is either a metallic or a non-metallic surface.</p>\n<p>Theoretically the metalness of a surface is binary: it’s either a metal or it isn’t; it can’t be both. However, most render pipelines allow configuring the metalness of a surface linearly between 0.0 and 1.0. This is mostly because of the lack of material texture precision to describe for instance a surface having small dust/sand-like particles/scratches over a metallic surface. By balancing the metalness value around these small non-metallic like particles/scratches we get visually pleasable results.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec3 <span class=\"title\">FresnelEquation</span><span class=\"params\">(vec3 N, vec3 V, vec3 F)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NoV = dot(N, V);</span><br><span class=\"line\">    vec3 res = F + (vec3(<span class=\"number\">1.0f</span>) - F) * <span class=\"built_in\">pow</span>(<span class=\"number\">1.0f</span> - NoV, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cook-Torrance-reflectance-equation\"><a href=\"#Cook-Torrance-reflectance-equation\" class=\"headerlink\" title=\"Cook-Torrance reflectance equation\"></a>Cook-Torrance reflectance equation</h3><p>With every component of the Cook-Torrance BRDF described we can include the physically based BRDF into the now final reflectance equation:</p>\n<script type=\"math/tex; mode=display\">L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + k_s \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_i</script><p>This equation is however not fully mathematically correct. You may remember that the Fresnel term $F$ represents the ratio of light that gets reflected on a surface. This is effectively our ratio $k_s$, meaning the specular part of the reflectance equation implicitly contains the reflectance ratio $k_s$. Given this, our final final reflectance equation becomes:</p>\n<script type=\"math/tex; mode=display\">L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_i</script><p>This equation now completely describes a physically based render model that is generally recognized as what we commonly understand as physically based rendering or PBR. Don’t worry if you didn’t yet completely understand how we’ll need to fit all the discussed mathematics together in code. In the next tutorials, we’ll explore how to utilize the reflectance equation to get much more physically plausible results in our rendered lighting and all the bits and pieces should slowly start to fit together.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/PBR/Theory\" target=\"_blank\" rel=\"noopener\">Learn OpenGL PBR Theory</a> </strong></p>"},{"title":"Basic Graph Theory","date":"2018-03-04T14:09:57.000Z","thumbnail":"http://hucoco.com/img/Graph/UDG.png","_content":"\n[Basic Graph Theory Chinese version address](http://hucoco.coding.me/2016/11/14/Graph/Graph/)\n\n# Graph Theory\n\n## The definition of graph\n\nThe graph is composed of some points and the connection between these points. points are often called vertices, and the lines between points are called edges. It is usually written as `G = (V,E)`.\n\n### Types of Graphs\n\nAccording to whether the direction of the edge, the graph can be divided into: undirected and directed graph.\n\n#### Undirected graph\n\n![](http://hucoco.com/img/Graph/UDG.png)\n\n<!--more-->\n\nThe above graph is an undirected graph, and all the edges of the undirected graph are not directed. It is written as G0=(V1,{E1}).\n\n`V1 = { A,B,C,D,E,F }`\n\nV1 represents a set of vertices composed of A, B, C, D, E, F.\n\n`E1 = { (A,B),(A,C),(B,C),(B,E),(B,F),(C,F),(C,D),(E,F),(C,E)}`\n\nE1 is by the edge (A, B), the edge (A, C)... And so on, and so on. (A, C) represents the edge that is connected by the vertex A and the vertex C.\n\n#### Directed graph\n\n![](http://hucoco.com/img/Graph/DG.png)\n\nThe graph above is a directed graph. Unlike an undirected graph, all the edges of the directed graph are directed. It is written as G2= (V2, {E2}).\n\n`V2={ A,C,B,F,D,E,G }`\n\nV2 represents a set of vertices composed of A, B, C, D, E, F, G.\n\n`E2={ <A,B>,<B,C>,<B,F>,<B,E>,<C,E>,<E,D>,<D,C>,<E,B>,<F,G> }`\n\nE2 is a <A,B>, <B,C>... And so on, and so on. In this, vector <A, B> represents the directed edge of the vertex C that is directed by the vertex A.\n\n### Adjacent & Degree\n\n#### Adjacent\n\nThe two vertices on an edge are called the adjacency points.\n\nFor example, the vertex A and the vertex C in the above undirected graph are the adjacency points.\n\nIn the digraph, except for the adjoining points; there are also the notions of `\"In-Edge\"` and `\"Out-Edge\"`.\n\n`In-Edge` is means which edge that end with the vertex. \n\n`Out-Edge` is means which edge that start with the vertex.\n\nFor example, the B and E in graph G2 are adjacent points; <B, E> is the Out-Edge of B, or the In-Edge of E.\n\n#### Degree\n\nIn an undirected graph, the degree of a vertex is the number of edges adjacent to the vertex.\n\nFor example, the degree of the vertex A in the above undirected graph is 2.\n\nIn the digraph, there are also the notions of `\"In-Degree\"` and `\"Out-Degree\"`\n\n`In-Degree` is means the number of edges at the end of the vertex.\n\n`Out-Degree` is means the number of edges at the start of the vertex.\n\nDegree of vertex = In-Degree + Out-Degree\n\n### Path & Circuit\n\n**Path:** If a vertex sequence exists between the vertex (Vm) to the vertex (Vn). It means that Vm to Vn is a path\n\n**Length of path:** the number of edge in this path.\n\n**Simple path:** If the vertex of a path does not repeat, it is a simple path.\n\n**Circuit:** If the first vertex of the path is the same as the last vertex, it is a Circuit.\n\n**Simple circuit:** If the vertex of a circuit does not repeat, it is a simple circuit.\n\n### Connected graphs and connected components\n\n**Connected graph:** For an undirected graph, there is an undirected path between any two vertices, and the undirected graph is called a connected graph. \n\n**strongly connected graph:** For a directed graph, if there is a directed path between any two vertices in the graph, the directed graph is called a strongly connected graph.\n\n### Weight of Graph\n\nThis is special value in Huffman tree, it is means the value of a edge.\n\n## Graph Storage Structures\n\nThe storage structure of a graph is commonly used as `adjacency matrix` and `adjacency list`.\n\n### Adjacency Matrix\n\nThe adjacency matrix refers to the representation of a graph by a matrix. It uses a matrix to describe the relationship between the vertices of the graph (and the right of the arcs or edges).\n\nTwo arrays are usually used to implement the graph's adjacency matrix: a one-dimensional array for storing vertex information and a two-dimensional array for saving edge information.\n\nThe disadvantage of adjacency matrix is more space-consuming.\n\nAssuming that the number of vertices in the graph is n, the adjacency matrix is defined as:\n\nA[i][j] = 0 is means that there is no edge.\n\nA[i][j] = 1 is means that there are edge.\n\nThe following undirected graph:\n\n![Undirected Graph](http://hucoco.com/img/Graph/UDG.png)\n\nThe adjacency matrix of this undirected graph is as follows:\n\n|N/A|A|B|C|D|E|F|G|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|A|0|0|1|1|0|1|0|\n|B|0|0|1|0|0|0|0|\n|C|1|1|0|1|0|0|0|\n|D|1|0|1|0|0|0|0|\n|E|0|0|0|0|0|0|1|\n|F|1|0|0|0|0|0|1|\n|G|0|0|0|0|1|1|0|\n\nThe following directed graph:\n\n![Undirected Graph](http://hucoco.com/img/Graph/DG.png)\n\nThe adjacency matrix of this directed graph is as follows:\n\n|N/A|A|B|C|D|E|F|G|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|A|0|0|1|0|0|0|0|\n|B|0|0|1|0|1|1|0|\n|C|0|0|0|0|1|0|0|\n|D|0|0|1|0|0|0|0|\n|E|0|1|0|1|0|0|1|\n|F|0|0|0|0|0|0|1|\n|G|0|0|0|0|0|0|0|\n\n### Adjacency List\n\nThe adjacency list is a chain storage representation method of a graph. It is an improved \"adjacency matrix\", its disadvantage is that it is inconvenient to judge whether there is an edge between the two vertices, but it is less space relative to the adjacency matrix.\n\nThe following undirected graph:\n\n![](http://hucoco.com/img/Graph/UDG.png)\n\nThe adjacency list of this undirected graph is as follows:\n\n![](http://hucoco.com/img/Graph/UDGL.png)\n\nThe following directed graph:\n\n![](http://hucoco.com/img/Graph/DG.png)\n\nThe adjacency list of this directed graph is as follows:\n\n![](http://hucoco.com/img/Graph/DGL.png)","source":"_posts/Basic-Graph-Theory.md","raw":"---\ntitle: Basic Graph Theory\ndate: 2018-03-04 22:09:57\nthumbnail: http://hucoco.com/img/Graph/UDG.png\ntags: \n- C++\n- Data Structure\n- Graph\ncategories:\n- Data Structure\n- Graph\n---\n\n[Basic Graph Theory Chinese version address](http://hucoco.coding.me/2016/11/14/Graph/Graph/)\n\n# Graph Theory\n\n## The definition of graph\n\nThe graph is composed of some points and the connection between these points. points are often called vertices, and the lines between points are called edges. It is usually written as `G = (V,E)`.\n\n### Types of Graphs\n\nAccording to whether the direction of the edge, the graph can be divided into: undirected and directed graph.\n\n#### Undirected graph\n\n![](http://hucoco.com/img/Graph/UDG.png)\n\n<!--more-->\n\nThe above graph is an undirected graph, and all the edges of the undirected graph are not directed. It is written as G0=(V1,{E1}).\n\n`V1 = { A,B,C,D,E,F }`\n\nV1 represents a set of vertices composed of A, B, C, D, E, F.\n\n`E1 = { (A,B),(A,C),(B,C),(B,E),(B,F),(C,F),(C,D),(E,F),(C,E)}`\n\nE1 is by the edge (A, B), the edge (A, C)... And so on, and so on. (A, C) represents the edge that is connected by the vertex A and the vertex C.\n\n#### Directed graph\n\n![](http://hucoco.com/img/Graph/DG.png)\n\nThe graph above is a directed graph. Unlike an undirected graph, all the edges of the directed graph are directed. It is written as G2= (V2, {E2}).\n\n`V2={ A,C,B,F,D,E,G }`\n\nV2 represents a set of vertices composed of A, B, C, D, E, F, G.\n\n`E2={ <A,B>,<B,C>,<B,F>,<B,E>,<C,E>,<E,D>,<D,C>,<E,B>,<F,G> }`\n\nE2 is a <A,B>, <B,C>... And so on, and so on. In this, vector <A, B> represents the directed edge of the vertex C that is directed by the vertex A.\n\n### Adjacent & Degree\n\n#### Adjacent\n\nThe two vertices on an edge are called the adjacency points.\n\nFor example, the vertex A and the vertex C in the above undirected graph are the adjacency points.\n\nIn the digraph, except for the adjoining points; there are also the notions of `\"In-Edge\"` and `\"Out-Edge\"`.\n\n`In-Edge` is means which edge that end with the vertex. \n\n`Out-Edge` is means which edge that start with the vertex.\n\nFor example, the B and E in graph G2 are adjacent points; <B, E> is the Out-Edge of B, or the In-Edge of E.\n\n#### Degree\n\nIn an undirected graph, the degree of a vertex is the number of edges adjacent to the vertex.\n\nFor example, the degree of the vertex A in the above undirected graph is 2.\n\nIn the digraph, there are also the notions of `\"In-Degree\"` and `\"Out-Degree\"`\n\n`In-Degree` is means the number of edges at the end of the vertex.\n\n`Out-Degree` is means the number of edges at the start of the vertex.\n\nDegree of vertex = In-Degree + Out-Degree\n\n### Path & Circuit\n\n**Path:** If a vertex sequence exists between the vertex (Vm) to the vertex (Vn). It means that Vm to Vn is a path\n\n**Length of path:** the number of edge in this path.\n\n**Simple path:** If the vertex of a path does not repeat, it is a simple path.\n\n**Circuit:** If the first vertex of the path is the same as the last vertex, it is a Circuit.\n\n**Simple circuit:** If the vertex of a circuit does not repeat, it is a simple circuit.\n\n### Connected graphs and connected components\n\n**Connected graph:** For an undirected graph, there is an undirected path between any two vertices, and the undirected graph is called a connected graph. \n\n**strongly connected graph:** For a directed graph, if there is a directed path between any two vertices in the graph, the directed graph is called a strongly connected graph.\n\n### Weight of Graph\n\nThis is special value in Huffman tree, it is means the value of a edge.\n\n## Graph Storage Structures\n\nThe storage structure of a graph is commonly used as `adjacency matrix` and `adjacency list`.\n\n### Adjacency Matrix\n\nThe adjacency matrix refers to the representation of a graph by a matrix. It uses a matrix to describe the relationship between the vertices of the graph (and the right of the arcs or edges).\n\nTwo arrays are usually used to implement the graph's adjacency matrix: a one-dimensional array for storing vertex information and a two-dimensional array for saving edge information.\n\nThe disadvantage of adjacency matrix is more space-consuming.\n\nAssuming that the number of vertices in the graph is n, the adjacency matrix is defined as:\n\nA[i][j] = 0 is means that there is no edge.\n\nA[i][j] = 1 is means that there are edge.\n\nThe following undirected graph:\n\n![Undirected Graph](http://hucoco.com/img/Graph/UDG.png)\n\nThe adjacency matrix of this undirected graph is as follows:\n\n|N/A|A|B|C|D|E|F|G|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|A|0|0|1|1|0|1|0|\n|B|0|0|1|0|0|0|0|\n|C|1|1|0|1|0|0|0|\n|D|1|0|1|0|0|0|0|\n|E|0|0|0|0|0|0|1|\n|F|1|0|0|0|0|0|1|\n|G|0|0|0|0|1|1|0|\n\nThe following directed graph:\n\n![Undirected Graph](http://hucoco.com/img/Graph/DG.png)\n\nThe adjacency matrix of this directed graph is as follows:\n\n|N/A|A|B|C|D|E|F|G|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|A|0|0|1|0|0|0|0|\n|B|0|0|1|0|1|1|0|\n|C|0|0|0|0|1|0|0|\n|D|0|0|1|0|0|0|0|\n|E|0|1|0|1|0|0|1|\n|F|0|0|0|0|0|0|1|\n|G|0|0|0|0|0|0|0|\n\n### Adjacency List\n\nThe adjacency list is a chain storage representation method of a graph. It is an improved \"adjacency matrix\", its disadvantage is that it is inconvenient to judge whether there is an edge between the two vertices, but it is less space relative to the adjacency matrix.\n\nThe following undirected graph:\n\n![](http://hucoco.com/img/Graph/UDG.png)\n\nThe adjacency list of this undirected graph is as follows:\n\n![](http://hucoco.com/img/Graph/UDGL.png)\n\nThe following directed graph:\n\n![](http://hucoco.com/img/Graph/DG.png)\n\nThe adjacency list of this directed graph is as follows:\n\n![](http://hucoco.com/img/Graph/DGL.png)","slug":"Basic-Graph-Theory","published":1,"updated":"2018-03-07T16:06:32.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36tt0007ssb9wnftbuvc","content":"<p><a href=\"http://hucoco.coding.me/2016/11/14/Graph/Graph/\" target=\"_blank\" rel=\"noopener\">Basic Graph Theory Chinese version address</a></p>\n<h1 id=\"Graph-Theory\"><a href=\"#Graph-Theory\" class=\"headerlink\" title=\"Graph Theory\"></a>Graph Theory</h1><h2 id=\"The-definition-of-graph\"><a href=\"#The-definition-of-graph\" class=\"headerlink\" title=\"The definition of graph\"></a>The definition of graph</h2><p>The graph is composed of some points and the connection between these points. points are often called vertices, and the lines between points are called edges. It is usually written as <code>G = (V,E)</code>.</p>\n<h3 id=\"Types-of-Graphs\"><a href=\"#Types-of-Graphs\" class=\"headerlink\" title=\"Types of Graphs\"></a>Types of Graphs</h3><p>According to whether the direction of the edge, the graph can be divided into: undirected and directed graph.</p>\n<h4 id=\"Undirected-graph\"><a href=\"#Undirected-graph\" class=\"headerlink\" title=\"Undirected graph\"></a>Undirected graph</h4><p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>The above graph is an undirected graph, and all the edges of the undirected graph are not directed. It is written as G0=(V1,{E1}).</p>\n<p><code>V1 = { A,B,C,D,E,F }</code></p>\n<p>V1 represents a set of vertices composed of A, B, C, D, E, F.</p>\n<p><code>E1 = { (A,B),(A,C),(B,C),(B,E),(B,F),(C,F),(C,D),(E,F),(C,E)}</code></p>\n<p>E1 is by the edge (A, B), the edge (A, C)… And so on, and so on. (A, C) represents the edge that is connected by the vertex A and the vertex C.</p>\n<h4 id=\"Directed-graph\"><a href=\"#Directed-graph\" class=\"headerlink\" title=\"Directed graph\"></a>Directed graph</h4><p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"\"></p>\n<p>The graph above is a directed graph. Unlike an undirected graph, all the edges of the directed graph are directed. It is written as G2= (V2, {E2}).</p>\n<p><code>V2={ A,C,B,F,D,E,G }</code></p>\n<p>V2 represents a set of vertices composed of A, B, C, D, E, F, G.</p>\n<p><code>E2={ &lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt; }</code></p>\n<p>E2 is a <a,b>, <b,c>… And so on, and so on. In this, vector <a, b=\"\"> represents the directed edge of the vertex C that is directed by the vertex A.</a,></b,c></a,b></p>\n<h3 id=\"Adjacent-amp-Degree\"><a href=\"#Adjacent-amp-Degree\" class=\"headerlink\" title=\"Adjacent &amp; Degree\"></a>Adjacent &amp; Degree</h3><h4 id=\"Adjacent\"><a href=\"#Adjacent\" class=\"headerlink\" title=\"Adjacent\"></a>Adjacent</h4><p>The two vertices on an edge are called the adjacency points.</p>\n<p>For example, the vertex A and the vertex C in the above undirected graph are the adjacency points.</p>\n<p>In the digraph, except for the adjoining points; there are also the notions of <code>&quot;In-Edge&quot;</code> and <code>&quot;Out-Edge&quot;</code>.</p>\n<p><code>In-Edge</code> is means which edge that end with the vertex. </p>\n<p><code>Out-Edge</code> is means which edge that start with the vertex.</p>\n<p>For example, the B and E in graph G2 are adjacent points; <b, e=\"\"> is the Out-Edge of B, or the In-Edge of E.</b,></p>\n<h4 id=\"Degree\"><a href=\"#Degree\" class=\"headerlink\" title=\"Degree\"></a>Degree</h4><p>In an undirected graph, the degree of a vertex is the number of edges adjacent to the vertex.</p>\n<p>For example, the degree of the vertex A in the above undirected graph is 2.</p>\n<p>In the digraph, there are also the notions of <code>&quot;In-Degree&quot;</code> and <code>&quot;Out-Degree&quot;</code></p>\n<p><code>In-Degree</code> is means the number of edges at the end of the vertex.</p>\n<p><code>Out-Degree</code> is means the number of edges at the start of the vertex.</p>\n<p>Degree of vertex = In-Degree + Out-Degree</p>\n<h3 id=\"Path-amp-Circuit\"><a href=\"#Path-amp-Circuit\" class=\"headerlink\" title=\"Path &amp; Circuit\"></a>Path &amp; Circuit</h3><p><strong>Path:</strong> If a vertex sequence exists between the vertex (Vm) to the vertex (Vn). It means that Vm to Vn is a path</p>\n<p><strong>Length of path:</strong> the number of edge in this path.</p>\n<p><strong>Simple path:</strong> If the vertex of a path does not repeat, it is a simple path.</p>\n<p><strong>Circuit:</strong> If the first vertex of the path is the same as the last vertex, it is a Circuit.</p>\n<p><strong>Simple circuit:</strong> If the vertex of a circuit does not repeat, it is a simple circuit.</p>\n<h3 id=\"Connected-graphs-and-connected-components\"><a href=\"#Connected-graphs-and-connected-components\" class=\"headerlink\" title=\"Connected graphs and connected components\"></a>Connected graphs and connected components</h3><p><strong>Connected graph:</strong> For an undirected graph, there is an undirected path between any two vertices, and the undirected graph is called a connected graph. </p>\n<p><strong>strongly connected graph:</strong> For a directed graph, if there is a directed path between any two vertices in the graph, the directed graph is called a strongly connected graph.</p>\n<h3 id=\"Weight-of-Graph\"><a href=\"#Weight-of-Graph\" class=\"headerlink\" title=\"Weight of Graph\"></a>Weight of Graph</h3><p>This is special value in Huffman tree, it is means the value of a edge.</p>\n<h2 id=\"Graph-Storage-Structures\"><a href=\"#Graph-Storage-Structures\" class=\"headerlink\" title=\"Graph Storage Structures\"></a>Graph Storage Structures</h2><p>The storage structure of a graph is commonly used as <code>adjacency matrix</code> and <code>adjacency list</code>.</p>\n<h3 id=\"Adjacency-Matrix\"><a href=\"#Adjacency-Matrix\" class=\"headerlink\" title=\"Adjacency Matrix\"></a>Adjacency Matrix</h3><p>The adjacency matrix refers to the representation of a graph by a matrix. It uses a matrix to describe the relationship between the vertices of the graph (and the right of the arcs or edges).</p>\n<p>Two arrays are usually used to implement the graph’s adjacency matrix: a one-dimensional array for storing vertex information and a two-dimensional array for saving edge information.</p>\n<p>The disadvantage of adjacency matrix is more space-consuming.</p>\n<p>Assuming that the number of vertices in the graph is n, the adjacency matrix is defined as:</p>\n<p>A[i][j] = 0 is means that there is no edge.</p>\n<p>A[i][j] = 1 is means that there are edge.</p>\n<p>The following undirected graph:</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Undirected Graph\"></p>\n<p>The adjacency matrix of this undirected graph is as follows:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">N/A</th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>The following directed graph:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Undirected Graph\"></p>\n<p>The adjacency matrix of this directed graph is as follows:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">N/A</th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"Adjacency-List\"><a href=\"#Adjacency-List\" class=\"headerlink\" title=\"Adjacency List\"></a>Adjacency List</h3><p>The adjacency list is a chain storage representation method of a graph. It is an improved “adjacency matrix”, its disadvantage is that it is inconvenient to judge whether there is an edge between the two vertices, but it is less space relative to the adjacency matrix.</p>\n<p>The following undirected graph:</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"\"></p>\n<p>The adjacency list of this undirected graph is as follows:</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDGL.png\" alt=\"\"></p>\n<p>The following directed graph:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"\"></p>\n<p>The adjacency list of this directed graph is as follows:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGL.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/14/Graph/Graph/\" target=\"_blank\" rel=\"noopener\">Basic Graph Theory Chinese version address</a></p>\n<h1 id=\"Graph-Theory\"><a href=\"#Graph-Theory\" class=\"headerlink\" title=\"Graph Theory\"></a>Graph Theory</h1><h2 id=\"The-definition-of-graph\"><a href=\"#The-definition-of-graph\" class=\"headerlink\" title=\"The definition of graph\"></a>The definition of graph</h2><p>The graph is composed of some points and the connection between these points. points are often called vertices, and the lines between points are called edges. It is usually written as <code>G = (V,E)</code>.</p>\n<h3 id=\"Types-of-Graphs\"><a href=\"#Types-of-Graphs\" class=\"headerlink\" title=\"Types of Graphs\"></a>Types of Graphs</h3><p>According to whether the direction of the edge, the graph can be divided into: undirected and directed graph.</p>\n<h4 id=\"Undirected-graph\"><a href=\"#Undirected-graph\" class=\"headerlink\" title=\"Undirected graph\"></a>Undirected graph</h4><p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"\"></p>","more":"<p>The above graph is an undirected graph, and all the edges of the undirected graph are not directed. It is written as G0=(V1,{E1}).</p>\n<p><code>V1 = { A,B,C,D,E,F }</code></p>\n<p>V1 represents a set of vertices composed of A, B, C, D, E, F.</p>\n<p><code>E1 = { (A,B),(A,C),(B,C),(B,E),(B,F),(C,F),(C,D),(E,F),(C,E)}</code></p>\n<p>E1 is by the edge (A, B), the edge (A, C)… And so on, and so on. (A, C) represents the edge that is connected by the vertex A and the vertex C.</p>\n<h4 id=\"Directed-graph\"><a href=\"#Directed-graph\" class=\"headerlink\" title=\"Directed graph\"></a>Directed graph</h4><p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"\"></p>\n<p>The graph above is a directed graph. Unlike an undirected graph, all the edges of the directed graph are directed. It is written as G2= (V2, {E2}).</p>\n<p><code>V2={ A,C,B,F,D,E,G }</code></p>\n<p>V2 represents a set of vertices composed of A, B, C, D, E, F, G.</p>\n<p><code>E2={ &lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt; }</code></p>\n<p>E2 is a <a,b>, <b,c>… And so on, and so on. In this, vector <a, b=\"\"> represents the directed edge of the vertex C that is directed by the vertex A.</a,></b,c></a,b></p>\n<h3 id=\"Adjacent-amp-Degree\"><a href=\"#Adjacent-amp-Degree\" class=\"headerlink\" title=\"Adjacent &amp; Degree\"></a>Adjacent &amp; Degree</h3><h4 id=\"Adjacent\"><a href=\"#Adjacent\" class=\"headerlink\" title=\"Adjacent\"></a>Adjacent</h4><p>The two vertices on an edge are called the adjacency points.</p>\n<p>For example, the vertex A and the vertex C in the above undirected graph are the adjacency points.</p>\n<p>In the digraph, except for the adjoining points; there are also the notions of <code>&quot;In-Edge&quot;</code> and <code>&quot;Out-Edge&quot;</code>.</p>\n<p><code>In-Edge</code> is means which edge that end with the vertex. </p>\n<p><code>Out-Edge</code> is means which edge that start with the vertex.</p>\n<p>For example, the B and E in graph G2 are adjacent points; <b, e=\"\"> is the Out-Edge of B, or the In-Edge of E.</b,></p>\n<h4 id=\"Degree\"><a href=\"#Degree\" class=\"headerlink\" title=\"Degree\"></a>Degree</h4><p>In an undirected graph, the degree of a vertex is the number of edges adjacent to the vertex.</p>\n<p>For example, the degree of the vertex A in the above undirected graph is 2.</p>\n<p>In the digraph, there are also the notions of <code>&quot;In-Degree&quot;</code> and <code>&quot;Out-Degree&quot;</code></p>\n<p><code>In-Degree</code> is means the number of edges at the end of the vertex.</p>\n<p><code>Out-Degree</code> is means the number of edges at the start of the vertex.</p>\n<p>Degree of vertex = In-Degree + Out-Degree</p>\n<h3 id=\"Path-amp-Circuit\"><a href=\"#Path-amp-Circuit\" class=\"headerlink\" title=\"Path &amp; Circuit\"></a>Path &amp; Circuit</h3><p><strong>Path:</strong> If a vertex sequence exists between the vertex (Vm) to the vertex (Vn). It means that Vm to Vn is a path</p>\n<p><strong>Length of path:</strong> the number of edge in this path.</p>\n<p><strong>Simple path:</strong> If the vertex of a path does not repeat, it is a simple path.</p>\n<p><strong>Circuit:</strong> If the first vertex of the path is the same as the last vertex, it is a Circuit.</p>\n<p><strong>Simple circuit:</strong> If the vertex of a circuit does not repeat, it is a simple circuit.</p>\n<h3 id=\"Connected-graphs-and-connected-components\"><a href=\"#Connected-graphs-and-connected-components\" class=\"headerlink\" title=\"Connected graphs and connected components\"></a>Connected graphs and connected components</h3><p><strong>Connected graph:</strong> For an undirected graph, there is an undirected path between any two vertices, and the undirected graph is called a connected graph. </p>\n<p><strong>strongly connected graph:</strong> For a directed graph, if there is a directed path between any two vertices in the graph, the directed graph is called a strongly connected graph.</p>\n<h3 id=\"Weight-of-Graph\"><a href=\"#Weight-of-Graph\" class=\"headerlink\" title=\"Weight of Graph\"></a>Weight of Graph</h3><p>This is special value in Huffman tree, it is means the value of a edge.</p>\n<h2 id=\"Graph-Storage-Structures\"><a href=\"#Graph-Storage-Structures\" class=\"headerlink\" title=\"Graph Storage Structures\"></a>Graph Storage Structures</h2><p>The storage structure of a graph is commonly used as <code>adjacency matrix</code> and <code>adjacency list</code>.</p>\n<h3 id=\"Adjacency-Matrix\"><a href=\"#Adjacency-Matrix\" class=\"headerlink\" title=\"Adjacency Matrix\"></a>Adjacency Matrix</h3><p>The adjacency matrix refers to the representation of a graph by a matrix. It uses a matrix to describe the relationship between the vertices of the graph (and the right of the arcs or edges).</p>\n<p>Two arrays are usually used to implement the graph’s adjacency matrix: a one-dimensional array for storing vertex information and a two-dimensional array for saving edge information.</p>\n<p>The disadvantage of adjacency matrix is more space-consuming.</p>\n<p>Assuming that the number of vertices in the graph is n, the adjacency matrix is defined as:</p>\n<p>A[i][j] = 0 is means that there is no edge.</p>\n<p>A[i][j] = 1 is means that there are edge.</p>\n<p>The following undirected graph:</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Undirected Graph\"></p>\n<p>The adjacency matrix of this undirected graph is as follows:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">N/A</th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>The following directed graph:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Undirected Graph\"></p>\n<p>The adjacency matrix of this directed graph is as follows:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">N/A</th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"Adjacency-List\"><a href=\"#Adjacency-List\" class=\"headerlink\" title=\"Adjacency List\"></a>Adjacency List</h3><p>The adjacency list is a chain storage representation method of a graph. It is an improved “adjacency matrix”, its disadvantage is that it is inconvenient to judge whether there is an edge between the two vertices, but it is less space relative to the adjacency matrix.</p>\n<p>The following undirected graph:</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"\"></p>\n<p>The adjacency list of this undirected graph is as follows:</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDGL.png\" alt=\"\"></p>\n<p>The following directed graph:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"\"></p>\n<p>The adjacency list of this directed graph is as follows:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGL.png\" alt=\"\"></p>"},{"title":"Depth First Search","date":"2018-03-07T14:47:44.000Z","thumbnail":"http://hucoco.com/img/Graph/DGDFS.png","_content":"\n[Depth First Search Chinese version address](http://hucoco.coding.me/2016/11/20/Graph/DFS/)\n\n# Depth First Search\n\n## Overview\n\nDepth first search of the graph is similar to the preorder traversal of the tree.\n\nSuppose that the initial state is that all the vertices in the graph are not accessed, then starting from a vertex and first access to it, nextly, the depth first search traversal from each of its non-accessed adjacency points in turn, until all the vertices that have a path to the starting vertex in the graph are accessed. If there are other vertices that are not accessed, then choose another unvisited vertex as a starting point, repeat the above process until all graph vertices have been visited.\n\n## Diagram\n\n### Depth first search for undirected graphs\n\nThe following is an example of undirected graph, to demonstrate the depth first search.\n\n![Undirected Graphs](http://hucoco.com/img/Graph/UDG.png)\n\n<!--more-->\n\nDepth first search of the graph above, starting with vertex A:\n\n![Step Diagram](http://hucoco.com/img/Graph/DGDFS.png)\n\n#### Steps:\n\n1. Access to A.\n2. Access to C. Because the vertices A,B,C,D,E,F,G are stored in order in this paper, C is in front of D and F, so visit C first.\n3. Access to B. Because B before D, first visit B.\n4. Access to D. After having visited C's adjacency point B at step 3, B has no unvisit adjacency points, thus, it returns to another adjacency point D that accesses C.\n5. Access to F. All adjacency point of B and C are accessed, so return to A and access to next adjaceny point of A.\n6. Access to G.\n7. Access to E.\n\n#### C++ Implememtation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```\n\n### Depth first search for directed graphs\n\nThe following is an example of directed graph, to demonstrate the depth first search.\n\n![Directed Graphs](http://hucoco.com/img/Graph/DG.png)\n\nDepth first search of the graph above, starting with vertex A:\n\n![Step Diagram](http://hucoco.com/img/Graph/DGDFS.png)\n\n#### Steps:\n\n1. Access to A.\n2. Access to B. After visiting A, the next vertex to which A should go is the vertex B that should be accessed next.\n3. Access to C. After visiting B, what should be followed is another vertex of B's out-edge. Because C is the first one, so first visit it\n4. Access to E. Next to the other vertex of the out-edge of the C vertex.\n5. Access to D. Then visit the other vertices of E's out edge, vertices B and D. Vertex B has already been visited, so visit vertex D.\n6. Access to F.\n7. Access to G.\n\n#### C++ Implememtation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```","source":"_posts/Depth-First-Search.md","raw":"---\ntitle: Depth First Search\ndate: 2018-03-07 22:47:44\nthumbnail: http://hucoco.com/img/Graph/DGDFS.png\ntags: \n- C++\n- Algorithm\n- Graph\ncategories:\n- Algorithm\n- Search\n---\n\n[Depth First Search Chinese version address](http://hucoco.coding.me/2016/11/20/Graph/DFS/)\n\n# Depth First Search\n\n## Overview\n\nDepth first search of the graph is similar to the preorder traversal of the tree.\n\nSuppose that the initial state is that all the vertices in the graph are not accessed, then starting from a vertex and first access to it, nextly, the depth first search traversal from each of its non-accessed adjacency points in turn, until all the vertices that have a path to the starting vertex in the graph are accessed. If there are other vertices that are not accessed, then choose another unvisited vertex as a starting point, repeat the above process until all graph vertices have been visited.\n\n## Diagram\n\n### Depth first search for undirected graphs\n\nThe following is an example of undirected graph, to demonstrate the depth first search.\n\n![Undirected Graphs](http://hucoco.com/img/Graph/UDG.png)\n\n<!--more-->\n\nDepth first search of the graph above, starting with vertex A:\n\n![Step Diagram](http://hucoco.com/img/Graph/DGDFS.png)\n\n#### Steps:\n\n1. Access to A.\n2. Access to C. Because the vertices A,B,C,D,E,F,G are stored in order in this paper, C is in front of D and F, so visit C first.\n3. Access to B. Because B before D, first visit B.\n4. Access to D. After having visited C's adjacency point B at step 3, B has no unvisit adjacency points, thus, it returns to another adjacency point D that accesses C.\n5. Access to F. All adjacency point of B and C are accessed, so return to A and access to next adjaceny point of A.\n6. Access to G.\n7. Access to E.\n\n#### C++ Implememtation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```\n\n### Depth first search for directed graphs\n\nThe following is an example of directed graph, to demonstrate the depth first search.\n\n![Directed Graphs](http://hucoco.com/img/Graph/DG.png)\n\nDepth first search of the graph above, starting with vertex A:\n\n![Step Diagram](http://hucoco.com/img/Graph/DGDFS.png)\n\n#### Steps:\n\n1. Access to A.\n2. Access to B. After visiting A, the next vertex to which A should go is the vertex B that should be accessed next.\n3. Access to C. After visiting B, what should be followed is another vertex of B's out-edge. Because C is the first one, so first visit it\n4. Access to E. Next to the other vertex of the out-edge of the C vertex.\n5. Access to D. Then visit the other vertices of E's out edge, vertices B and D. Vertex B has already been visited, so visit vertex D.\n6. Access to F.\n7. Access to G.\n\n#### C++ Implememtation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```","slug":"Depth-First-Search","published":1,"updated":"2018-03-07T16:04:48.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36tu000assb9g71t9075","content":"<p><a href=\"http://hucoco.coding.me/2016/11/20/Graph/DFS/\" target=\"_blank\" rel=\"noopener\">Depth First Search Chinese version address</a></p>\n<h1 id=\"Depth-First-Search\"><a href=\"#Depth-First-Search\" class=\"headerlink\" title=\"Depth First Search\"></a>Depth First Search</h1><h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>Depth first search of the graph is similar to the preorder traversal of the tree.</p>\n<p>Suppose that the initial state is that all the vertices in the graph are not accessed, then starting from a vertex and first access to it, nextly, the depth first search traversal from each of its non-accessed adjacency points in turn, until all the vertices that have a path to the starting vertex in the graph are accessed. If there are other vertices that are not accessed, then choose another unvisited vertex as a starting point, repeat the above process until all graph vertices have been visited.</p>\n<h2 id=\"Diagram\"><a href=\"#Diagram\" class=\"headerlink\" title=\"Diagram\"></a>Diagram</h2><h3 id=\"Depth-first-search-for-undirected-graphs\"><a href=\"#Depth-first-search-for-undirected-graphs\" class=\"headerlink\" title=\"Depth first search for undirected graphs\"></a>Depth first search for undirected graphs</h3><p>The following is an example of undirected graph, to demonstrate the depth first search.</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Undirected Graphs\"></p>\n<a id=\"more\"></a>\n<p>Depth first search of the graph above, starting with vertex A:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGDFS.png\" alt=\"Step Diagram\"></p>\n<h4 id=\"Steps\"><a href=\"#Steps\" class=\"headerlink\" title=\"Steps:\"></a>Steps:</h4><ol>\n<li>Access to A.</li>\n<li>Access to C. Because the vertices A,B,C,D,E,F,G are stored in order in this paper, C is in front of D and F, so visit C first.</li>\n<li>Access to B. Because B before D, first visit B.</li>\n<li>Access to D. After having visited C’s adjacency point B at step 3, B has no unvisit adjacency points, thus, it returns to another adjacency point D that accesses C.</li>\n<li>Access to F. All adjacency point of B and C are accessed, so return to A and access to next adjaceny point of A.</li>\n<li>Access to G.</li>\n<li>Access to E.</li>\n</ol>\n<h4 id=\"C-Implememtation\"><a href=\"#C-Implememtation\" class=\"headerlink\" title=\"C++ Implememtation\"></a>C++ Implememtation</h4><h5 id=\"Adjacency-Matrix-Version\"><a href=\"#Adjacency-Matrix-Version\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version\"><a href=\"#Adjacency-List-Version\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"Depth-first-search-for-directed-graphs\"><a href=\"#Depth-first-search-for-directed-graphs\" class=\"headerlink\" title=\"Depth first search for directed graphs\"></a>Depth first search for directed graphs</h3><p>The following is an example of directed graph, to demonstrate the depth first search.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Directed Graphs\"></p>\n<p>Depth first search of the graph above, starting with vertex A:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGDFS.png\" alt=\"Step Diagram\"></p>\n<h4 id=\"Steps-1\"><a href=\"#Steps-1\" class=\"headerlink\" title=\"Steps:\"></a>Steps:</h4><ol>\n<li>Access to A.</li>\n<li>Access to B. After visiting A, the next vertex to which A should go is the vertex B that should be accessed next.</li>\n<li>Access to C. After visiting B, what should be followed is another vertex of B’s out-edge. Because C is the first one, so first visit it</li>\n<li>Access to E. Next to the other vertex of the out-edge of the C vertex.</li>\n<li>Access to D. Then visit the other vertices of E’s out edge, vertices B and D. Vertex B has already been visited, so visit vertex D.</li>\n<li>Access to F.</li>\n<li>Access to G.</li>\n</ol>\n<h4 id=\"C-Implememtation-1\"><a href=\"#C-Implememtation-1\" class=\"headerlink\" title=\"C++ Implememtation\"></a>C++ Implememtation</h4><h5 id=\"Adjacency-Matrix-Version-1\"><a href=\"#Adjacency-Matrix-Version-1\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version-1\"><a href=\"#Adjacency-List-Version-1\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/20/Graph/DFS/\" target=\"_blank\" rel=\"noopener\">Depth First Search Chinese version address</a></p>\n<h1 id=\"Depth-First-Search\"><a href=\"#Depth-First-Search\" class=\"headerlink\" title=\"Depth First Search\"></a>Depth First Search</h1><h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>Depth first search of the graph is similar to the preorder traversal of the tree.</p>\n<p>Suppose that the initial state is that all the vertices in the graph are not accessed, then starting from a vertex and first access to it, nextly, the depth first search traversal from each of its non-accessed adjacency points in turn, until all the vertices that have a path to the starting vertex in the graph are accessed. If there are other vertices that are not accessed, then choose another unvisited vertex as a starting point, repeat the above process until all graph vertices have been visited.</p>\n<h2 id=\"Diagram\"><a href=\"#Diagram\" class=\"headerlink\" title=\"Diagram\"></a>Diagram</h2><h3 id=\"Depth-first-search-for-undirected-graphs\"><a href=\"#Depth-first-search-for-undirected-graphs\" class=\"headerlink\" title=\"Depth first search for undirected graphs\"></a>Depth first search for undirected graphs</h3><p>The following is an example of undirected graph, to demonstrate the depth first search.</p>\n<p><img src=\"http://hucoco.com/img/Graph/UDG.png\" alt=\"Undirected Graphs\"></p>","more":"<p>Depth first search of the graph above, starting with vertex A:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGDFS.png\" alt=\"Step Diagram\"></p>\n<h4 id=\"Steps\"><a href=\"#Steps\" class=\"headerlink\" title=\"Steps:\"></a>Steps:</h4><ol>\n<li>Access to A.</li>\n<li>Access to C. Because the vertices A,B,C,D,E,F,G are stored in order in this paper, C is in front of D and F, so visit C first.</li>\n<li>Access to B. Because B before D, first visit B.</li>\n<li>Access to D. After having visited C’s adjacency point B at step 3, B has no unvisit adjacency points, thus, it returns to another adjacency point D that accesses C.</li>\n<li>Access to F. All adjacency point of B and C are accessed, so return to A and access to next adjaceny point of A.</li>\n<li>Access to G.</li>\n<li>Access to E.</li>\n</ol>\n<h4 id=\"C-Implememtation\"><a href=\"#C-Implememtation\" class=\"headerlink\" title=\"C++ Implememtation\"></a>C++ Implememtation</h4><h5 id=\"Adjacency-Matrix-Version\"><a href=\"#Adjacency-Matrix-Version\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version\"><a href=\"#Adjacency-List-Version\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h3 id=\"Depth-first-search-for-directed-graphs\"><a href=\"#Depth-first-search-for-directed-graphs\" class=\"headerlink\" title=\"Depth first search for directed graphs\"></a>Depth first search for directed graphs</h3><p>The following is an example of directed graph, to demonstrate the depth first search.</p>\n<p><img src=\"http://hucoco.com/img/Graph/DG.png\" alt=\"Directed Graphs\"></p>\n<p>Depth first search of the graph above, starting with vertex A:</p>\n<p><img src=\"http://hucoco.com/img/Graph/DGDFS.png\" alt=\"Step Diagram\"></p>\n<h4 id=\"Steps-1\"><a href=\"#Steps-1\" class=\"headerlink\" title=\"Steps:\"></a>Steps:</h4><ol>\n<li>Access to A.</li>\n<li>Access to B. After visiting A, the next vertex to which A should go is the vertex B that should be accessed next.</li>\n<li>Access to C. After visiting B, what should be followed is another vertex of B’s out-edge. Because C is the first one, so first visit it</li>\n<li>Access to E. Next to the other vertex of the out-edge of the C vertex.</li>\n<li>Access to D. Then visit the other vertices of E’s out edge, vertices B and D. Vertex B has already been visited, so visit vertex D.</li>\n<li>Access to F.</li>\n<li>Access to G.</li>\n</ol>\n<h4 id=\"C-Implememtation-1\"><a href=\"#C-Implememtation-1\" class=\"headerlink\" title=\"C++ Implememtation\"></a>C++ Implememtation</h4><h5 id=\"Adjacency-Matrix-Version-1\"><a href=\"#Adjacency-Matrix-Version-1\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version-1\"><a href=\"#Adjacency-List-Version-1\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>"},{"title":"Lighting and Materials","date":"2018-07-09T12:59:05.000Z","thumbnail":"http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_00.png","mathjax":true,"_content":"\n## Lighting\n\nCaculate lighting effect is extremely complicated and it depends on way too many factors in real world, therefore we use a method based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the **Phong lighting model**. \n\nPhong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area.\n\n![](http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_01.png)\n\n<!--more-->\n\nIn 1977 the **Blinn-Phong lighting model** was introduced by James F. Blinn as an extension to the Phong shading we've used so far. The Blinn-Phong model is largely similar, but approaches the specular model slightly different which as a result overcomes our problem. Instead of relying on a reflection vector we're using a so called halfway vector that is a unit vector exactly halfway between the view direction and the light direction. The closer this halfway vector aligns with the surface's normal vector, the higher the specular contribution.\n\n![](http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_02.png)\n\nGetting the halfway vector is easy, we add the light's direction vector and view vector together and normalize the result:\n\n$$\n\\overline{H} = \\frac{\\overline{V} + \\overline{H}}\n{\\begin{Vmatrix}\n\\overline{V} + \\overline{H}\n\\end{Vmatrix}}\n$$\n\n\n## Matrials\n\nThe major building blocks of the Phong model consist of 3 components: ambient, diffuse and specular lighting. Below you can see what these lighting components actually look like:\n\n![](http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_00.png)\n\n* **Ambient lighting:** even when it is dark there is usually still some light somewhere in the world (the moon, a distant light) so objects are almost never completely dark. To simulate this we use an ambient lighting constant that always gives the object some color.\n* **Diffuse lighting:** simulates the directional impact a light object has on an object. This is the most visually significant component of the lighting model. The more a part of an object faces the light source, the brighter it becomes.\n\n\t```C++\n\tptLight.I_source * mat->k_d * NL\n\t```\n\t\n* **Specular lighting:** simulates the bright spot of a light that appears on shiny objects. Specular highlights are often more inclined to the color of the light than the color of the object.\n\n\t```C++\n\tfloat RVn = pow( (float) dot( V, R ), (float) mat->n);  \\\\Phong lighting model\n\tfloat RVn = pow( (float) dot( N, H ), (float) mat->n);  \\\\Blinn-Phong lighting model\n\tptLight.I_source * mat->k_r * RVn);\n\t```\n\n## Phong lighting model\n\n```C++\nstatic Color computePhongLighting( const Vector3d &L, const Vector3d &N, const Vector3d &V,\n\t\t\t\t\t\t\t\t   const EMPMaterial* mat, const PointLightSource &ptLight )\n{\n\tVector3d NN = ( dot( L, N ) >= 0.0 )?  N : -N;\n\n\tVector3d R = mirrorReflect( L, NN );\n\tfloat NL = (float) dot( NN, L );\n\tfloat RVn = pow( (float) dot( V, R ), (float) mat->n );\n\n\treturn ptLight.I_source * ( mat->k_d * NL  +  mat->k_r * RVn );\n}\n```\n\n## Blinn-Phong lighting model\n\n```C++\nstatic Color computeBlinnPhongLighting(const Vector3d &L, const Vector3d &N, const Vector3d &V,\n    const EMPMaterial* mat, const PointLightSource &ptLight)\n{\n    Vector3d NN = (dot(L, N) >= 0.0) ? N : -N;\n\n    Vector3d R = mirrorReflect(L, NN);\n    Vector3d H = L + V;\n    H = H.makeUnitVector();\n    float NL = (float)dot(NN, L);\n    float RVn = pow((float)dot(N, H), (float)mat->n);\n\n    return ptLight.I_source * (mat->k_d * NL + mat->k_r * RVn);\n}\n\n```\n\nthose lighting models are experience model, it is not base on physically visual effect. \n\nphysically based rendering is a collection of render techniques, these techniques will be introduced in other series of articles. \n\n[Physically Based Rendering Series Catalogue](http://hucoco.com/2018/07/04/Physically-Based-Rendering-Catalogue/), and  the series is in progress.\n\n## Reference\n\n**[Learn OpenGL](https://learnopengl.com/) **\n","source":"_posts/Lighting_and_Materials.md","raw":"---\ntitle: Lighting and Materials\ndate: 2018-07-09 20:59:05\nthumbnail: http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_00.png\nmathjax: true\ntags: \n- Graphics\n- Ray Tracing\ncategories:\n- Graphics\n- Ray Tracing\n---\n\n## Lighting\n\nCaculate lighting effect is extremely complicated and it depends on way too many factors in real world, therefore we use a method based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the **Phong lighting model**. \n\nPhong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area.\n\n![](http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_01.png)\n\n<!--more-->\n\nIn 1977 the **Blinn-Phong lighting model** was introduced by James F. Blinn as an extension to the Phong shading we've used so far. The Blinn-Phong model is largely similar, but approaches the specular model slightly different which as a result overcomes our problem. Instead of relying on a reflection vector we're using a so called halfway vector that is a unit vector exactly halfway between the view direction and the light direction. The closer this halfway vector aligns with the surface's normal vector, the higher the specular contribution.\n\n![](http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_02.png)\n\nGetting the halfway vector is easy, we add the light's direction vector and view vector together and normalize the result:\n\n$$\n\\overline{H} = \\frac{\\overline{V} + \\overline{H}}\n{\\begin{Vmatrix}\n\\overline{V} + \\overline{H}\n\\end{Vmatrix}}\n$$\n\n\n## Matrials\n\nThe major building blocks of the Phong model consist of 3 components: ambient, diffuse and specular lighting. Below you can see what these lighting components actually look like:\n\n![](http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_00.png)\n\n* **Ambient lighting:** even when it is dark there is usually still some light somewhere in the world (the moon, a distant light) so objects are almost never completely dark. To simulate this we use an ambient lighting constant that always gives the object some color.\n* **Diffuse lighting:** simulates the directional impact a light object has on an object. This is the most visually significant component of the lighting model. The more a part of an object faces the light source, the brighter it becomes.\n\n\t```C++\n\tptLight.I_source * mat->k_d * NL\n\t```\n\t\n* **Specular lighting:** simulates the bright spot of a light that appears on shiny objects. Specular highlights are often more inclined to the color of the light than the color of the object.\n\n\t```C++\n\tfloat RVn = pow( (float) dot( V, R ), (float) mat->n);  \\\\Phong lighting model\n\tfloat RVn = pow( (float) dot( N, H ), (float) mat->n);  \\\\Blinn-Phong lighting model\n\tptLight.I_source * mat->k_r * RVn);\n\t```\n\n## Phong lighting model\n\n```C++\nstatic Color computePhongLighting( const Vector3d &L, const Vector3d &N, const Vector3d &V,\n\t\t\t\t\t\t\t\t   const EMPMaterial* mat, const PointLightSource &ptLight )\n{\n\tVector3d NN = ( dot( L, N ) >= 0.0 )?  N : -N;\n\n\tVector3d R = mirrorReflect( L, NN );\n\tfloat NL = (float) dot( NN, L );\n\tfloat RVn = pow( (float) dot( V, R ), (float) mat->n );\n\n\treturn ptLight.I_source * ( mat->k_d * NL  +  mat->k_r * RVn );\n}\n```\n\n## Blinn-Phong lighting model\n\n```C++\nstatic Color computeBlinnPhongLighting(const Vector3d &L, const Vector3d &N, const Vector3d &V,\n    const EMPMaterial* mat, const PointLightSource &ptLight)\n{\n    Vector3d NN = (dot(L, N) >= 0.0) ? N : -N;\n\n    Vector3d R = mirrorReflect(L, NN);\n    Vector3d H = L + V;\n    H = H.makeUnitVector();\n    float NL = (float)dot(NN, L);\n    float RVn = pow((float)dot(N, H), (float)mat->n);\n\n    return ptLight.I_source * (mat->k_d * NL + mat->k_r * RVn);\n}\n\n```\n\nthose lighting models are experience model, it is not base on physically visual effect. \n\nphysically based rendering is a collection of render techniques, these techniques will be introduced in other series of articles. \n\n[Physically Based Rendering Series Catalogue](http://hucoco.com/2018/07/04/Physically-Based-Rendering-Catalogue/), and  the series is in progress.\n\n## Reference\n\n**[Learn OpenGL](https://learnopengl.com/) **\n","slug":"Lighting_and_Materials","published":1,"updated":"2018-07-10T07:29:02.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36tv000bssb9ox92ry7y","content":"<h2 id=\"Lighting\"><a href=\"#Lighting\" class=\"headerlink\" title=\"Lighting\"></a>Lighting</h2><p>Caculate lighting effect is extremely complicated and it depends on way too many factors in real world, therefore we use a method based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the <strong>Phong lighting model</strong>. </p>\n<p>Phong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_01.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>In 1977 the <strong>Blinn-Phong lighting model</strong> was introduced by James F. Blinn as an extension to the Phong shading we’ve used so far. The Blinn-Phong model is largely similar, but approaches the specular model slightly different which as a result overcomes our problem. Instead of relying on a reflection vector we’re using a so called halfway vector that is a unit vector exactly halfway between the view direction and the light direction. The closer this halfway vector aligns with the surface’s normal vector, the higher the specular contribution.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_02.png\" alt=\"\"></p>\n<p>Getting the halfway vector is easy, we add the light’s direction vector and view vector together and normalize the result:</p>\n<script type=\"math/tex; mode=display\">\n\\overline{H} = \\frac{\\overline{V} + \\overline{H}}\n{\\begin{Vmatrix}\n\\overline{V} + \\overline{H}\n\\end{Vmatrix}}</script><h2 id=\"Matrials\"><a href=\"#Matrials\" class=\"headerlink\" title=\"Matrials\"></a>Matrials</h2><p>The major building blocks of the Phong model consist of 3 components: ambient, diffuse and specular lighting. Below you can see what these lighting components actually look like:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_00.png\" alt=\"\"></p>\n<ul>\n<li><strong>Ambient lighting:</strong> even when it is dark there is usually still some light somewhere in the world (the moon, a distant light) so objects are almost never completely dark. To simulate this we use an ambient lighting constant that always gives the object some color.</li>\n<li><p><strong>Diffuse lighting:</strong> simulates the directional impact a light object has on an object. This is the most visually significant component of the lighting model. The more a part of an object faces the light source, the brighter it becomes.</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ptLight.I_source * mat-&gt;k_d * NL</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><strong>Specular lighting:</strong> simulates the bright spot of a light that appears on shiny objects. Specular highlights are often more inclined to the color of the light than the color of the object.</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> RVn = <span class=\"built_in\">pow</span>( (<span class=\"keyword\">float</span>) dot( V, R ), (<span class=\"keyword\">float</span>) mat-&gt;n);  \\\\Phong lighting model</span><br><span class=\"line\"><span class=\"keyword\">float</span> RVn = <span class=\"built_in\">pow</span>( (<span class=\"keyword\">float</span>) dot( N, H ), (<span class=\"keyword\">float</span>) mat-&gt;n);  \\\\Blinn-Phong lighting model</span><br><span class=\"line\">ptLight.I_source * mat-&gt;k_r * RVn);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Phong-lighting-model\"><a href=\"#Phong-lighting-model\" class=\"headerlink\" title=\"Phong lighting model\"></a>Phong lighting model</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Color <span class=\"title\">computePhongLighting</span><span class=\"params\">( <span class=\"keyword\">const</span> Vector3d &amp;L, <span class=\"keyword\">const</span> Vector3d &amp;N, <span class=\"keyword\">const</span> Vector3d &amp;V,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t   <span class=\"keyword\">const</span> EMPMaterial* mat, <span class=\"keyword\">const</span> PointLightSource &amp;ptLight )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tVector3d NN = ( dot( L, N ) &gt;= <span class=\"number\">0.0</span> )?  N : -N;</span><br><span class=\"line\"></span><br><span class=\"line\">\tVector3d R = mirrorReflect( L, NN );</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NL = (<span class=\"keyword\">float</span>) dot( NN, L );</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> RVn = <span class=\"built_in\">pow</span>( (<span class=\"keyword\">float</span>) dot( V, R ), (<span class=\"keyword\">float</span>) mat-&gt;n );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptLight.I_source * ( mat-&gt;k_d * NL  +  mat-&gt;k_r * RVn );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Blinn-Phong-lighting-model\"><a href=\"#Blinn-Phong-lighting-model\" class=\"headerlink\" title=\"Blinn-Phong lighting model\"></a>Blinn-Phong lighting model</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Color <span class=\"title\">computeBlinnPhongLighting</span><span class=\"params\">(<span class=\"keyword\">const</span> Vector3d &amp;L, <span class=\"keyword\">const</span> Vector3d &amp;N, <span class=\"keyword\">const</span> Vector3d &amp;V,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> EMPMaterial* mat, <span class=\"keyword\">const</span> PointLightSource &amp;ptLight)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Vector3d NN = (dot(L, N) &gt;= <span class=\"number\">0.0</span>) ? N : -N;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector3d R = mirrorReflect(L, NN);</span><br><span class=\"line\">    Vector3d H = L + V;</span><br><span class=\"line\">    H = H.makeUnitVector();</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NL = (<span class=\"keyword\">float</span>)dot(NN, L);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> RVn = <span class=\"built_in\">pow</span>((<span class=\"keyword\">float</span>)dot(N, H), (<span class=\"keyword\">float</span>)mat-&gt;n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ptLight.I_source * (mat-&gt;k_d * NL + mat-&gt;k_r * RVn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>those lighting models are experience model, it is not base on physically visual effect. </p>\n<p>physically based rendering is a collection of render techniques, these techniques will be introduced in other series of articles. </p>\n<p><a href=\"http://hucoco.com/2018/07/04/Physically-Based-Rendering-Catalogue/\">Physically Based Rendering Series Catalogue</a>, and  the series is in progress.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Lighting\"><a href=\"#Lighting\" class=\"headerlink\" title=\"Lighting\"></a>Lighting</h2><p>Caculate lighting effect is extremely complicated and it depends on way too many factors in real world, therefore we use a method based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the <strong>Phong lighting model</strong>. </p>\n<p>Phong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_01.png\" alt=\"\"></p>","more":"<p>In 1977 the <strong>Blinn-Phong lighting model</strong> was introduced by James F. Blinn as an extension to the Phong shading we’ve used so far. The Blinn-Phong model is largely similar, but approaches the specular model slightly different which as a result overcomes our problem. Instead of relying on a reflection vector we’re using a so called halfway vector that is a unit vector exactly halfway between the view direction and the light direction. The closer this halfway vector aligns with the surface’s normal vector, the higher the specular contribution.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_02.png\" alt=\"\"></p>\n<p>Getting the halfway vector is easy, we add the light’s direction vector and view vector together and normalize the result:</p>\n<script type=\"math/tex; mode=display\">\n\\overline{H} = \\frac{\\overline{V} + \\overline{H}}\n{\\begin{Vmatrix}\n\\overline{V} + \\overline{H}\n\\end{Vmatrix}}</script><h2 id=\"Matrials\"><a href=\"#Matrials\" class=\"headerlink\" title=\"Matrials\"></a>Matrials</h2><p>The major building blocks of the Phong model consist of 3 components: ambient, diffuse and specular lighting. Below you can see what these lighting components actually look like:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/lighting_and_matrials_00.png\" alt=\"\"></p>\n<ul>\n<li><strong>Ambient lighting:</strong> even when it is dark there is usually still some light somewhere in the world (the moon, a distant light) so objects are almost never completely dark. To simulate this we use an ambient lighting constant that always gives the object some color.</li>\n<li><p><strong>Diffuse lighting:</strong> simulates the directional impact a light object has on an object. This is the most visually significant component of the lighting model. The more a part of an object faces the light source, the brighter it becomes.</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ptLight.I_source * mat-&gt;k_d * NL</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><strong>Specular lighting:</strong> simulates the bright spot of a light that appears on shiny objects. Specular highlights are often more inclined to the color of the light than the color of the object.</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> RVn = <span class=\"built_in\">pow</span>( (<span class=\"keyword\">float</span>) dot( V, R ), (<span class=\"keyword\">float</span>) mat-&gt;n);  \\\\Phong lighting model</span><br><span class=\"line\"><span class=\"keyword\">float</span> RVn = <span class=\"built_in\">pow</span>( (<span class=\"keyword\">float</span>) dot( N, H ), (<span class=\"keyword\">float</span>) mat-&gt;n);  \\\\Blinn-Phong lighting model</span><br><span class=\"line\">ptLight.I_source * mat-&gt;k_r * RVn);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Phong-lighting-model\"><a href=\"#Phong-lighting-model\" class=\"headerlink\" title=\"Phong lighting model\"></a>Phong lighting model</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Color <span class=\"title\">computePhongLighting</span><span class=\"params\">( <span class=\"keyword\">const</span> Vector3d &amp;L, <span class=\"keyword\">const</span> Vector3d &amp;N, <span class=\"keyword\">const</span> Vector3d &amp;V,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t   <span class=\"keyword\">const</span> EMPMaterial* mat, <span class=\"keyword\">const</span> PointLightSource &amp;ptLight )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tVector3d NN = ( dot( L, N ) &gt;= <span class=\"number\">0.0</span> )?  N : -N;</span><br><span class=\"line\"></span><br><span class=\"line\">\tVector3d R = mirrorReflect( L, NN );</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NL = (<span class=\"keyword\">float</span>) dot( NN, L );</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> RVn = <span class=\"built_in\">pow</span>( (<span class=\"keyword\">float</span>) dot( V, R ), (<span class=\"keyword\">float</span>) mat-&gt;n );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptLight.I_source * ( mat-&gt;k_d * NL  +  mat-&gt;k_r * RVn );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Blinn-Phong-lighting-model\"><a href=\"#Blinn-Phong-lighting-model\" class=\"headerlink\" title=\"Blinn-Phong lighting model\"></a>Blinn-Phong lighting model</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Color <span class=\"title\">computeBlinnPhongLighting</span><span class=\"params\">(<span class=\"keyword\">const</span> Vector3d &amp;L, <span class=\"keyword\">const</span> Vector3d &amp;N, <span class=\"keyword\">const</span> Vector3d &amp;V,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> EMPMaterial* mat, <span class=\"keyword\">const</span> PointLightSource &amp;ptLight)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Vector3d NN = (dot(L, N) &gt;= <span class=\"number\">0.0</span>) ? N : -N;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector3d R = mirrorReflect(L, NN);</span><br><span class=\"line\">    Vector3d H = L + V;</span><br><span class=\"line\">    H = H.makeUnitVector();</span><br><span class=\"line\">    <span class=\"keyword\">float</span> NL = (<span class=\"keyword\">float</span>)dot(NN, L);</span><br><span class=\"line\">    <span class=\"keyword\">float</span> RVn = <span class=\"built_in\">pow</span>((<span class=\"keyword\">float</span>)dot(N, H), (<span class=\"keyword\">float</span>)mat-&gt;n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ptLight.I_source * (mat-&gt;k_d * NL + mat-&gt;k_r * RVn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>those lighting models are experience model, it is not base on physically visual effect. </p>\n<p>physically based rendering is a collection of render techniques, these techniques will be introduced in other series of articles. </p>\n<p><a href=\"http://hucoco.com/2018/07/04/Physically-Based-Rendering-Catalogue/\">Physically Based Rendering Series Catalogue</a>, and  the series is in progress.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>"},{"title":"Do Ray Tracing","date":"2018-07-10T05:54:10.000Z","thumbnail":"http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png","mathjax":true,"_content":"\n![](http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png)\n\n## Generate Ray\n\nGenerate a ray that goes from the camera's origin through the pixel location (pixelPosX, pixelPosY) of the camera. Note that pixelPosX and pixelPosY can be non-integer. The image origin is at the bottom-leftmost corner, that means:\n\n* The bottom-leftmost corner of the image is (0, 0).\n* The top-rightmost corner of the image is (imageWidth, imageHeight).\n* The center of the bottom-leftmost pixel is (0.5, 0.5). \n* The center of the top-rightmost pixel is (imageWidth-0.5, imageHeight-0.5).\n\n```c++\nRay getRay( double pixelPosX, double pixelPosY ) const\n{\n\tVector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV;\n\treturn Ray( mCOP, imgPos - mCOP );\n}\n```\n\n<!--more-->\n\n## Nearest Surface\n\nFind whether and where the ray hits some surface. Take the nearest hit point. \n\n```C++\nbool hasHitSomething = false;\ndouble nearest_t = DEFAULT_TMAX;\nSurfaceHitRecord nearestHitRec;\n\nfor ( int i = 0; i < scene.numSurfaces; i++ )\n{\n\tSurfaceHitRecord tempHitRec;\n\tbool hasHit = scene.surfacep[i]->hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec );\n\n\tif ( hasHit && tempHitRec.t < nearest_t )\n\t{\n\t\thasHitSomething = true;\n\t\tnearest_t = tempHitRec.t;\n\t\tnearestHitRec = tempHitRec;\n\t}\n}\n```\n\n## Shadow\n\nAdd to result the phong lightin contributed by each point light source. Compute shadow if hasShadow is true.\n\n\n```c++\nbool shadow = true;\nfor(int i = 0 ; i < scene.numPtLights ; i++)\n{\n    \n    Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p;\n    double MaxLength = (Lin).length();\n    double invLen = 1 / MaxLength;\n    Vector3d L = (Lin)*invLen;\n\n    if(hasShadow)\n    {\n        Ray newRay(nearestHitRec.p,L);\n        for(int j = 0 ; j < scene.numSurfaces ; j++)\n        {\n            if(scene.surfacep[j]->shadowHit(newRay, DEFAULT_TMIN, MaxLength))\n            {\n                shadow = false;\n                break;\n            }\n        }\n        if(shadow == false)\n        {\n            continue;\n        }\n    }\n    result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);\n}\n```\n\n## Reflection\n\nAdd to result the reflection of the scene.\n\n```C++\nif(reflectLevels > 0)\n{\n    Vector3d dir = mirrorReflect(V, N);\n    Ray rRay(nearestHitRec.p,dir);\n    result += nearestHitRec.mat_ptr->k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);\n}\n```\n\n## Hammersley Sampling\n\nWe know that binary numbers are used to represent data in the computer. The corresponding relations between decimal and binary systems are shown in the following table. \n\n|Decimal|Binary|\n|:-:|:-:|\n|1|1|\n|2|10|\n|3|11|\n|4|100|\n\nAnd Hammersley Sampling is to generate uniformly distributed 2D random sampliong points by using this characteristics.\n\nIt constructs a value by implementing a **Radical Inverse** method for a binary number. Its process is as follows\n\n|Decimal|Binary|Radical Inverse|Value|\n|:-:|:-:|:-:|:-:|\n|1|1|.1 = 1 * 1/2|0.5|\n|2|10|.01 = 0 * 1/2 + 1 * 1/4|0.25|\n|3|11|.11 = 1 * 1/2 + 1 * 1/4|0.75|\n|4|100|.001 = 0 * 1/2 + 0 * 1/4 + 1 * 1/8|0.125|\n\nConstructing a set of 2D random sampling points for Hammersley Sampling\n\n$$\\phi(i) = RadicalInverse(i)$$\n$$P_i = (x_i,y_i) = (i/N,\\phi(i))$$\n\n## Anti-Aliasing\n\nIn ray tracing world, Anti-Aliasing method is simply, it only just increase the amount of sampling.\n\n#### Anti-Aliasing in GLSL\n\n```c\nfor(uint i = 0 ; i < NumSample; i++)\n{\n\tvec2 offset = Hammersley(i, NumSample);\n\tRay ray = getRay(float(pos.x) + offset.x, float(pos.y) + offset.y); // create ray from camera\n\tcolor += RayTrace(ray,ReflectLevels,HasShadow);\n}\n```\n\n![Without Anti-Aliasing](http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_00.png)\n\n![With Anti-Aliasing](http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png)\n\n## Code\n\n\n```C++\nfor (uint32_t y = task->beginHeight; y < task->endHeight; y++)\n{\n    for (uint32_t x = 0; x < task->width; x++)\n    {\n        Color pixelColor = Color(0, 0, 0);\n        for (uint32_t i = 0; i < task->numSample; i++)\n        {\n            float xx;\n            float yy;\n            Math::Hammersley(i, task->numSample, &xx, &yy);\n            double pixelPosX = x + xx;\n            double pixelPosY = y + yy;\n            Ray ray = task->scene->camera.getRay(pixelPosX, pixelPosY);\n            pixelColor += Raytrace::TraceRay(ray, *task->scene, task->reflectLevels, task->hasShadow);\n        }\n        pixelColor /= (float)task->numSample;\n        pixelColor.clamp();\n        task->output->setPixel(x, y, pixelColor);\n\n    }\n    // printf( \"%d \", y );\n}\n```\n\n```C++\nColor Raytrace::TraceRay( const Ray &ray, const Scene &scene, \n\t\t\t\t\t      int reflectLevels, bool hasShadow )\n{\n\tRay uRay( ray );\n\tuRay.makeUnitDirection();  // Normalize ray direction.\n\n\tbool hasHitSomething = false;\n\tdouble nearest_t = DEFAULT_TMAX;\n\tSurfaceHitRecord nearestHitRec;\n\n\tfor ( int i = 0; i < scene.numSurfaces; i++ )\n\t{\n\t\tSurfaceHitRecord tempHitRec;\n\t\tbool hasHit = scene.surfacep[i]->hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec );\n\n\t\tif ( hasHit && tempHitRec.t < nearest_t )\n\t\t{\n\t\t\thasHitSomething = true;\n\t\t\tnearest_t = tempHitRec.t;\n\t\t\tnearestHitRec = tempHitRec;\n\t\t}\n\t}\n\n\tif ( !hasHitSomething ) return scene.backgroundColor;\n\n\tnearestHitRec.normal.makeUnitVector();\n\tVector3d N = nearestHitRec.normal;\t// Unit vector.\n\tVector3d V = -uRay.direction();\t\t// Unit vector.\n    \n\tColor result( 0.0f, 0.0f, 0.0f );\t// The result will be accumulated here.\n\n    bool shadow = 1.0f;\n    for(int i = 0 ; i < scene.numPtLights ; i++)\n    {\n        \n        Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p;\n        double MaxLength = (Lin).length();\n        double invLen = 1 / MaxLength;\n        Vector3d L = (Lin)*invLen;\n\n        if(hasShadow)\n        {\n            Ray newRay(nearestHitRec.p,L);\n            for(int j = 0 ; j < scene.numSurfaces ; j++)\n            {\n                if(scene.surfacep[j]->shadowHit(newRay, DEFAULT_TMIN, MaxLength))\n                {\n                    shadow = true;\n                    break;\n                }\n            }\n            if(shadow == false)\n            {\n                continue;\n            }\n        }\n        result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);\n    }\n    \n    result += scene.amLight.I_a * nearestHitRec.mat_ptr->k_a;\n\n    if(reflectLevels > 0)\n    {\n        Vector3d dir = mirrorReflect(V, N);\n        Ray rRay(nearestHitRec.p,dir);\n        result += nearestHitRec.mat_ptr->k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);\n    }\n\n\n\treturn result;\n}\n```\n\n## Reference\n\n**[Learn OpenGL](https://learnopengl.com/) **","source":"_posts/Do-Ray-Tracing.md","raw":"---\ntitle: Do Ray Tracing\ndate: 2018-07-10 13:54:10\nthumbnail: http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png\nmathjax: true\ntags: \n- Graphics\n- Ray Tracing\ncategories:\n- Graphics\n- Ray Tracing\n---\n\n![](http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png)\n\n## Generate Ray\n\nGenerate a ray that goes from the camera's origin through the pixel location (pixelPosX, pixelPosY) of the camera. Note that pixelPosX and pixelPosY can be non-integer. The image origin is at the bottom-leftmost corner, that means:\n\n* The bottom-leftmost corner of the image is (0, 0).\n* The top-rightmost corner of the image is (imageWidth, imageHeight).\n* The center of the bottom-leftmost pixel is (0.5, 0.5). \n* The center of the top-rightmost pixel is (imageWidth-0.5, imageHeight-0.5).\n\n```c++\nRay getRay( double pixelPosX, double pixelPosY ) const\n{\n\tVector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV;\n\treturn Ray( mCOP, imgPos - mCOP );\n}\n```\n\n<!--more-->\n\n## Nearest Surface\n\nFind whether and where the ray hits some surface. Take the nearest hit point. \n\n```C++\nbool hasHitSomething = false;\ndouble nearest_t = DEFAULT_TMAX;\nSurfaceHitRecord nearestHitRec;\n\nfor ( int i = 0; i < scene.numSurfaces; i++ )\n{\n\tSurfaceHitRecord tempHitRec;\n\tbool hasHit = scene.surfacep[i]->hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec );\n\n\tif ( hasHit && tempHitRec.t < nearest_t )\n\t{\n\t\thasHitSomething = true;\n\t\tnearest_t = tempHitRec.t;\n\t\tnearestHitRec = tempHitRec;\n\t}\n}\n```\n\n## Shadow\n\nAdd to result the phong lightin contributed by each point light source. Compute shadow if hasShadow is true.\n\n\n```c++\nbool shadow = true;\nfor(int i = 0 ; i < scene.numPtLights ; i++)\n{\n    \n    Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p;\n    double MaxLength = (Lin).length();\n    double invLen = 1 / MaxLength;\n    Vector3d L = (Lin)*invLen;\n\n    if(hasShadow)\n    {\n        Ray newRay(nearestHitRec.p,L);\n        for(int j = 0 ; j < scene.numSurfaces ; j++)\n        {\n            if(scene.surfacep[j]->shadowHit(newRay, DEFAULT_TMIN, MaxLength))\n            {\n                shadow = false;\n                break;\n            }\n        }\n        if(shadow == false)\n        {\n            continue;\n        }\n    }\n    result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);\n}\n```\n\n## Reflection\n\nAdd to result the reflection of the scene.\n\n```C++\nif(reflectLevels > 0)\n{\n    Vector3d dir = mirrorReflect(V, N);\n    Ray rRay(nearestHitRec.p,dir);\n    result += nearestHitRec.mat_ptr->k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);\n}\n```\n\n## Hammersley Sampling\n\nWe know that binary numbers are used to represent data in the computer. The corresponding relations between decimal and binary systems are shown in the following table. \n\n|Decimal|Binary|\n|:-:|:-:|\n|1|1|\n|2|10|\n|3|11|\n|4|100|\n\nAnd Hammersley Sampling is to generate uniformly distributed 2D random sampliong points by using this characteristics.\n\nIt constructs a value by implementing a **Radical Inverse** method for a binary number. Its process is as follows\n\n|Decimal|Binary|Radical Inverse|Value|\n|:-:|:-:|:-:|:-:|\n|1|1|.1 = 1 * 1/2|0.5|\n|2|10|.01 = 0 * 1/2 + 1 * 1/4|0.25|\n|3|11|.11 = 1 * 1/2 + 1 * 1/4|0.75|\n|4|100|.001 = 0 * 1/2 + 0 * 1/4 + 1 * 1/8|0.125|\n\nConstructing a set of 2D random sampling points for Hammersley Sampling\n\n$$\\phi(i) = RadicalInverse(i)$$\n$$P_i = (x_i,y_i) = (i/N,\\phi(i))$$\n\n## Anti-Aliasing\n\nIn ray tracing world, Anti-Aliasing method is simply, it only just increase the amount of sampling.\n\n#### Anti-Aliasing in GLSL\n\n```c\nfor(uint i = 0 ; i < NumSample; i++)\n{\n\tvec2 offset = Hammersley(i, NumSample);\n\tRay ray = getRay(float(pos.x) + offset.x, float(pos.y) + offset.y); // create ray from camera\n\tcolor += RayTrace(ray,ReflectLevels,HasShadow);\n}\n```\n\n![Without Anti-Aliasing](http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_00.png)\n\n![With Anti-Aliasing](http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png)\n\n## Code\n\n\n```C++\nfor (uint32_t y = task->beginHeight; y < task->endHeight; y++)\n{\n    for (uint32_t x = 0; x < task->width; x++)\n    {\n        Color pixelColor = Color(0, 0, 0);\n        for (uint32_t i = 0; i < task->numSample; i++)\n        {\n            float xx;\n            float yy;\n            Math::Hammersley(i, task->numSample, &xx, &yy);\n            double pixelPosX = x + xx;\n            double pixelPosY = y + yy;\n            Ray ray = task->scene->camera.getRay(pixelPosX, pixelPosY);\n            pixelColor += Raytrace::TraceRay(ray, *task->scene, task->reflectLevels, task->hasShadow);\n        }\n        pixelColor /= (float)task->numSample;\n        pixelColor.clamp();\n        task->output->setPixel(x, y, pixelColor);\n\n    }\n    // printf( \"%d \", y );\n}\n```\n\n```C++\nColor Raytrace::TraceRay( const Ray &ray, const Scene &scene, \n\t\t\t\t\t      int reflectLevels, bool hasShadow )\n{\n\tRay uRay( ray );\n\tuRay.makeUnitDirection();  // Normalize ray direction.\n\n\tbool hasHitSomething = false;\n\tdouble nearest_t = DEFAULT_TMAX;\n\tSurfaceHitRecord nearestHitRec;\n\n\tfor ( int i = 0; i < scene.numSurfaces; i++ )\n\t{\n\t\tSurfaceHitRecord tempHitRec;\n\t\tbool hasHit = scene.surfacep[i]->hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec );\n\n\t\tif ( hasHit && tempHitRec.t < nearest_t )\n\t\t{\n\t\t\thasHitSomething = true;\n\t\t\tnearest_t = tempHitRec.t;\n\t\t\tnearestHitRec = tempHitRec;\n\t\t}\n\t}\n\n\tif ( !hasHitSomething ) return scene.backgroundColor;\n\n\tnearestHitRec.normal.makeUnitVector();\n\tVector3d N = nearestHitRec.normal;\t// Unit vector.\n\tVector3d V = -uRay.direction();\t\t// Unit vector.\n    \n\tColor result( 0.0f, 0.0f, 0.0f );\t// The result will be accumulated here.\n\n    bool shadow = 1.0f;\n    for(int i = 0 ; i < scene.numPtLights ; i++)\n    {\n        \n        Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p;\n        double MaxLength = (Lin).length();\n        double invLen = 1 / MaxLength;\n        Vector3d L = (Lin)*invLen;\n\n        if(hasShadow)\n        {\n            Ray newRay(nearestHitRec.p,L);\n            for(int j = 0 ; j < scene.numSurfaces ; j++)\n            {\n                if(scene.surfacep[j]->shadowHit(newRay, DEFAULT_TMIN, MaxLength))\n                {\n                    shadow = true;\n                    break;\n                }\n            }\n            if(shadow == false)\n            {\n                continue;\n            }\n        }\n        result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);\n    }\n    \n    result += scene.amLight.I_a * nearestHitRec.mat_ptr->k_a;\n\n    if(reflectLevels > 0)\n    {\n        Vector3d dir = mirrorReflect(V, N);\n        Ray rRay(nearestHitRec.p,dir);\n        result += nearestHitRec.mat_ptr->k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);\n    }\n\n\n\treturn result;\n}\n```\n\n## Reference\n\n**[Learn OpenGL](https://learnopengl.com/) **","slug":"Do-Ray-Tracing","published":1,"updated":"2018-07-10T07:28:42.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36tx000essb97d9ne8wp","content":"<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png\" alt=\"\"></p>\n<h2 id=\"Generate-Ray\"><a href=\"#Generate-Ray\" class=\"headerlink\" title=\"Generate Ray\"></a>Generate Ray</h2><p>Generate a ray that goes from the camera’s origin through the pixel location (pixelPosX, pixelPosY) of the camera. Note that pixelPosX and pixelPosY can be non-integer. The image origin is at the bottom-leftmost corner, that means:</p>\n<ul>\n<li>The bottom-leftmost corner of the image is (0, 0).</li>\n<li>The top-rightmost corner of the image is (imageWidth, imageHeight).</li>\n<li>The center of the bottom-leftmost pixel is (0.5, 0.5). </li>\n<li>The center of the top-rightmost pixel is (imageWidth-0.5, imageHeight-0.5).</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Ray <span class=\"title\">getRay</span><span class=\"params\">( <span class=\"keyword\">double</span> pixelPosX, <span class=\"keyword\">double</span> pixelPosY )</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tVector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Ray( mCOP, imgPos - mCOP );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"Nearest-Surface\"><a href=\"#Nearest-Surface\" class=\"headerlink\" title=\"Nearest Surface\"></a>Nearest Surface</h2><p>Find whether and where the ray hits some surface. Take the nearest hit point. </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> hasHitSomething = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> <span class=\"keyword\">nearest_t</span> = DEFAULT_TMAX;</span><br><span class=\"line\">SurfaceHitRecord nearestHitRec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; scene.numSurfaces; i++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSurfaceHitRecord tempHitRec;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> hasHit = scene.surfacep[i]-&gt;hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( hasHit &amp;&amp; tempHitRec.t &lt; <span class=\"keyword\">nearest_t</span> )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thasHitSomething = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">nearest_t</span> = tempHitRec.t;</span><br><span class=\"line\">\t\tnearestHitRec = tempHitRec;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Shadow\"><a href=\"#Shadow\" class=\"headerlink\" title=\"Shadow\"></a>Shadow</h2><p>Add to result the phong lightin contributed by each point light source. Compute shadow if hasShadow is true.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> shadow = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; scene.numPtLights ; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> MaxLength = (Lin).length();</span><br><span class=\"line\">    <span class=\"keyword\">double</span> invLen = <span class=\"number\">1</span> / MaxLength;</span><br><span class=\"line\">    Vector3d L = (Lin)*invLen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(hasShadow)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">Ray <span class=\"title\">newRay</span><span class=\"params\">(nearestHitRec.p,L)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; scene.numSurfaces ; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(scene.surfacep[j]-&gt;shadowHit(newRay, DEFAULT_TMIN, MaxLength))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                shadow = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(shadow == <span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reflection\"><a href=\"#Reflection\" class=\"headerlink\" title=\"Reflection\"></a>Reflection</h2><p>Add to result the reflection of the scene.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(reflectLevels &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3d dir = mirrorReflect(V, N);</span><br><span class=\"line\">    <span class=\"function\">Ray <span class=\"title\">rRay</span><span class=\"params\">(nearestHitRec.p,dir)</span></span>;</span><br><span class=\"line\">    result += nearestHitRec.mat_ptr-&gt;k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hammersley-Sampling\"><a href=\"#Hammersley-Sampling\" class=\"headerlink\" title=\"Hammersley Sampling\"></a>Hammersley Sampling</h2><p>We know that binary numbers are used to represent data in the computer. The corresponding relations between decimal and binary systems are shown in the following table. </p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Decimal</th>\n<th style=\"text-align:center\">Binary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">11</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>And Hammersley Sampling is to generate uniformly distributed 2D random sampliong points by using this characteristics.</p>\n<p>It constructs a value by implementing a <strong>Radical Inverse</strong> method for a binary number. Its process is as follows</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Decimal</th>\n<th style=\"text-align:center\">Binary</th>\n<th style=\"text-align:center\">Radical Inverse</th>\n<th style=\"text-align:center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">.1 = 1 * 1/2</td>\n<td style=\"text-align:center\">0.5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">.01 = 0 <em> 1/2 + 1 </em> 1/4</td>\n<td style=\"text-align:center\">0.25</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">.11 = 1 <em> 1/2 + 1 </em> 1/4</td>\n<td style=\"text-align:center\">0.75</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">.001 = 0 <em> 1/2 + 0 </em> 1/4 + 1 * 1/8</td>\n<td style=\"text-align:center\">0.125</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Constructing a set of 2D random sampling points for Hammersley Sampling</p>\n<script type=\"math/tex; mode=display\">\\phi(i) = RadicalInverse(i)</script><script type=\"math/tex; mode=display\">P_i = (x_i,y_i) = (i/N,\\phi(i))</script><h2 id=\"Anti-Aliasing\"><a href=\"#Anti-Aliasing\" class=\"headerlink\" title=\"Anti-Aliasing\"></a>Anti-Aliasing</h2><p>In ray tracing world, Anti-Aliasing method is simply, it only just increase the amount of sampling.</p>\n<h4 id=\"Anti-Aliasing-in-GLSL\"><a href=\"#Anti-Aliasing-in-GLSL\" class=\"headerlink\" title=\"Anti-Aliasing in GLSL\"></a>Anti-Aliasing in GLSL</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(uint i = <span class=\"number\">0</span> ; i &lt; NumSample; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvec2 offset = Hammersley(i, NumSample);</span><br><span class=\"line\">\tRay ray = getRay(<span class=\"keyword\">float</span>(pos.x) + offset.x, <span class=\"keyword\">float</span>(pos.y) + offset.y); <span class=\"comment\">// create ray from camera</span></span><br><span class=\"line\">\tcolor += RayTrace(ray,ReflectLevels,HasShadow);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_00.png\" alt=\"Without Anti-Aliasing\"></p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png\" alt=\"With Anti-Aliasing\"></p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">uint32_t</span> y = task-&gt;beginHeight; y &lt; task-&gt;endHeight; y++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint32_t</span> x = <span class=\"number\">0</span>; x &lt; task-&gt;width; x++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Color pixelColor = Color(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; task-&gt;numSample; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> xx;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> yy;</span><br><span class=\"line\">            Math::Hammersley(i, task-&gt;numSample, &amp;xx, &amp;yy);</span><br><span class=\"line\">            <span class=\"keyword\">double</span> pixelPosX = x + xx;</span><br><span class=\"line\">            <span class=\"keyword\">double</span> pixelPosY = y + yy;</span><br><span class=\"line\">            Ray ray = task-&gt;scene-&gt;camera.getRay(pixelPosX, pixelPosY);</span><br><span class=\"line\">            pixelColor += Raytrace::TraceRay(ray, *task-&gt;scene, task-&gt;reflectLevels, task-&gt;hasShadow);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pixelColor /= (<span class=\"keyword\">float</span>)task-&gt;numSample;</span><br><span class=\"line\">        pixelColor.clamp();</span><br><span class=\"line\">        task-&gt;output-&gt;setPixel(x, y, pixelColor);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// printf( \"%d \", y );</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Color Raytrace::TraceRay( <span class=\"keyword\">const</span> Ray &amp;ray, <span class=\"keyword\">const</span> Scene &amp;scene, </span><br><span class=\"line\">\t\t\t\t\t      <span class=\"keyword\">int</span> reflectLevels, <span class=\"keyword\">bool</span> hasShadow )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\">Ray <span class=\"title\">uRay</span><span class=\"params\">( ray )</span></span>;</span><br><span class=\"line\">\tuRay.makeUnitDirection();  <span class=\"comment\">// Normalize ray direction.</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> hasHitSomething = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> <span class=\"keyword\">nearest_t</span> = DEFAULT_TMAX;</span><br><span class=\"line\">\tSurfaceHitRecord nearestHitRec;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; scene.numSurfaces; i++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSurfaceHitRecord tempHitRec;</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> hasHit = scene.surfacep[i]-&gt;hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( hasHit &amp;&amp; tempHitRec.t &lt; <span class=\"keyword\">nearest_t</span> )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\thasHitSomething = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">nearest_t</span> = tempHitRec.t;</span><br><span class=\"line\">\t\t\tnearestHitRec = tempHitRec;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( !hasHitSomething ) <span class=\"keyword\">return</span> scene.backgroundColor;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnearestHitRec.normal.makeUnitVector();</span><br><span class=\"line\">\tVector3d N = nearestHitRec.normal;\t<span class=\"comment\">// Unit vector.</span></span><br><span class=\"line\">\tVector3d V = -uRay.direction();\t\t<span class=\"comment\">// Unit vector.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"function\">Color <span class=\"title\">result</span><span class=\"params\">( <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span> )</span></span>;\t<span class=\"comment\">// The result will be accumulated here.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> shadow = <span class=\"number\">1.0f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; scene.numPtLights ; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> MaxLength = (Lin).length();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> invLen = <span class=\"number\">1</span> / MaxLength;</span><br><span class=\"line\">        Vector3d L = (Lin)*invLen;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hasShadow)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\">Ray <span class=\"title\">newRay</span><span class=\"params\">(nearestHitRec.p,L)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; scene.numSurfaces ; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(scene.surfacep[j]-&gt;shadowHit(newRay, DEFAULT_TMIN, MaxLength))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    shadow = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(shadow == <span class=\"literal\">false</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    result += scene.amLight.I_a * nearestHitRec.mat_ptr-&gt;k_a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reflectLevels &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Vector3d dir = mirrorReflect(V, N);</span><br><span class=\"line\">        <span class=\"function\">Ray <span class=\"title\">rRay</span><span class=\"params\">(nearestHitRec.p,dir)</span></span>;</span><br><span class=\"line\">        result += nearestHitRec.mat_ptr-&gt;k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png\" alt=\"\"></p>\n<h2 id=\"Generate-Ray\"><a href=\"#Generate-Ray\" class=\"headerlink\" title=\"Generate Ray\"></a>Generate Ray</h2><p>Generate a ray that goes from the camera’s origin through the pixel location (pixelPosX, pixelPosY) of the camera. Note that pixelPosX and pixelPosY can be non-integer. The image origin is at the bottom-leftmost corner, that means:</p>\n<ul>\n<li>The bottom-leftmost corner of the image is (0, 0).</li>\n<li>The top-rightmost corner of the image is (imageWidth, imageHeight).</li>\n<li>The center of the bottom-leftmost pixel is (0.5, 0.5). </li>\n<li>The center of the top-rightmost pixel is (imageWidth-0.5, imageHeight-0.5).</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Ray <span class=\"title\">getRay</span><span class=\"params\">( <span class=\"keyword\">double</span> pixelPosX, <span class=\"keyword\">double</span> pixelPosY )</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tVector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Ray( mCOP, imgPos - mCOP );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"Nearest-Surface\"><a href=\"#Nearest-Surface\" class=\"headerlink\" title=\"Nearest Surface\"></a>Nearest Surface</h2><p>Find whether and where the ray hits some surface. Take the nearest hit point. </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> hasHitSomething = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> <span class=\"keyword\">nearest_t</span> = DEFAULT_TMAX;</span><br><span class=\"line\">SurfaceHitRecord nearestHitRec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; scene.numSurfaces; i++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSurfaceHitRecord tempHitRec;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> hasHit = scene.surfacep[i]-&gt;hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( hasHit &amp;&amp; tempHitRec.t &lt; <span class=\"keyword\">nearest_t</span> )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thasHitSomething = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">nearest_t</span> = tempHitRec.t;</span><br><span class=\"line\">\t\tnearestHitRec = tempHitRec;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Shadow\"><a href=\"#Shadow\" class=\"headerlink\" title=\"Shadow\"></a>Shadow</h2><p>Add to result the phong lightin contributed by each point light source. Compute shadow if hasShadow is true.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> shadow = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; scene.numPtLights ; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> MaxLength = (Lin).length();</span><br><span class=\"line\">    <span class=\"keyword\">double</span> invLen = <span class=\"number\">1</span> / MaxLength;</span><br><span class=\"line\">    Vector3d L = (Lin)*invLen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(hasShadow)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">Ray <span class=\"title\">newRay</span><span class=\"params\">(nearestHitRec.p,L)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; scene.numSurfaces ; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(scene.surfacep[j]-&gt;shadowHit(newRay, DEFAULT_TMIN, MaxLength))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                shadow = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(shadow == <span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reflection\"><a href=\"#Reflection\" class=\"headerlink\" title=\"Reflection\"></a>Reflection</h2><p>Add to result the reflection of the scene.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(reflectLevels &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3d dir = mirrorReflect(V, N);</span><br><span class=\"line\">    <span class=\"function\">Ray <span class=\"title\">rRay</span><span class=\"params\">(nearestHitRec.p,dir)</span></span>;</span><br><span class=\"line\">    result += nearestHitRec.mat_ptr-&gt;k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hammersley-Sampling\"><a href=\"#Hammersley-Sampling\" class=\"headerlink\" title=\"Hammersley Sampling\"></a>Hammersley Sampling</h2><p>We know that binary numbers are used to represent data in the computer. The corresponding relations between decimal and binary systems are shown in the following table. </p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Decimal</th>\n<th style=\"text-align:center\">Binary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">11</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>And Hammersley Sampling is to generate uniformly distributed 2D random sampliong points by using this characteristics.</p>\n<p>It constructs a value by implementing a <strong>Radical Inverse</strong> method for a binary number. Its process is as follows</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Decimal</th>\n<th style=\"text-align:center\">Binary</th>\n<th style=\"text-align:center\">Radical Inverse</th>\n<th style=\"text-align:center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">.1 = 1 * 1/2</td>\n<td style=\"text-align:center\">0.5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">.01 = 0 <em> 1/2 + 1 </em> 1/4</td>\n<td style=\"text-align:center\">0.25</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">.11 = 1 <em> 1/2 + 1 </em> 1/4</td>\n<td style=\"text-align:center\">0.75</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">.001 = 0 <em> 1/2 + 0 </em> 1/4 + 1 * 1/8</td>\n<td style=\"text-align:center\">0.125</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Constructing a set of 2D random sampling points for Hammersley Sampling</p>\n<script type=\"math/tex; mode=display\">\\phi(i) = RadicalInverse(i)</script><script type=\"math/tex; mode=display\">P_i = (x_i,y_i) = (i/N,\\phi(i))</script><h2 id=\"Anti-Aliasing\"><a href=\"#Anti-Aliasing\" class=\"headerlink\" title=\"Anti-Aliasing\"></a>Anti-Aliasing</h2><p>In ray tracing world, Anti-Aliasing method is simply, it only just increase the amount of sampling.</p>\n<h4 id=\"Anti-Aliasing-in-GLSL\"><a href=\"#Anti-Aliasing-in-GLSL\" class=\"headerlink\" title=\"Anti-Aliasing in GLSL\"></a>Anti-Aliasing in GLSL</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(uint i = <span class=\"number\">0</span> ; i &lt; NumSample; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvec2 offset = Hammersley(i, NumSample);</span><br><span class=\"line\">\tRay ray = getRay(<span class=\"keyword\">float</span>(pos.x) + offset.x, <span class=\"keyword\">float</span>(pos.y) + offset.y); <span class=\"comment\">// create ray from camera</span></span><br><span class=\"line\">\tcolor += RayTrace(ray,ReflectLevels,HasShadow);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_00.png\" alt=\"Without Anti-Aliasing\"></p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/DoRayTracing_01.png\" alt=\"With Anti-Aliasing\"></p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">uint32_t</span> y = task-&gt;beginHeight; y &lt; task-&gt;endHeight; y++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint32_t</span> x = <span class=\"number\">0</span>; x &lt; task-&gt;width; x++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Color pixelColor = Color(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; task-&gt;numSample; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> xx;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> yy;</span><br><span class=\"line\">            Math::Hammersley(i, task-&gt;numSample, &amp;xx, &amp;yy);</span><br><span class=\"line\">            <span class=\"keyword\">double</span> pixelPosX = x + xx;</span><br><span class=\"line\">            <span class=\"keyword\">double</span> pixelPosY = y + yy;</span><br><span class=\"line\">            Ray ray = task-&gt;scene-&gt;camera.getRay(pixelPosX, pixelPosY);</span><br><span class=\"line\">            pixelColor += Raytrace::TraceRay(ray, *task-&gt;scene, task-&gt;reflectLevels, task-&gt;hasShadow);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pixelColor /= (<span class=\"keyword\">float</span>)task-&gt;numSample;</span><br><span class=\"line\">        pixelColor.clamp();</span><br><span class=\"line\">        task-&gt;output-&gt;setPixel(x, y, pixelColor);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// printf( \"%d \", y );</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Color Raytrace::TraceRay( <span class=\"keyword\">const</span> Ray &amp;ray, <span class=\"keyword\">const</span> Scene &amp;scene, </span><br><span class=\"line\">\t\t\t\t\t      <span class=\"keyword\">int</span> reflectLevels, <span class=\"keyword\">bool</span> hasShadow )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\">Ray <span class=\"title\">uRay</span><span class=\"params\">( ray )</span></span>;</span><br><span class=\"line\">\tuRay.makeUnitDirection();  <span class=\"comment\">// Normalize ray direction.</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> hasHitSomething = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> <span class=\"keyword\">nearest_t</span> = DEFAULT_TMAX;</span><br><span class=\"line\">\tSurfaceHitRecord nearestHitRec;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; scene.numSurfaces; i++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSurfaceHitRecord tempHitRec;</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> hasHit = scene.surfacep[i]-&gt;hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( hasHit &amp;&amp; tempHitRec.t &lt; <span class=\"keyword\">nearest_t</span> )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\thasHitSomething = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">nearest_t</span> = tempHitRec.t;</span><br><span class=\"line\">\t\t\tnearestHitRec = tempHitRec;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( !hasHitSomething ) <span class=\"keyword\">return</span> scene.backgroundColor;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnearestHitRec.normal.makeUnitVector();</span><br><span class=\"line\">\tVector3d N = nearestHitRec.normal;\t<span class=\"comment\">// Unit vector.</span></span><br><span class=\"line\">\tVector3d V = -uRay.direction();\t\t<span class=\"comment\">// Unit vector.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"function\">Color <span class=\"title\">result</span><span class=\"params\">( <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span> )</span></span>;\t<span class=\"comment\">// The result will be accumulated here.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> shadow = <span class=\"number\">1.0f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; scene.numPtLights ; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> MaxLength = (Lin).length();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> invLen = <span class=\"number\">1</span> / MaxLength;</span><br><span class=\"line\">        Vector3d L = (Lin)*invLen;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hasShadow)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\">Ray <span class=\"title\">newRay</span><span class=\"params\">(nearestHitRec.p,L)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; scene.numSurfaces ; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(scene.surfacep[j]-&gt;shadowHit(newRay, DEFAULT_TMIN, MaxLength))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    shadow = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(shadow == <span class=\"literal\">false</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    result += scene.amLight.I_a * nearestHitRec.mat_ptr-&gt;k_a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reflectLevels &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Vector3d dir = mirrorReflect(V, N);</span><br><span class=\"line\">        <span class=\"function\">Ray <span class=\"title\">rRay</span><span class=\"params\">(nearestHitRec.p,dir)</span></span>;</span><br><span class=\"line\">        result += nearestHitRec.mat_ptr-&gt;k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>"},{"title":"N-Queens Problem","date":"2018-03-09T13:51:43.000Z","thumbnail":"http://hucoco.com/img/EightQueen/EightQueen5.jpg","_content":"\n# N-Queens Problem\n\n## Overview\n\nThe eight queens problem is a question with chess as the background: how to place eight queens on an 8×8 chess board so that no queen can directly eat other queens? In order to achieve this purpose, any two queens are not in the same horizontal, vertical or diagonal. The eight queen problem can be extended to the more general N-Queens Problem.\n\nmore information about n-queens problem please google it.\n\n## C++ Code\n\n```C++\nint NQueens(int n) {\n    int upperlim = (1 << n) - 1, sum = 0;\n    std::function<void(int,int,int)> dfs = [&](int row,int ld,int rd) {\n        if(row == upperlim) {++sum;return;}\n        for(int cur = upperlim & (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)<<1,(rd|pos)>>1)) {\n            pos = cur & (-cur);\n            cur -= pos;\n        }\n    };\n    dfs(0,0,0);\n    return sum;\n}\n```\n\n<!--more-->\n\n## Introduction\n\n### initialization\n\n```\nupperlim = (1 << n) - 1, sum = 0;\n```\n\nUpperlim value is n-bit binary 1.\n\n### Recursive Function\n\n```\nstd::function<void(int,int,int)> dfs = [&](int row,int ld,int rd) {\n    if(row == upperlim) {++sum;return;}\n    for(int cur = upperlim & (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)<<1,(rd|pos)>>1)) {\n        pos = cur & (-cur);\n        cur -= pos;\n    }\n};\n```\n\nThe function has three parameters:\n\n* row : row\n* ld : Left diagonal\n* rd : Right diagonal\n\nUse these three parameters to determine whether a queen can be placed in a certain position.\n\n### Diagram\n\nHere is a step-by-step illustration of the Six Queens question.\n\n![Step #1](http://hucoco.com/img/EightQueen/EightQueen1.jpg)\n\n```\nrow = 000001\nld  = 000010\nrd  = 000000\ncur = 111100\npos = 000100\n```\n---\n![Step #2](http://hucoco.com/img/EightQueen/EightQueen2.jpg)\n\n```\nrow = 000101\nld  = 001100\nrd  = 000010 \ncur = 110000\npos = 010000\n```\n---\n![Step #3](http://hucoco.com/img/EightQueen/EightQueen3.jpg)\n\n```\nrow = 010101\nld  = 111000\nrd  = 001001 \ncur = 000010\npos = 000010\n```\n---\n![Step #4](http://hucoco.com/img/EightQueen/EightQueen4.jpg)\n\n```\nrow = 010111\nld  = 110100\nrd  = 000101 \ncur = 001000\npos = 001000\n```\n---\n![Step #5](http://hucoco.com/img/EightQueen/EightQueen5.jpg)\n\n```\nrow = 011111\nld  = 111000\nrd  = 000110\ncur = 000000\npos = 000000\n```\n---\n\nThe first round of search is completed, there is a kind of thought is the depth first search, is to find a solution and then press forward to the enemy's capital to find second solution, because the eight queens problem belongs to the scope of the graph, so the idea of graph theory can be found in this problem.\n\n","source":"_posts/N-Queens-Problem.md","raw":"---\ntitle: N-Queens Problem\ndate: 2018-03-09 21:51:43\nthumbnail: http://hucoco.com/img/EightQueen/EightQueen5.jpg\ntags: \n- C++\n- Algorithm\n- Backtracking\ncategories:\n- Algorithm\n- Problems\n---\n\n# N-Queens Problem\n\n## Overview\n\nThe eight queens problem is a question with chess as the background: how to place eight queens on an 8×8 chess board so that no queen can directly eat other queens? In order to achieve this purpose, any two queens are not in the same horizontal, vertical or diagonal. The eight queen problem can be extended to the more general N-Queens Problem.\n\nmore information about n-queens problem please google it.\n\n## C++ Code\n\n```C++\nint NQueens(int n) {\n    int upperlim = (1 << n) - 1, sum = 0;\n    std::function<void(int,int,int)> dfs = [&](int row,int ld,int rd) {\n        if(row == upperlim) {++sum;return;}\n        for(int cur = upperlim & (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)<<1,(rd|pos)>>1)) {\n            pos = cur & (-cur);\n            cur -= pos;\n        }\n    };\n    dfs(0,0,0);\n    return sum;\n}\n```\n\n<!--more-->\n\n## Introduction\n\n### initialization\n\n```\nupperlim = (1 << n) - 1, sum = 0;\n```\n\nUpperlim value is n-bit binary 1.\n\n### Recursive Function\n\n```\nstd::function<void(int,int,int)> dfs = [&](int row,int ld,int rd) {\n    if(row == upperlim) {++sum;return;}\n    for(int cur = upperlim & (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)<<1,(rd|pos)>>1)) {\n        pos = cur & (-cur);\n        cur -= pos;\n    }\n};\n```\n\nThe function has three parameters:\n\n* row : row\n* ld : Left diagonal\n* rd : Right diagonal\n\nUse these three parameters to determine whether a queen can be placed in a certain position.\n\n### Diagram\n\nHere is a step-by-step illustration of the Six Queens question.\n\n![Step #1](http://hucoco.com/img/EightQueen/EightQueen1.jpg)\n\n```\nrow = 000001\nld  = 000010\nrd  = 000000\ncur = 111100\npos = 000100\n```\n---\n![Step #2](http://hucoco.com/img/EightQueen/EightQueen2.jpg)\n\n```\nrow = 000101\nld  = 001100\nrd  = 000010 \ncur = 110000\npos = 010000\n```\n---\n![Step #3](http://hucoco.com/img/EightQueen/EightQueen3.jpg)\n\n```\nrow = 010101\nld  = 111000\nrd  = 001001 \ncur = 000010\npos = 000010\n```\n---\n![Step #4](http://hucoco.com/img/EightQueen/EightQueen4.jpg)\n\n```\nrow = 010111\nld  = 110100\nrd  = 000101 \ncur = 001000\npos = 001000\n```\n---\n![Step #5](http://hucoco.com/img/EightQueen/EightQueen5.jpg)\n\n```\nrow = 011111\nld  = 111000\nrd  = 000110\ncur = 000000\npos = 000000\n```\n---\n\nThe first round of search is completed, there is a kind of thought is the depth first search, is to find a solution and then press forward to the enemy's capital to find second solution, because the eight queens problem belongs to the scope of the graph, so the idea of graph theory can be found in this problem.\n\n","slug":"N-Queens-Problem","published":1,"updated":"2018-03-09T14:43:00.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36tz000fssb9h0o7qchd","content":"<h1 id=\"N-Queens-Problem\"><a href=\"#N-Queens-Problem\" class=\"headerlink\" title=\"N-Queens Problem\"></a>N-Queens Problem</h1><h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>The eight queens problem is a question with chess as the background: how to place eight queens on an 8×8 chess board so that no queen can directly eat other queens? In order to achieve this purpose, any two queens are not in the same horizontal, vertical or diagonal. The eight queen problem can be extended to the more general N-Queens Problem.</p>\n<p>more information about n-queens problem please google it.</p>\n<h2 id=\"C-Code\"><a href=\"#C-Code\" class=\"headerlink\" title=\"C++ Code\"></a>C++ Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NQueens</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> upperlim = (<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)&gt; dfs = [&amp;](<span class=\"keyword\">int</span> row,<span class=\"keyword\">int</span> ld,<span class=\"keyword\">int</span> rd) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(row == upperlim) &#123;++sum;<span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cur = upperlim &amp; (~(row|ld|rd)),pos = <span class=\"number\">0</span>;cur ;dfs(row|pos,(ld|pos)&lt;&lt;<span class=\"number\">1</span>,(rd|pos)&gt;&gt;<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            pos = cur &amp; (-cur);</span><br><span class=\"line\">            cur -= pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><h3 id=\"initialization\"><a href=\"#initialization\" class=\"headerlink\" title=\"initialization\"></a>initialization</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upperlim = (1 &lt;&lt; n) - 1, sum = 0;</span><br></pre></td></tr></table></figure>\n<p>Upperlim value is n-bit binary 1.</p>\n<h3 id=\"Recursive-Function\"><a href=\"#Recursive-Function\" class=\"headerlink\" title=\"Recursive Function\"></a>Recursive Function</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123;</span><br><span class=\"line\">    if(row == upperlim) &#123;++sum;return;&#125;</span><br><span class=\"line\">    for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123;</span><br><span class=\"line\">        pos = cur &amp; (-cur);</span><br><span class=\"line\">        cur -= pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>The function has three parameters:</p>\n<ul>\n<li>row : row</li>\n<li>ld : Left diagonal</li>\n<li>rd : Right diagonal</li>\n</ul>\n<p>Use these three parameters to determine whether a queen can be placed in a certain position.</p>\n<h3 id=\"Diagram\"><a href=\"#Diagram\" class=\"headerlink\" title=\"Diagram\"></a>Diagram</h3><p>Here is a step-by-step illustration of the Six Queens question.</p>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen1.jpg\" alt=\"Step #1\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 000001</span><br><span class=\"line\">ld  = 000010</span><br><span class=\"line\">rd  = 000000</span><br><span class=\"line\">cur = 111100</span><br><span class=\"line\">pos = 000100</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen2.jpg\" alt=\"Step #2\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 000101</span><br><span class=\"line\">ld  = 001100</span><br><span class=\"line\">rd  = 000010 </span><br><span class=\"line\">cur = 110000</span><br><span class=\"line\">pos = 010000</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen3.jpg\" alt=\"Step #3\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 010101</span><br><span class=\"line\">ld  = 111000</span><br><span class=\"line\">rd  = 001001 </span><br><span class=\"line\">cur = 000010</span><br><span class=\"line\">pos = 000010</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen4.jpg\" alt=\"Step #4\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 010111</span><br><span class=\"line\">ld  = 110100</span><br><span class=\"line\">rd  = 000101 </span><br><span class=\"line\">cur = 001000</span><br><span class=\"line\">pos = 001000</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen5.jpg\" alt=\"Step #5\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 011111</span><br><span class=\"line\">ld  = 111000</span><br><span class=\"line\">rd  = 000110</span><br><span class=\"line\">cur = 000000</span><br><span class=\"line\">pos = 000000</span><br></pre></td></tr></table></figure>\n<hr>\n<p>The first round of search is completed, there is a kind of thought is the depth first search, is to find a solution and then press forward to the enemy’s capital to find second solution, because the eight queens problem belongs to the scope of the graph, so the idea of graph theory can be found in this problem.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"N-Queens-Problem\"><a href=\"#N-Queens-Problem\" class=\"headerlink\" title=\"N-Queens Problem\"></a>N-Queens Problem</h1><h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>The eight queens problem is a question with chess as the background: how to place eight queens on an 8×8 chess board so that no queen can directly eat other queens? In order to achieve this purpose, any two queens are not in the same horizontal, vertical or diagonal. The eight queen problem can be extended to the more general N-Queens Problem.</p>\n<p>more information about n-queens problem please google it.</p>\n<h2 id=\"C-Code\"><a href=\"#C-Code\" class=\"headerlink\" title=\"C++ Code\"></a>C++ Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NQueens</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> upperlim = (<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)&gt; dfs = [&amp;](<span class=\"keyword\">int</span> row,<span class=\"keyword\">int</span> ld,<span class=\"keyword\">int</span> rd) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(row == upperlim) &#123;++sum;<span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cur = upperlim &amp; (~(row|ld|rd)),pos = <span class=\"number\">0</span>;cur ;dfs(row|pos,(ld|pos)&lt;&lt;<span class=\"number\">1</span>,(rd|pos)&gt;&gt;<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            pos = cur &amp; (-cur);</span><br><span class=\"line\">            cur -= pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><h3 id=\"initialization\"><a href=\"#initialization\" class=\"headerlink\" title=\"initialization\"></a>initialization</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upperlim = (1 &lt;&lt; n) - 1, sum = 0;</span><br></pre></td></tr></table></figure>\n<p>Upperlim value is n-bit binary 1.</p>\n<h3 id=\"Recursive-Function\"><a href=\"#Recursive-Function\" class=\"headerlink\" title=\"Recursive Function\"></a>Recursive Function</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123;</span><br><span class=\"line\">    if(row == upperlim) &#123;++sum;return;&#125;</span><br><span class=\"line\">    for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123;</span><br><span class=\"line\">        pos = cur &amp; (-cur);</span><br><span class=\"line\">        cur -= pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>The function has three parameters:</p>\n<ul>\n<li>row : row</li>\n<li>ld : Left diagonal</li>\n<li>rd : Right diagonal</li>\n</ul>\n<p>Use these three parameters to determine whether a queen can be placed in a certain position.</p>\n<h3 id=\"Diagram\"><a href=\"#Diagram\" class=\"headerlink\" title=\"Diagram\"></a>Diagram</h3><p>Here is a step-by-step illustration of the Six Queens question.</p>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen1.jpg\" alt=\"Step #1\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 000001</span><br><span class=\"line\">ld  = 000010</span><br><span class=\"line\">rd  = 000000</span><br><span class=\"line\">cur = 111100</span><br><span class=\"line\">pos = 000100</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen2.jpg\" alt=\"Step #2\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 000101</span><br><span class=\"line\">ld  = 001100</span><br><span class=\"line\">rd  = 000010 </span><br><span class=\"line\">cur = 110000</span><br><span class=\"line\">pos = 010000</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen3.jpg\" alt=\"Step #3\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 010101</span><br><span class=\"line\">ld  = 111000</span><br><span class=\"line\">rd  = 001001 </span><br><span class=\"line\">cur = 000010</span><br><span class=\"line\">pos = 000010</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen4.jpg\" alt=\"Step #4\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 010111</span><br><span class=\"line\">ld  = 110100</span><br><span class=\"line\">rd  = 000101 </span><br><span class=\"line\">cur = 001000</span><br><span class=\"line\">pos = 001000</span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"http://hucoco.com/img/EightQueen/EightQueen5.jpg\" alt=\"Step #5\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row = 011111</span><br><span class=\"line\">ld  = 111000</span><br><span class=\"line\">rd  = 000110</span><br><span class=\"line\">cur = 000000</span><br><span class=\"line\">pos = 000000</span><br></pre></td></tr></table></figure>\n<hr>\n<p>The first round of search is completed, there is a kind of thought is the depth first search, is to find a solution and then press forward to the enemy’s capital to find second solution, because the eight queens problem belongs to the scope of the graph, so the idea of graph theory can be found in this problem.</p>"},{"title":"Ray Tracing Catalogue","date":"2018-07-04T13:26:13.000Z","thumbnail":"http://hucoco.com/img/Graphics/RayTracing/RayTracing_0.png","_content":"\nThis is catalogue of Ray Tracing, I will update it if I have free time.(It's means I don't know what time I will finish one of them.)\n \n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_0.png)\n\n* [Theory of ray tracing](http://hucoco.com/2018/07/05/Theory-of-Ray-Tracing/)\n* [Ray and Scene](http://hucoco.com/2018/07/07/Ray-and-Camera/)\n* [Various surfaces](http://hucoco.com/2018/07/06/Various-surfaces/)\n* [Lighting and Materials](http://hucoco.com/2018/07/09/Lighting_and_Materials/)\n* [Do ray tracing](http://hucoco.com/2018/07/10/Do-Ray-Tracing/)\n\n**Coming soon...**\n\n* Ambient Occlusion\n* Blur","source":"_posts/Ray-Tracing-Catalogue.md","raw":"---\ntitle: Ray Tracing Catalogue\ndate: 2018-07-04 21:26:13\nthumbnail: http://hucoco.com/img/Graphics/RayTracing/RayTracing_0.png\ntags: \n- Graphics\n- Ray Tracing\ncategories:\n- Graphics\n- Ray Tracing\n---\n\nThis is catalogue of Ray Tracing, I will update it if I have free time.(It's means I don't know what time I will finish one of them.)\n \n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_0.png)\n\n* [Theory of ray tracing](http://hucoco.com/2018/07/05/Theory-of-Ray-Tracing/)\n* [Ray and Scene](http://hucoco.com/2018/07/07/Ray-and-Camera/)\n* [Various surfaces](http://hucoco.com/2018/07/06/Various-surfaces/)\n* [Lighting and Materials](http://hucoco.com/2018/07/09/Lighting_and_Materials/)\n* [Do ray tracing](http://hucoco.com/2018/07/10/Do-Ray-Tracing/)\n\n**Coming soon...**\n\n* Ambient Occlusion\n* Blur","slug":"Ray-Tracing-Catalogue","published":1,"updated":"2018-07-10T07:24:41.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36u1000issb9bss8z7u4","content":"<p>This is catalogue of Ray Tracing, I will update it if I have free time.(It’s means I don’t know what time I will finish one of them.)</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_0.png\" alt=\"\"></p>\n<ul>\n<li><a href=\"http://hucoco.com/2018/07/05/Theory-of-Ray-Tracing/\">Theory of ray tracing</a></li>\n<li><a href=\"http://hucoco.com/2018/07/07/Ray-and-Camera/\">Ray and Scene</a></li>\n<li><a href=\"http://hucoco.com/2018/07/06/Various-surfaces/\">Various surfaces</a></li>\n<li><a href=\"http://hucoco.com/2018/07/09/Lighting_and_Materials/\">Lighting and Materials</a></li>\n<li><a href=\"http://hucoco.com/2018/07/10/Do-Ray-Tracing/\">Do ray tracing</a></li>\n</ul>\n<p><strong>Coming soon…</strong></p>\n<ul>\n<li>Ambient Occlusion</li>\n<li>Blur</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>This is catalogue of Ray Tracing, I will update it if I have free time.(It’s means I don’t know what time I will finish one of them.)</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_0.png\" alt=\"\"></p>\n<ul>\n<li><a href=\"http://hucoco.com/2018/07/05/Theory-of-Ray-Tracing/\">Theory of ray tracing</a></li>\n<li><a href=\"http://hucoco.com/2018/07/07/Ray-and-Camera/\">Ray and Scene</a></li>\n<li><a href=\"http://hucoco.com/2018/07/06/Various-surfaces/\">Various surfaces</a></li>\n<li><a href=\"http://hucoco.com/2018/07/09/Lighting_and_Materials/\">Lighting and Materials</a></li>\n<li><a href=\"http://hucoco.com/2018/07/10/Do-Ray-Tracing/\">Do ray tracing</a></li>\n</ul>\n<p><strong>Coming soon…</strong></p>\n<ul>\n<li>Ambient Occlusion</li>\n<li>Blur</li>\n</ul>\n"},{"title":"Physically Based Rendering Catalogue","date":"2018-07-04T13:57:47.000Z","thumbnail":"http://hucoco.com/img/Graphics/PBR/PBR_0.png","_content":"This is catalogue of Physically Based Rendering, I will update it if I have free time.(It's means I don't know what time I will finish one of them.)\n \n![](http://hucoco.com/img/Graphics/PBR/PBR_0.png)\n\n* Theory of Physically Based Rendering\n* The Reflectance Equation\n* BRDF\n* Lighting\n* IBL","source":"_posts/Physically-Based-Rendering-Catalogue.md","raw":"---\ntitle: Physically Based Rendering Catalogue\ndate: 2018-07-04 21:57:47\nthumbnail: http://hucoco.com/img/Graphics/PBR/PBR_0.png\ntags: \n- Graphics\n- PBR\ncategories:\n- Graphics\n- PBR\n---\nThis is catalogue of Physically Based Rendering, I will update it if I have free time.(It's means I don't know what time I will finish one of them.)\n \n![](http://hucoco.com/img/Graphics/PBR/PBR_0.png)\n\n* Theory of Physically Based Rendering\n* The Reflectance Equation\n* BRDF\n* Lighting\n* IBL","slug":"Physically-Based-Rendering-Catalogue","published":1,"updated":"2018-07-11T14:11:54.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36u2000kssb9n1d3cgan","content":"<p>This is catalogue of Physically Based Rendering, I will update it if I have free time.(It’s means I don’t know what time I will finish one of them.)</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/PBR_0.png\" alt=\"\"></p>\n<ul>\n<li>Theory of Physically Based Rendering</li>\n<li>The Reflectance Equation</li>\n<li>BRDF</li>\n<li>Lighting</li>\n<li>IBL</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>This is catalogue of Physically Based Rendering, I will update it if I have free time.(It’s means I don’t know what time I will finish one of them.)</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/PBR_0.png\" alt=\"\"></p>\n<ul>\n<li>Theory of Physically Based Rendering</li>\n<li>The Reflectance Equation</li>\n<li>BRDF</li>\n<li>Lighting</li>\n<li>IBL</li>\n</ul>\n"},{"title":"Ray and Camera","date":"2018-07-07T08:08:16.000Z","thumbnail":"http://hucoco.com/img/Graphics/RayTracing/ray_00.png","mathjax":true,"_content":"\n## Ray\n\nFinding ray-object  intersection and computing  surface normal is central to ray tracing.\n\nRay representations:\n\n* Two 3D vectors\n\t* Ray origin position\n\t* Ray direction vector\n* Parametric form\n\t* $P(t) = origin + t \\times direction$\n\n![](http://hucoco.com/img/Graphics/RayTracing/ray_00.png)\n\n<!--more-->\n\n### Computing Reflection / Refraction Rays\n\n![](http://hucoco.com/img/Graphics/RayTracing/ray_01.png)\n\n#### Snell’s law\n\n$$\\mu_1sin\\theta = \\mu_2sin\\phi$$\n\n#### Reflection\n\n$$R = 2 (N \\cdot L) N - L$$\n\n#### Refraction\n\n$$\\mu = \\frac{\\mu_1}{\\mu_2}$$\n\n$$T = -\\mu L + (\\mu (N \\cdot L) - \\sqrt{1 - \\mu^2 (1 - (N \\cdot L)^2)})N$$\n\n### Recursive Ray Tracing\n\nFor each reflection/refraction ray spawned, we can trace it just like tracing the original ray.\n\n![](http://hucoco.com/img/Graphics/RayTracing/ray_02.png)\n\n#### When to stop recursion?\n\n* When the surface is totally diffuse (and opaque)\n* When reflected/refracted ray hits nothing\n* When maximum recursion depth is reached\n* When the contribution of the reflected/refracted ray to thecolor at the top level is too small\n\t* $(K_{rg1} | K_{tg1}) \\times \\cdots \\times (k_{rg(n-1)}|k_{tg(n-1)}) < threshold $\n\n## Camera\n\nCamera view & image resolution\n\n* Camera position and orientation in world coordinate frame\n\t* Similar to gluLookAt()\n* Field of view\n\t* Similar to gluPerspective(), but no need near & far plane\n* Image resolution\n\t* Number of pixels in each dimension\n\n```c++\nCamera &Camera::setCamera( \n\t\t\t    const Vector3d &eye, const Vector3d &lookAt, const Vector3d &upVector,\n\t\t        double left, double right, double bottom, double top, double near,\n\t\t\t    int image_width, int image_height )\n{\n\tassert( image_width > 0 && image_height > 0 );\n\tmImageWidth = image_width;\n\tmImageHeight = image_height;\n\n\tmCOP = eye;\n\tVector3d cop_n = (eye - lookAt).unitVector();\n\tVector3d cop_u = cross( upVector.unitVector(), cop_n );\n\tVector3d cop_v = cross( cop_n, cop_u );\n\n\tmImageOrigin = mCOP + ( left * cop_u ) + ( bottom * cop_v ) + ( -near * cop_n );\n\n\tmImageU = (right - left) * cop_u;\n\tmImageV = (top - bottom) * cop_v;\n\treturn (*this);\n}\n\nRay getRay( double pixelPosX, double pixelPosY ) const\n{\n\tVector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV;\n\treturn Ray( mCOP, imgPos - mCOP );\n}\n\n```\n\n## Reference\n\n**[Learn OpenGL](https://learnopengl.com/) **","source":"_posts/Ray-and-Camera.md","raw":"---\ntitle: Ray and Camera \ndate: 2018-07-07 16:08:16\nthumbnail: http://hucoco.com/img/Graphics/RayTracing/ray_00.png\nmathjax: true\ntags: \n- Graphics\n- Ray Tracing\ncategories:\n- Graphics\n- Ray Tracing\n---\n\n## Ray\n\nFinding ray-object  intersection and computing  surface normal is central to ray tracing.\n\nRay representations:\n\n* Two 3D vectors\n\t* Ray origin position\n\t* Ray direction vector\n* Parametric form\n\t* $P(t) = origin + t \\times direction$\n\n![](http://hucoco.com/img/Graphics/RayTracing/ray_00.png)\n\n<!--more-->\n\n### Computing Reflection / Refraction Rays\n\n![](http://hucoco.com/img/Graphics/RayTracing/ray_01.png)\n\n#### Snell’s law\n\n$$\\mu_1sin\\theta = \\mu_2sin\\phi$$\n\n#### Reflection\n\n$$R = 2 (N \\cdot L) N - L$$\n\n#### Refraction\n\n$$\\mu = \\frac{\\mu_1}{\\mu_2}$$\n\n$$T = -\\mu L + (\\mu (N \\cdot L) - \\sqrt{1 - \\mu^2 (1 - (N \\cdot L)^2)})N$$\n\n### Recursive Ray Tracing\n\nFor each reflection/refraction ray spawned, we can trace it just like tracing the original ray.\n\n![](http://hucoco.com/img/Graphics/RayTracing/ray_02.png)\n\n#### When to stop recursion?\n\n* When the surface is totally diffuse (and opaque)\n* When reflected/refracted ray hits nothing\n* When maximum recursion depth is reached\n* When the contribution of the reflected/refracted ray to thecolor at the top level is too small\n\t* $(K_{rg1} | K_{tg1}) \\times \\cdots \\times (k_{rg(n-1)}|k_{tg(n-1)}) < threshold $\n\n## Camera\n\nCamera view & image resolution\n\n* Camera position and orientation in world coordinate frame\n\t* Similar to gluLookAt()\n* Field of view\n\t* Similar to gluPerspective(), but no need near & far plane\n* Image resolution\n\t* Number of pixels in each dimension\n\n```c++\nCamera &Camera::setCamera( \n\t\t\t    const Vector3d &eye, const Vector3d &lookAt, const Vector3d &upVector,\n\t\t        double left, double right, double bottom, double top, double near,\n\t\t\t    int image_width, int image_height )\n{\n\tassert( image_width > 0 && image_height > 0 );\n\tmImageWidth = image_width;\n\tmImageHeight = image_height;\n\n\tmCOP = eye;\n\tVector3d cop_n = (eye - lookAt).unitVector();\n\tVector3d cop_u = cross( upVector.unitVector(), cop_n );\n\tVector3d cop_v = cross( cop_n, cop_u );\n\n\tmImageOrigin = mCOP + ( left * cop_u ) + ( bottom * cop_v ) + ( -near * cop_n );\n\n\tmImageU = (right - left) * cop_u;\n\tmImageV = (top - bottom) * cop_v;\n\treturn (*this);\n}\n\nRay getRay( double pixelPosX, double pixelPosY ) const\n{\n\tVector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV;\n\treturn Ray( mCOP, imgPos - mCOP );\n}\n\n```\n\n## Reference\n\n**[Learn OpenGL](https://learnopengl.com/) **","slug":"Ray-and-Camera","published":1,"updated":"2018-07-10T07:28:33.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36u4000ossb9scg34cru","content":"<h2 id=\"Ray\"><a href=\"#Ray\" class=\"headerlink\" title=\"Ray\"></a>Ray</h2><p>Finding ray-object  intersection and computing  surface normal is central to ray tracing.</p>\n<p>Ray representations:</p>\n<ul>\n<li>Two 3D vectors<ul>\n<li>Ray origin position</li>\n<li>Ray direction vector</li>\n</ul>\n</li>\n<li>Parametric form<ul>\n<li>$P(t) = origin + t \\times direction$</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/ray_00.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"Computing-Reflection-Refraction-Rays\"><a href=\"#Computing-Reflection-Refraction-Rays\" class=\"headerlink\" title=\"Computing Reflection / Refraction Rays\"></a>Computing Reflection / Refraction Rays</h3><p><img src=\"http://hucoco.com/img/Graphics/RayTracing/ray_01.png\" alt=\"\"></p>\n<h4 id=\"Snell’s-law\"><a href=\"#Snell’s-law\" class=\"headerlink\" title=\"Snell’s law\"></a>Snell’s law</h4><script type=\"math/tex; mode=display\">\\mu_1sin\\theta = \\mu_2sin\\phi</script><h4 id=\"Reflection\"><a href=\"#Reflection\" class=\"headerlink\" title=\"Reflection\"></a>Reflection</h4><script type=\"math/tex; mode=display\">R = 2 (N \\cdot L) N - L</script><h4 id=\"Refraction\"><a href=\"#Refraction\" class=\"headerlink\" title=\"Refraction\"></a>Refraction</h4><script type=\"math/tex; mode=display\">\\mu = \\frac{\\mu_1}{\\mu_2}</script><script type=\"math/tex; mode=display\">T = -\\mu L + (\\mu (N \\cdot L) - \\sqrt{1 - \\mu^2 (1 - (N \\cdot L)^2)})N</script><h3 id=\"Recursive-Ray-Tracing\"><a href=\"#Recursive-Ray-Tracing\" class=\"headerlink\" title=\"Recursive Ray Tracing\"></a>Recursive Ray Tracing</h3><p>For each reflection/refraction ray spawned, we can trace it just like tracing the original ray.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/ray_02.png\" alt=\"\"></p>\n<h4 id=\"When-to-stop-recursion\"><a href=\"#When-to-stop-recursion\" class=\"headerlink\" title=\"When to stop recursion?\"></a>When to stop recursion?</h4><ul>\n<li>When the surface is totally diffuse (and opaque)</li>\n<li>When reflected/refracted ray hits nothing</li>\n<li>When maximum recursion depth is reached</li>\n<li>When the contribution of the reflected/refracted ray to thecolor at the top level is too small<ul>\n<li>$(K_{rg1} | K_{tg1}) \\times \\cdots \\times (k_{rg(n-1)}|k_{tg(n-1)}) &lt; threshold $</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Camera\"><a href=\"#Camera\" class=\"headerlink\" title=\"Camera\"></a>Camera</h2><p>Camera view &amp; image resolution</p>\n<ul>\n<li>Camera position and orientation in world coordinate frame<ul>\n<li>Similar to gluLookAt()</li>\n</ul>\n</li>\n<li>Field of view<ul>\n<li>Similar to gluPerspective(), but no need near &amp; far plane</li>\n</ul>\n</li>\n<li>Image resolution<ul>\n<li>Number of pixels in each dimension</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Camera &amp;Camera::setCamera( </span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">const</span> Vector3d &amp;eye, <span class=\"keyword\">const</span> Vector3d &amp;lookAt, <span class=\"keyword\">const</span> Vector3d &amp;upVector,</span><br><span class=\"line\">\t\t        <span class=\"keyword\">double</span> left, <span class=\"keyword\">double</span> right, <span class=\"keyword\">double</span> bottom, <span class=\"keyword\">double</span> top, <span class=\"keyword\">double</span> near,</span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">int</span> image_width, <span class=\"keyword\">int</span> image_height )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tassert( image_width &gt; <span class=\"number\">0</span> &amp;&amp; image_height &gt; <span class=\"number\">0</span> );</span><br><span class=\"line\">\tmImageWidth = image_width;</span><br><span class=\"line\">\tmImageHeight = image_height;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmCOP = eye;</span><br><span class=\"line\">\tVector3d cop_n = (eye - lookAt).unitVector();</span><br><span class=\"line\">\tVector3d cop_u = cross( upVector.unitVector(), cop_n );</span><br><span class=\"line\">\tVector3d cop_v = cross( cop_n, cop_u );</span><br><span class=\"line\"></span><br><span class=\"line\">\tmImageOrigin = mCOP + ( left * cop_u ) + ( bottom * cop_v ) + ( -near * cop_n );</span><br><span class=\"line\"></span><br><span class=\"line\">\tmImageU = (right - left) * cop_u;</span><br><span class=\"line\">\tmImageV = (top - bottom) * cop_v;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ray <span class=\"title\">getRay</span><span class=\"params\">( <span class=\"keyword\">double</span> pixelPosX, <span class=\"keyword\">double</span> pixelPosY )</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tVector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Ray( mCOP, imgPos - mCOP );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Ray\"><a href=\"#Ray\" class=\"headerlink\" title=\"Ray\"></a>Ray</h2><p>Finding ray-object  intersection and computing  surface normal is central to ray tracing.</p>\n<p>Ray representations:</p>\n<ul>\n<li>Two 3D vectors<ul>\n<li>Ray origin position</li>\n<li>Ray direction vector</li>\n</ul>\n</li>\n<li>Parametric form<ul>\n<li>$P(t) = origin + t \\times direction$</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/ray_00.png\" alt=\"\"></p>","more":"<h3 id=\"Computing-Reflection-Refraction-Rays\"><a href=\"#Computing-Reflection-Refraction-Rays\" class=\"headerlink\" title=\"Computing Reflection / Refraction Rays\"></a>Computing Reflection / Refraction Rays</h3><p><img src=\"http://hucoco.com/img/Graphics/RayTracing/ray_01.png\" alt=\"\"></p>\n<h4 id=\"Snell’s-law\"><a href=\"#Snell’s-law\" class=\"headerlink\" title=\"Snell’s law\"></a>Snell’s law</h4><script type=\"math/tex; mode=display\">\\mu_1sin\\theta = \\mu_2sin\\phi</script><h4 id=\"Reflection\"><a href=\"#Reflection\" class=\"headerlink\" title=\"Reflection\"></a>Reflection</h4><script type=\"math/tex; mode=display\">R = 2 (N \\cdot L) N - L</script><h4 id=\"Refraction\"><a href=\"#Refraction\" class=\"headerlink\" title=\"Refraction\"></a>Refraction</h4><script type=\"math/tex; mode=display\">\\mu = \\frac{\\mu_1}{\\mu_2}</script><script type=\"math/tex; mode=display\">T = -\\mu L + (\\mu (N \\cdot L) - \\sqrt{1 - \\mu^2 (1 - (N \\cdot L)^2)})N</script><h3 id=\"Recursive-Ray-Tracing\"><a href=\"#Recursive-Ray-Tracing\" class=\"headerlink\" title=\"Recursive Ray Tracing\"></a>Recursive Ray Tracing</h3><p>For each reflection/refraction ray spawned, we can trace it just like tracing the original ray.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/ray_02.png\" alt=\"\"></p>\n<h4 id=\"When-to-stop-recursion\"><a href=\"#When-to-stop-recursion\" class=\"headerlink\" title=\"When to stop recursion?\"></a>When to stop recursion?</h4><ul>\n<li>When the surface is totally diffuse (and opaque)</li>\n<li>When reflected/refracted ray hits nothing</li>\n<li>When maximum recursion depth is reached</li>\n<li>When the contribution of the reflected/refracted ray to thecolor at the top level is too small<ul>\n<li>$(K_{rg1} | K_{tg1}) \\times \\cdots \\times (k_{rg(n-1)}|k_{tg(n-1)}) &lt; threshold $</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Camera\"><a href=\"#Camera\" class=\"headerlink\" title=\"Camera\"></a>Camera</h2><p>Camera view &amp; image resolution</p>\n<ul>\n<li>Camera position and orientation in world coordinate frame<ul>\n<li>Similar to gluLookAt()</li>\n</ul>\n</li>\n<li>Field of view<ul>\n<li>Similar to gluPerspective(), but no need near &amp; far plane</li>\n</ul>\n</li>\n<li>Image resolution<ul>\n<li>Number of pixels in each dimension</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Camera &amp;Camera::setCamera( </span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">const</span> Vector3d &amp;eye, <span class=\"keyword\">const</span> Vector3d &amp;lookAt, <span class=\"keyword\">const</span> Vector3d &amp;upVector,</span><br><span class=\"line\">\t\t        <span class=\"keyword\">double</span> left, <span class=\"keyword\">double</span> right, <span class=\"keyword\">double</span> bottom, <span class=\"keyword\">double</span> top, <span class=\"keyword\">double</span> near,</span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">int</span> image_width, <span class=\"keyword\">int</span> image_height )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tassert( image_width &gt; <span class=\"number\">0</span> &amp;&amp; image_height &gt; <span class=\"number\">0</span> );</span><br><span class=\"line\">\tmImageWidth = image_width;</span><br><span class=\"line\">\tmImageHeight = image_height;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmCOP = eye;</span><br><span class=\"line\">\tVector3d cop_n = (eye - lookAt).unitVector();</span><br><span class=\"line\">\tVector3d cop_u = cross( upVector.unitVector(), cop_n );</span><br><span class=\"line\">\tVector3d cop_v = cross( cop_n, cop_u );</span><br><span class=\"line\"></span><br><span class=\"line\">\tmImageOrigin = mCOP + ( left * cop_u ) + ( bottom * cop_v ) + ( -near * cop_n );</span><br><span class=\"line\"></span><br><span class=\"line\">\tmImageU = (right - left) * cop_u;</span><br><span class=\"line\">\tmImageV = (top - bottom) * cop_v;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ray <span class=\"title\">getRay</span><span class=\"params\">( <span class=\"keyword\">double</span> pixelPosX, <span class=\"keyword\">double</span> pixelPosY )</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tVector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Ray( mCOP, imgPos - mCOP );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>"},{"title":"RedBlackTree I","date":"2018-03-02T15:38:12.000Z","thumbnail":"http://hucoco.com/img/RedBlackTree/rbtree.png","_content":"\n[RedBlackTree I Chinese version address](http://hucoco.coding.me/2016/11/08/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91/)\n\n## Binary Tree Review\n\nThere are several features of binary tree:\n\n1.  if the left subtree of any nodes is not null, the value of all nodes on the left subtree is less than the value of its root node.\n2.  if the right subtree of any nodes is not null, the value of all nodes on the right subtree is greater than the value of its root node.\n3.  the left and right subtrees of any node are also binary tree.\n4.  No nodes with equal values\n\n## Red Black Tree Overview\n\nRed Black Tree is a special binary tree. each node of a red black tree has a bit to represenet the color, which can be red or black.\n\n<!--more-->\n\n### Red Black Tree Features\n\n1. the color of each node is red or black.\n2. the color of root node is black.\n3. the color of each leaf node is black.\n4. if a node is red, the subnode of it must be black.\n5. The same number of black nodes is included on all paths from a node to the node's descendant node.\n\n![RedBlackTree](http://hucoco.com/img/RedBlackTree/rbtree.png)\n\n#### Notes:\n\n1. leaf node is means which node is null.\n2. Feature 5 to ensure that no path is twice as long as the other path. Thus, the red black tree is a relatively balanced binary tree.\n\n## Application of red black trees\n\nThe application of the red-black tree is particularly extensive, mainly because it uses it to store ordered data. Its time complexity is O (lgn), which is very efficient.\n\nBut its implementation is complicated, and insert, delete operation will pay more cost.\n\n* Set and Map in STL\n* TreeSet and TreeMap in Java\n* Virtual memory management in Linux\n\n## Basic operation of red black trees \n\n### Left Rotation\n\n```\n                              z\n  x                          /                  \n / \\      --(左旋)-->        x\ny   z                      /\n                          y\n```\n\nMake left rotation on x node, and it will be a left node.\n\n![Left Rotate](http://hucoco.com/img/RedBlackTree/leftrotate.jpg)\n\n#### Pseudo code\n\n```\nLEFT-ROTATE(T, x)  \n y ← right[x]            \n right[x] ← left[y]      \n p[left[y]] ← x         \n p[y] ← p[x]             \n if p[x] = nil[T]       \n then root[T] ← y                 \n else if x = left[p[x]]  \n           then left[p[x]] ← y   \n           else right[p[x]] ← y  \n left[y] ← x             \n p[x] ← y\n```\n\n#### C++ Code\n\n```\ntemplate <class T>\nvoid RedBlackTree<T>::leftRotate(RedBlackNode<T> *&root, RedBlackNode<T> *x) {\n\n\tRedBlackNode<T> *y = x->pRight;     \n\n\tx->pRight = y->pLeft;                    \n\tif(y->pLeft != nullptr) {\n\t\ty->pLeft->pParent = x;        \n\t}\n\n\ty->pParent = x->pParent;         \n\n\tif(x->pParent == nullptr) {      \n\t\troot = y;                      \n\t}\n\telse {\n\t\tif(x->pParent->pLeft == x) {    \n\t\t\tx->pParent->pLeft = y;      \n\t\t}\n\t\telse {\n\t\t\tx->pParent->pRight = y; \n\t\t}\n\t}\n\ty->pLeft = x;                   \n\tx->pParent = y;                    \n}                                                                                                            \n```\n\n### Right Rotation\n\n```\n                             y\n  x                           \\                 \n / \\      --(右旋)-->           x\ny   z                            \\\n                                  z\n```\n\nMake right rotation on x node, and it will be a right node.\n\n![](http://hucoco.com/img/RedBlackTree/rightrotate.jpg)\n\n#### Pseudo code\n\n```\nRIGHT-ROTATE(T, y)  \n x ← left[y]             \n left[y] ← right[x]      \n p[right[x]] ← y         \n p[x] ← p[y]             \n if p[y] = nil[T]       \n then root[T] ← x               \n else if y = right[p[y]]  \n           then right[p[y]] ← x   \n           else left[p[y]] ← x   \n right[x] ← y            \n p[y] ← x\n```\n\n#### C++ Code\n\n```\ntemplate <class T>\nvoid RedBlackTree<T>::rightRotate(RedBlackNode<T> *&root, RedBlackNode<T> *y) {\n\n\tRedBlackNode<T> *x = y->pLeft;    \n\n\ty->pLeft = x->pRight;              \n\tif(x->pRight != nullptr) {\n\t\tx->pRight->pParent = y;     \n\t}\n\n\tx->pParent = y->pParent;           \n\n\tif(y->pParent == nullptr) {        \n\t\troot = x;                       \n\t}\n\telse {\n\t\tif(y->pParent->pRight == y) {   \n\t\t\ty->pParent->pRight = x;     \n\t\t}\n\t\telse {\n\t\t\ty->pParent->pLeft = x;   \n\t\t}\n\t}\n\n\tx->pRight = y;       \n\ty->pParent = x;  \n}\n```\n\n[The Next Section](http://hucoco.com/2018/03/02/RedBlackTree-II/)","source":"_posts/RedBlackTree-I.md","raw":"---\ntitle: RedBlackTree I\ndate: 2018-03-02 23:38:12\nthumbnail: http://hucoco.com/img/RedBlackTree/rbtree.png\ntags: \n- C++\n- Data Structure\n- Tree\ncategories:\n- Data Structure\n- Tree\n---\n\n[RedBlackTree I Chinese version address](http://hucoco.coding.me/2016/11/08/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91/)\n\n## Binary Tree Review\n\nThere are several features of binary tree:\n\n1.  if the left subtree of any nodes is not null, the value of all nodes on the left subtree is less than the value of its root node.\n2.  if the right subtree of any nodes is not null, the value of all nodes on the right subtree is greater than the value of its root node.\n3.  the left and right subtrees of any node are also binary tree.\n4.  No nodes with equal values\n\n## Red Black Tree Overview\n\nRed Black Tree is a special binary tree. each node of a red black tree has a bit to represenet the color, which can be red or black.\n\n<!--more-->\n\n### Red Black Tree Features\n\n1. the color of each node is red or black.\n2. the color of root node is black.\n3. the color of each leaf node is black.\n4. if a node is red, the subnode of it must be black.\n5. The same number of black nodes is included on all paths from a node to the node's descendant node.\n\n![RedBlackTree](http://hucoco.com/img/RedBlackTree/rbtree.png)\n\n#### Notes:\n\n1. leaf node is means which node is null.\n2. Feature 5 to ensure that no path is twice as long as the other path. Thus, the red black tree is a relatively balanced binary tree.\n\n## Application of red black trees\n\nThe application of the red-black tree is particularly extensive, mainly because it uses it to store ordered data. Its time complexity is O (lgn), which is very efficient.\n\nBut its implementation is complicated, and insert, delete operation will pay more cost.\n\n* Set and Map in STL\n* TreeSet and TreeMap in Java\n* Virtual memory management in Linux\n\n## Basic operation of red black trees \n\n### Left Rotation\n\n```\n                              z\n  x                          /                  \n / \\      --(左旋)-->        x\ny   z                      /\n                          y\n```\n\nMake left rotation on x node, and it will be a left node.\n\n![Left Rotate](http://hucoco.com/img/RedBlackTree/leftrotate.jpg)\n\n#### Pseudo code\n\n```\nLEFT-ROTATE(T, x)  \n y ← right[x]            \n right[x] ← left[y]      \n p[left[y]] ← x         \n p[y] ← p[x]             \n if p[x] = nil[T]       \n then root[T] ← y                 \n else if x = left[p[x]]  \n           then left[p[x]] ← y   \n           else right[p[x]] ← y  \n left[y] ← x             \n p[x] ← y\n```\n\n#### C++ Code\n\n```\ntemplate <class T>\nvoid RedBlackTree<T>::leftRotate(RedBlackNode<T> *&root, RedBlackNode<T> *x) {\n\n\tRedBlackNode<T> *y = x->pRight;     \n\n\tx->pRight = y->pLeft;                    \n\tif(y->pLeft != nullptr) {\n\t\ty->pLeft->pParent = x;        \n\t}\n\n\ty->pParent = x->pParent;         \n\n\tif(x->pParent == nullptr) {      \n\t\troot = y;                      \n\t}\n\telse {\n\t\tif(x->pParent->pLeft == x) {    \n\t\t\tx->pParent->pLeft = y;      \n\t\t}\n\t\telse {\n\t\t\tx->pParent->pRight = y; \n\t\t}\n\t}\n\ty->pLeft = x;                   \n\tx->pParent = y;                    \n}                                                                                                            \n```\n\n### Right Rotation\n\n```\n                             y\n  x                           \\                 \n / \\      --(右旋)-->           x\ny   z                            \\\n                                  z\n```\n\nMake right rotation on x node, and it will be a right node.\n\n![](http://hucoco.com/img/RedBlackTree/rightrotate.jpg)\n\n#### Pseudo code\n\n```\nRIGHT-ROTATE(T, y)  \n x ← left[y]             \n left[y] ← right[x]      \n p[right[x]] ← y         \n p[x] ← p[y]             \n if p[y] = nil[T]       \n then root[T] ← x               \n else if y = right[p[y]]  \n           then right[p[y]] ← x   \n           else left[p[y]] ← x   \n right[x] ← y            \n p[y] ← x\n```\n\n#### C++ Code\n\n```\ntemplate <class T>\nvoid RedBlackTree<T>::rightRotate(RedBlackNode<T> *&root, RedBlackNode<T> *y) {\n\n\tRedBlackNode<T> *x = y->pLeft;    \n\n\ty->pLeft = x->pRight;              \n\tif(x->pRight != nullptr) {\n\t\tx->pRight->pParent = y;     \n\t}\n\n\tx->pParent = y->pParent;           \n\n\tif(y->pParent == nullptr) {        \n\t\troot = x;                       \n\t}\n\telse {\n\t\tif(y->pParent->pRight == y) {   \n\t\t\ty->pParent->pRight = x;     \n\t\t}\n\t\telse {\n\t\t\ty->pParent->pLeft = x;   \n\t\t}\n\t}\n\n\tx->pRight = y;       \n\ty->pParent = x;  \n}\n```\n\n[The Next Section](http://hucoco.com/2018/03/02/RedBlackTree-II/)","slug":"RedBlackTree-I","published":1,"updated":"2018-03-03T14:23:47.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36u5000qssb9yf5eceol","content":"<p><a href=\"http://hucoco.coding.me/2016/11/08/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91/\" target=\"_blank\" rel=\"noopener\">RedBlackTree I Chinese version address</a></p>\n<h2 id=\"Binary-Tree-Review\"><a href=\"#Binary-Tree-Review\" class=\"headerlink\" title=\"Binary Tree Review\"></a>Binary Tree Review</h2><p>There are several features of binary tree:</p>\n<ol>\n<li>if the left subtree of any nodes is not null, the value of all nodes on the left subtree is less than the value of its root node.</li>\n<li>if the right subtree of any nodes is not null, the value of all nodes on the right subtree is greater than the value of its root node.</li>\n<li>the left and right subtrees of any node are also binary tree.</li>\n<li>No nodes with equal values</li>\n</ol>\n<h2 id=\"Red-Black-Tree-Overview\"><a href=\"#Red-Black-Tree-Overview\" class=\"headerlink\" title=\"Red Black Tree Overview\"></a>Red Black Tree Overview</h2><p>Red Black Tree is a special binary tree. each node of a red black tree has a bit to represenet the color, which can be red or black.</p>\n<a id=\"more\"></a>\n<h3 id=\"Red-Black-Tree-Features\"><a href=\"#Red-Black-Tree-Features\" class=\"headerlink\" title=\"Red Black Tree Features\"></a>Red Black Tree Features</h3><ol>\n<li>the color of each node is red or black.</li>\n<li>the color of root node is black.</li>\n<li>the color of each leaf node is black.</li>\n<li>if a node is red, the subnode of it must be black.</li>\n<li>The same number of black nodes is included on all paths from a node to the node’s descendant node.</li>\n</ol>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/rbtree.png\" alt=\"RedBlackTree\"></p>\n<h4 id=\"Notes\"><a href=\"#Notes\" class=\"headerlink\" title=\"Notes:\"></a>Notes:</h4><ol>\n<li>leaf node is means which node is null.</li>\n<li>Feature 5 to ensure that no path is twice as long as the other path. Thus, the red black tree is a relatively balanced binary tree.</li>\n</ol>\n<h2 id=\"Application-of-red-black-trees\"><a href=\"#Application-of-red-black-trees\" class=\"headerlink\" title=\"Application of red black trees\"></a>Application of red black trees</h2><p>The application of the red-black tree is particularly extensive, mainly because it uses it to store ordered data. Its time complexity is O (lgn), which is very efficient.</p>\n<p>But its implementation is complicated, and insert, delete operation will pay more cost.</p>\n<ul>\n<li>Set and Map in STL</li>\n<li>TreeSet and TreeMap in Java</li>\n<li>Virtual memory management in Linux</li>\n</ul>\n<h2 id=\"Basic-operation-of-red-black-trees\"><a href=\"#Basic-operation-of-red-black-trees\" class=\"headerlink\" title=\"Basic operation of red black trees\"></a>Basic operation of red black trees</h2><h3 id=\"Left-Rotation\"><a href=\"#Left-Rotation\" class=\"headerlink\" title=\"Left Rotation\"></a>Left Rotation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                              z</span><br><span class=\"line\">  x                          /                  </span><br><span class=\"line\"> / \\      --(左旋)--&gt;        x</span><br><span class=\"line\">y   z                      /</span><br><span class=\"line\">                          y</span><br></pre></td></tr></table></figure>\n<p>Make left rotation on x node, and it will be a left node.</p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/leftrotate.jpg\" alt=\"Left Rotate\"></p>\n<h4 id=\"Pseudo-code\"><a href=\"#Pseudo-code\" class=\"headerlink\" title=\"Pseudo code\"></a>Pseudo code</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LEFT-ROTATE(T, x)  </span><br><span class=\"line\"> y ← right[x]            </span><br><span class=\"line\"> right[x] ← left[y]      </span><br><span class=\"line\"> p[left[y]] ← x         </span><br><span class=\"line\"> p[y] ← p[x]             </span><br><span class=\"line\"> if p[x] = nil[T]       </span><br><span class=\"line\"> then root[T] ← y                 </span><br><span class=\"line\"> else if x = left[p[x]]  </span><br><span class=\"line\">           then left[p[x]] ← y   </span><br><span class=\"line\">           else right[p[x]] ← y  </span><br><span class=\"line\"> left[y] ← x             </span><br><span class=\"line\"> p[x] ← y</span><br></pre></td></tr></table></figure>\n<h4 id=\"C-Code\"><a href=\"#C-Code\" class=\"headerlink\" title=\"C++ Code\"></a>C++ Code</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void RedBlackTree&lt;T&gt;::leftRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *x) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRedBlackNode&lt;T&gt; *y = x-&gt;pRight;     </span><br><span class=\"line\"></span><br><span class=\"line\">\tx-&gt;pRight = y-&gt;pLeft;                    </span><br><span class=\"line\">\tif(y-&gt;pLeft != nullptr) &#123;</span><br><span class=\"line\">\t\ty-&gt;pLeft-&gt;pParent = x;        </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ty-&gt;pParent = x-&gt;pParent;         </span><br><span class=\"line\"></span><br><span class=\"line\">\tif(x-&gt;pParent == nullptr) &#123;      </span><br><span class=\"line\">\t\troot = y;                      </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse &#123;</span><br><span class=\"line\">\t\tif(x-&gt;pParent-&gt;pLeft == x) &#123;    </span><br><span class=\"line\">\t\t\tx-&gt;pParent-&gt;pLeft = y;      </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\tx-&gt;pParent-&gt;pRight = y; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ty-&gt;pLeft = x;                   </span><br><span class=\"line\">\tx-&gt;pParent = y;                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Right-Rotation\"><a href=\"#Right-Rotation\" class=\"headerlink\" title=\"Right Rotation\"></a>Right Rotation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                             y</span><br><span class=\"line\">  x                           \\                 </span><br><span class=\"line\"> / \\      --(右旋)--&gt;           x</span><br><span class=\"line\">y   z                            \\</span><br><span class=\"line\">                                  z</span><br></pre></td></tr></table></figure>\n<p>Make right rotation on x node, and it will be a right node.</p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/rightrotate.jpg\" alt=\"\"></p>\n<h4 id=\"Pseudo-code-1\"><a href=\"#Pseudo-code-1\" class=\"headerlink\" title=\"Pseudo code\"></a>Pseudo code</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RIGHT-ROTATE(T, y)  </span><br><span class=\"line\"> x ← left[y]             </span><br><span class=\"line\"> left[y] ← right[x]      </span><br><span class=\"line\"> p[right[x]] ← y         </span><br><span class=\"line\"> p[x] ← p[y]             </span><br><span class=\"line\"> if p[y] = nil[T]       </span><br><span class=\"line\"> then root[T] ← x               </span><br><span class=\"line\"> else if y = right[p[y]]  </span><br><span class=\"line\">           then right[p[y]] ← x   </span><br><span class=\"line\">           else left[p[y]] ← x   </span><br><span class=\"line\"> right[x] ← y            </span><br><span class=\"line\"> p[y] ← x</span><br></pre></td></tr></table></figure>\n<h4 id=\"C-Code-1\"><a href=\"#C-Code-1\" class=\"headerlink\" title=\"C++ Code\"></a>C++ Code</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void RedBlackTree&lt;T&gt;::rightRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *y) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRedBlackNode&lt;T&gt; *x = y-&gt;pLeft;    </span><br><span class=\"line\"></span><br><span class=\"line\">\ty-&gt;pLeft = x-&gt;pRight;              </span><br><span class=\"line\">\tif(x-&gt;pRight != nullptr) &#123;</span><br><span class=\"line\">\t\tx-&gt;pRight-&gt;pParent = y;     </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx-&gt;pParent = y-&gt;pParent;           </span><br><span class=\"line\"></span><br><span class=\"line\">\tif(y-&gt;pParent == nullptr) &#123;        </span><br><span class=\"line\">\t\troot = x;                       </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse &#123;</span><br><span class=\"line\">\t\tif(y-&gt;pParent-&gt;pRight == y) &#123;   </span><br><span class=\"line\">\t\t\ty-&gt;pParent-&gt;pRight = x;     </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\ty-&gt;pParent-&gt;pLeft = x;   </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx-&gt;pRight = y;       </span><br><span class=\"line\">\ty-&gt;pParent = x;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://hucoco.com/2018/03/02/RedBlackTree-II/\">The Next Section</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/08/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91/\" target=\"_blank\" rel=\"noopener\">RedBlackTree I Chinese version address</a></p>\n<h2 id=\"Binary-Tree-Review\"><a href=\"#Binary-Tree-Review\" class=\"headerlink\" title=\"Binary Tree Review\"></a>Binary Tree Review</h2><p>There are several features of binary tree:</p>\n<ol>\n<li>if the left subtree of any nodes is not null, the value of all nodes on the left subtree is less than the value of its root node.</li>\n<li>if the right subtree of any nodes is not null, the value of all nodes on the right subtree is greater than the value of its root node.</li>\n<li>the left and right subtrees of any node are also binary tree.</li>\n<li>No nodes with equal values</li>\n</ol>\n<h2 id=\"Red-Black-Tree-Overview\"><a href=\"#Red-Black-Tree-Overview\" class=\"headerlink\" title=\"Red Black Tree Overview\"></a>Red Black Tree Overview</h2><p>Red Black Tree is a special binary tree. each node of a red black tree has a bit to represenet the color, which can be red or black.</p>","more":"<h3 id=\"Red-Black-Tree-Features\"><a href=\"#Red-Black-Tree-Features\" class=\"headerlink\" title=\"Red Black Tree Features\"></a>Red Black Tree Features</h3><ol>\n<li>the color of each node is red or black.</li>\n<li>the color of root node is black.</li>\n<li>the color of each leaf node is black.</li>\n<li>if a node is red, the subnode of it must be black.</li>\n<li>The same number of black nodes is included on all paths from a node to the node’s descendant node.</li>\n</ol>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/rbtree.png\" alt=\"RedBlackTree\"></p>\n<h4 id=\"Notes\"><a href=\"#Notes\" class=\"headerlink\" title=\"Notes:\"></a>Notes:</h4><ol>\n<li>leaf node is means which node is null.</li>\n<li>Feature 5 to ensure that no path is twice as long as the other path. Thus, the red black tree is a relatively balanced binary tree.</li>\n</ol>\n<h2 id=\"Application-of-red-black-trees\"><a href=\"#Application-of-red-black-trees\" class=\"headerlink\" title=\"Application of red black trees\"></a>Application of red black trees</h2><p>The application of the red-black tree is particularly extensive, mainly because it uses it to store ordered data. Its time complexity is O (lgn), which is very efficient.</p>\n<p>But its implementation is complicated, and insert, delete operation will pay more cost.</p>\n<ul>\n<li>Set and Map in STL</li>\n<li>TreeSet and TreeMap in Java</li>\n<li>Virtual memory management in Linux</li>\n</ul>\n<h2 id=\"Basic-operation-of-red-black-trees\"><a href=\"#Basic-operation-of-red-black-trees\" class=\"headerlink\" title=\"Basic operation of red black trees\"></a>Basic operation of red black trees</h2><h3 id=\"Left-Rotation\"><a href=\"#Left-Rotation\" class=\"headerlink\" title=\"Left Rotation\"></a>Left Rotation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                              z</span><br><span class=\"line\">  x                          /                  </span><br><span class=\"line\"> / \\      --(左旋)--&gt;        x</span><br><span class=\"line\">y   z                      /</span><br><span class=\"line\">                          y</span><br></pre></td></tr></table></figure>\n<p>Make left rotation on x node, and it will be a left node.</p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/leftrotate.jpg\" alt=\"Left Rotate\"></p>\n<h4 id=\"Pseudo-code\"><a href=\"#Pseudo-code\" class=\"headerlink\" title=\"Pseudo code\"></a>Pseudo code</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LEFT-ROTATE(T, x)  </span><br><span class=\"line\"> y ← right[x]            </span><br><span class=\"line\"> right[x] ← left[y]      </span><br><span class=\"line\"> p[left[y]] ← x         </span><br><span class=\"line\"> p[y] ← p[x]             </span><br><span class=\"line\"> if p[x] = nil[T]       </span><br><span class=\"line\"> then root[T] ← y                 </span><br><span class=\"line\"> else if x = left[p[x]]  </span><br><span class=\"line\">           then left[p[x]] ← y   </span><br><span class=\"line\">           else right[p[x]] ← y  </span><br><span class=\"line\"> left[y] ← x             </span><br><span class=\"line\"> p[x] ← y</span><br></pre></td></tr></table></figure>\n<h4 id=\"C-Code\"><a href=\"#C-Code\" class=\"headerlink\" title=\"C++ Code\"></a>C++ Code</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void RedBlackTree&lt;T&gt;::leftRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *x) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRedBlackNode&lt;T&gt; *y = x-&gt;pRight;     </span><br><span class=\"line\"></span><br><span class=\"line\">\tx-&gt;pRight = y-&gt;pLeft;                    </span><br><span class=\"line\">\tif(y-&gt;pLeft != nullptr) &#123;</span><br><span class=\"line\">\t\ty-&gt;pLeft-&gt;pParent = x;        </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ty-&gt;pParent = x-&gt;pParent;         </span><br><span class=\"line\"></span><br><span class=\"line\">\tif(x-&gt;pParent == nullptr) &#123;      </span><br><span class=\"line\">\t\troot = y;                      </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse &#123;</span><br><span class=\"line\">\t\tif(x-&gt;pParent-&gt;pLeft == x) &#123;    </span><br><span class=\"line\">\t\t\tx-&gt;pParent-&gt;pLeft = y;      </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\tx-&gt;pParent-&gt;pRight = y; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ty-&gt;pLeft = x;                   </span><br><span class=\"line\">\tx-&gt;pParent = y;                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Right-Rotation\"><a href=\"#Right-Rotation\" class=\"headerlink\" title=\"Right Rotation\"></a>Right Rotation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                             y</span><br><span class=\"line\">  x                           \\                 </span><br><span class=\"line\"> / \\      --(右旋)--&gt;           x</span><br><span class=\"line\">y   z                            \\</span><br><span class=\"line\">                                  z</span><br></pre></td></tr></table></figure>\n<p>Make right rotation on x node, and it will be a right node.</p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/rightrotate.jpg\" alt=\"\"></p>\n<h4 id=\"Pseudo-code-1\"><a href=\"#Pseudo-code-1\" class=\"headerlink\" title=\"Pseudo code\"></a>Pseudo code</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RIGHT-ROTATE(T, y)  </span><br><span class=\"line\"> x ← left[y]             </span><br><span class=\"line\"> left[y] ← right[x]      </span><br><span class=\"line\"> p[right[x]] ← y         </span><br><span class=\"line\"> p[x] ← p[y]             </span><br><span class=\"line\"> if p[y] = nil[T]       </span><br><span class=\"line\"> then root[T] ← x               </span><br><span class=\"line\"> else if y = right[p[y]]  </span><br><span class=\"line\">           then right[p[y]] ← x   </span><br><span class=\"line\">           else left[p[y]] ← x   </span><br><span class=\"line\"> right[x] ← y            </span><br><span class=\"line\"> p[y] ← x</span><br></pre></td></tr></table></figure>\n<h4 id=\"C-Code-1\"><a href=\"#C-Code-1\" class=\"headerlink\" title=\"C++ Code\"></a>C++ Code</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void RedBlackTree&lt;T&gt;::rightRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *y) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRedBlackNode&lt;T&gt; *x = y-&gt;pLeft;    </span><br><span class=\"line\"></span><br><span class=\"line\">\ty-&gt;pLeft = x-&gt;pRight;              </span><br><span class=\"line\">\tif(x-&gt;pRight != nullptr) &#123;</span><br><span class=\"line\">\t\tx-&gt;pRight-&gt;pParent = y;     </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx-&gt;pParent = y-&gt;pParent;           </span><br><span class=\"line\"></span><br><span class=\"line\">\tif(y-&gt;pParent == nullptr) &#123;        </span><br><span class=\"line\">\t\troot = x;                       </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse &#123;</span><br><span class=\"line\">\t\tif(y-&gt;pParent-&gt;pRight == y) &#123;   </span><br><span class=\"line\">\t\t\ty-&gt;pParent-&gt;pRight = x;     </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\ty-&gt;pParent-&gt;pLeft = x;   </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tx-&gt;pRight = y;       </span><br><span class=\"line\">\ty-&gt;pParent = x;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://hucoco.com/2018/03/02/RedBlackTree-II/\">The Next Section</a></p>"},{"title":"RedBlackTree_II","date":"2018-03-02T15:38:16.000Z","thumbnail":"http://hucoco.com/img/RedBlackTree/rbtree.png","_content":"\n[RedBlackTree II Chinese version address](http://hucoco.coding.me/2016/11/09/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%EF%BC%89/)\n\n[The Last Section](http://hucoco.com/2018/03/02/RedBlackTree-I/)\n\n## Basic operation of red black trees \n\n### Insert\n\nInsert a node into the red-black tree, which steps need to be performed?\n\n1. think of the red-black tree as a binary search tree and insert the node.\n2. Set this node to red.\n3. Modify the tree by rotating and recoloring it to make it a red-black tree again.\n\n<!--more-->\n\n#### Step Description\n\n##### Step 1\n\nThe red-black tree is a binary search tree, which is still a binary search tree after the node is inserted. This means that the key of the tree is still ordered. In addition, whether it is left-rotation or right-rotation, the tree is a binary search tree before rotation, and after rotation it must be a binary search tree.\n\n##### Step 2\n\nWhy should set the node's color to red?\n\nBecause it is not violate 5 features. violate more less feature mean less things we need to deal with.\n\n##### Step 3\n\nSo how many features it violate?\n\n1. As for feature 1, obviously not violate.\n2. As for feature 2, insert operation does not change the root node, so the color of root node is still black.\n3. As for feature 3, leaf node is null node, inserting non-null node does not affect feature.\n4. As for feature 4, Is possible to violate.\n\n#### Case Description\n\n##### Case 1\n\n###### Description\n\nThe current node's parent node is red, and the current node's grandparent node's other child node (uncle node) is also red\n\n```\nwhile color[p[z]] = RED                                                  \n    do if p[z] = left[p[p[z]]]                                           \n          then y ← right[p[p[z]]]                                       \n               if color[y] = RED  \n```\n\nGrandfather node must exist at this time, otherwise it is not black red tree before inserting. At this point is divided into the parent node is the grandfather's left child or right child, according to symmetry, we just untie a direction on it. Here only consider the parent node left grandfather's situation, as shown below.\n\n![](http://hucoco.com/img/RedBlackTree/insertFix1.png)\n\n###### Method\n\nStrategy is as follows: \n\n1. Sets the parent node to black.\n2. Sets the node of the uncle to black.\n3. set grandfather node to red.\n4. The grandfather node is set as the current node (red node).\n\nAs shown in the following pseudo code:\n\n```\nthen color[p[z]] ← BLACK                  ▹ Case 1   \n   color[y] ← BLACK                       ▹ Case 1   \n   color[p[p[z]]] ← RED                   ▹ Case 1   \n   z ← p[p[z]]                            ▹ Case 1   \n```\n\n![](http://hucoco.com/img/RedBlackTree/insertFix2.png)\n\nThen, insert repair case 1 translates into insert repair case 2.\n\n##### Case 2\n\n###### Description\n\nThe current node's parent node is red, the uncle node is black, and the current node is the right child of its parent node\n\n###### Method\n\nStrategy is as follows: \n\n1. Set the parent as the new current node.\n2. Do left rotation on current node.\n\nAs shown in the following pseudo code:\n\n```\nelse if z = right[p[z]]                                \n      then z ← p[z]                       ▹ Case 2   \n           LEFT-ROTATE(T, z)              ▹ Case 2   \n```\n\n![](http://hucoco.com/img/RedBlackTree/insertFix3.png)\n\nInsertion Repair Case 2 translates into insert repair case 3.\n\n##### Case 3\n\n###### Description\n\nThe current node's parent node is red, the uncle node is black, and the current node is the left child of its parent node\n\n###### Method\n\nStrategy is as follows: \n\n1. Sets the parent node to black.\n2. set grandfather node to red.\n3. Do right rotation on grandfather node.\n\nAs shown in the following pseudo code:\n\n```\ncolor[p[z]] ← BLACK                 ▹ Case 3   \ncolor[p[p[z]]] ← RED                ▹ Case 3   \nRIGHT-ROTATE(T, p[p[z]])            ▹ Case 3 \n```\n\n![](http://hucoco.com/img/RedBlackTree/insertFix4.png)\n\n### Code Reference\n\n#### Pseudo code:\n\n##### Insert Pseudo Code\n\n```\nRB-INSERT(T, z)  \n y ← nil[T]                        \n x ← root[T]                       \n while x ≠ nil[T]                  \n     do y ← x                      \n        if key[z] < key[x]  \n           then x ← left[x]  \n           else x ← right[x]  \n p[z] ← y                          \n if y = nil[T]                     \n    then root[T] ← z               \n    else if key[z] < key[y]        \n            then left[y] ← z       \n            else right[y] ← z       \n left[z] ← nil[T]                  \n right[z] ← nil[T]                 \n color[z] ← RED                    \n RB-INSERT-FIXUP(T, z)\n```\n\n##### Insert-Fixed Pseudo Code\n\n```\nRB-INSERT-FIXUP(T, z)\nwhile color[p[z]] = RED                                                  \n    do if p[z] = left[p[p[z]]]                                           \n          then y ← right[p[p[z]]]                                       \n               if color[y] = RED                                         \n                  then color[p[z]] ← BLACK                    ▹ Case 1   \n                       color[y] ← BLACK                       ▹ Case 1   \n                       color[p[p[z]]] ← RED                   ▹ Case 1   \n                       z ← p[p[z]]                            ▹ Case 1   \n                  else if z = right[p[z]]                                \n                          then z ← p[z]                       ▹ Case 2   \n                               LEFT-ROTATE(T, z)              ▹ Case 2   \n                          color[p[z]] ← BLACK                 ▹ Case 3   \n                          color[p[p[z]]] ← RED                ▹ Case 3   \n                          RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3  \n       else (same as then clause with \"right\" and \"left\" exchanged)      \ncolor[root[T]] ← BLACK\n```\n\n#### C++ Implementation\n\n##### Insert C++ Code\n```\ntemplate <class T>\nbool RedBlackTree<T>::insert(RedBlackNode<T> *&root, RedBlackNode<T> *node) {\n\n\tRedBlackNode<T>* y = nullptr;   \n\tRedBlackNode<T>* x = root;     \n\n\twhile (x != nullptr) {          \n\n\t\tif(x->key == node->key){    \n\t\t\treturn false;\n\t\t}\n\n\t\ty = x;                     \n\t\tif(node->key < x->key) {   \n\t\t\tx = x->pLeft;           \n\t\t} else {\n\t\t\tx = x->pRight;\t\t\t\n\t\t}\n\n\t}\n\n\t\n\tnode->pParent = y;\t\t\t\t\n\n\tif(y != nullptr) {\t\t\t\t\n\t\tif(node->key < y->key) {\t\n\t\t\ty->pLeft = node;\t\t\n\t\t} else {\t\t\t\t\t\n\t\t\ty->pRight = node;\t\t\n\t\t}\n\t} else {\n\t\troot = node;\t\t\t\t\n\t}\n\n\tset_red(node);\t\t\n\n\tinsertFixUp(root, node);\n\n\treturn true;\n\n}\n```\n##### Insert-Fixed C++ Code\n\n```\ntemplate <class T>\nvoid RedBlackTree<T>::insertFixUp(RedBlackNode<T> *&root, RedBlackNode<T> *node) {\n\n\tRedBlackNode<T>* parent;\n\tRedBlackNode<T>* gparnet;\n\n\twhile ((parent = get_parent(node))&&(is_red(parent))) {\n\n\t\tgparnet = get_parent(parent);\n\n\t\tif(parent == gparnet->pLeft) {\n            RedBlackNode<T>* uncle = gparnet->pRight;\n            if(uncle && is_red(uncle)) {\n                set_black(uncle);\n                set_black(parent);\n                set_red(gparnet);\n                node = gparnet;\n                continue;\n            }\n            if(parent->pRight == node) {\n                RedBlackNode<T>* tmp;\n                leftRotate(root, parent);\n                tmp = parent;\n                parent = node;\n                node = tmp;\n            }\n            set_black(parent);\n            set_red(gparnet);\n            rightRotate(root, gparnet);\n\n\t\t}\n\t\telse {\n            RedBlackNode<T>* uncle = gparnet->pLeft;\n            if(uncle && is_red(uncle)) {\n                set_black(uncle);\n                set_black(parent);\n                set_red(gparnet);\n                node = gparnet;\n                continue;\n            }\n            if(parent->pLeft == node) {\n                RedBlackNode<T>* tmp;\n                rightRotate(root, parent);\n                tmp = parent;\n                parent = node;\n                node = tmp;\n            }\n            set_black(parent);\n            set_red(gparnet);\n            leftRotate(root, gparnet);\n        }\n\n\t}\n\tset_black(root);\n}\n```\n\n[The Next Section](http://hucoco.com/2018/03/02/RedBlackTree-II/)","source":"_posts/RedBlackTree-II.md","raw":"---\ntitle: RedBlackTree_II\ndate: 2018-03-02 23:38:16\nthumbnail: http://hucoco.com/img/RedBlackTree/rbtree.png\ntags: \n- C++\n- Data Structure\n- Tree\ncategories:\n- Data Structure\n- Tree\n---\n\n[RedBlackTree II Chinese version address](http://hucoco.coding.me/2016/11/09/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%EF%BC%89/)\n\n[The Last Section](http://hucoco.com/2018/03/02/RedBlackTree-I/)\n\n## Basic operation of red black trees \n\n### Insert\n\nInsert a node into the red-black tree, which steps need to be performed?\n\n1. think of the red-black tree as a binary search tree and insert the node.\n2. Set this node to red.\n3. Modify the tree by rotating and recoloring it to make it a red-black tree again.\n\n<!--more-->\n\n#### Step Description\n\n##### Step 1\n\nThe red-black tree is a binary search tree, which is still a binary search tree after the node is inserted. This means that the key of the tree is still ordered. In addition, whether it is left-rotation or right-rotation, the tree is a binary search tree before rotation, and after rotation it must be a binary search tree.\n\n##### Step 2\n\nWhy should set the node's color to red?\n\nBecause it is not violate 5 features. violate more less feature mean less things we need to deal with.\n\n##### Step 3\n\nSo how many features it violate?\n\n1. As for feature 1, obviously not violate.\n2. As for feature 2, insert operation does not change the root node, so the color of root node is still black.\n3. As for feature 3, leaf node is null node, inserting non-null node does not affect feature.\n4. As for feature 4, Is possible to violate.\n\n#### Case Description\n\n##### Case 1\n\n###### Description\n\nThe current node's parent node is red, and the current node's grandparent node's other child node (uncle node) is also red\n\n```\nwhile color[p[z]] = RED                                                  \n    do if p[z] = left[p[p[z]]]                                           \n          then y ← right[p[p[z]]]                                       \n               if color[y] = RED  \n```\n\nGrandfather node must exist at this time, otherwise it is not black red tree before inserting. At this point is divided into the parent node is the grandfather's left child or right child, according to symmetry, we just untie a direction on it. Here only consider the parent node left grandfather's situation, as shown below.\n\n![](http://hucoco.com/img/RedBlackTree/insertFix1.png)\n\n###### Method\n\nStrategy is as follows: \n\n1. Sets the parent node to black.\n2. Sets the node of the uncle to black.\n3. set grandfather node to red.\n4. The grandfather node is set as the current node (red node).\n\nAs shown in the following pseudo code:\n\n```\nthen color[p[z]] ← BLACK                  ▹ Case 1   \n   color[y] ← BLACK                       ▹ Case 1   \n   color[p[p[z]]] ← RED                   ▹ Case 1   \n   z ← p[p[z]]                            ▹ Case 1   \n```\n\n![](http://hucoco.com/img/RedBlackTree/insertFix2.png)\n\nThen, insert repair case 1 translates into insert repair case 2.\n\n##### Case 2\n\n###### Description\n\nThe current node's parent node is red, the uncle node is black, and the current node is the right child of its parent node\n\n###### Method\n\nStrategy is as follows: \n\n1. Set the parent as the new current node.\n2. Do left rotation on current node.\n\nAs shown in the following pseudo code:\n\n```\nelse if z = right[p[z]]                                \n      then z ← p[z]                       ▹ Case 2   \n           LEFT-ROTATE(T, z)              ▹ Case 2   \n```\n\n![](http://hucoco.com/img/RedBlackTree/insertFix3.png)\n\nInsertion Repair Case 2 translates into insert repair case 3.\n\n##### Case 3\n\n###### Description\n\nThe current node's parent node is red, the uncle node is black, and the current node is the left child of its parent node\n\n###### Method\n\nStrategy is as follows: \n\n1. Sets the parent node to black.\n2. set grandfather node to red.\n3. Do right rotation on grandfather node.\n\nAs shown in the following pseudo code:\n\n```\ncolor[p[z]] ← BLACK                 ▹ Case 3   \ncolor[p[p[z]]] ← RED                ▹ Case 3   \nRIGHT-ROTATE(T, p[p[z]])            ▹ Case 3 \n```\n\n![](http://hucoco.com/img/RedBlackTree/insertFix4.png)\n\n### Code Reference\n\n#### Pseudo code:\n\n##### Insert Pseudo Code\n\n```\nRB-INSERT(T, z)  \n y ← nil[T]                        \n x ← root[T]                       \n while x ≠ nil[T]                  \n     do y ← x                      \n        if key[z] < key[x]  \n           then x ← left[x]  \n           else x ← right[x]  \n p[z] ← y                          \n if y = nil[T]                     \n    then root[T] ← z               \n    else if key[z] < key[y]        \n            then left[y] ← z       \n            else right[y] ← z       \n left[z] ← nil[T]                  \n right[z] ← nil[T]                 \n color[z] ← RED                    \n RB-INSERT-FIXUP(T, z)\n```\n\n##### Insert-Fixed Pseudo Code\n\n```\nRB-INSERT-FIXUP(T, z)\nwhile color[p[z]] = RED                                                  \n    do if p[z] = left[p[p[z]]]                                           \n          then y ← right[p[p[z]]]                                       \n               if color[y] = RED                                         \n                  then color[p[z]] ← BLACK                    ▹ Case 1   \n                       color[y] ← BLACK                       ▹ Case 1   \n                       color[p[p[z]]] ← RED                   ▹ Case 1   \n                       z ← p[p[z]]                            ▹ Case 1   \n                  else if z = right[p[z]]                                \n                          then z ← p[z]                       ▹ Case 2   \n                               LEFT-ROTATE(T, z)              ▹ Case 2   \n                          color[p[z]] ← BLACK                 ▹ Case 3   \n                          color[p[p[z]]] ← RED                ▹ Case 3   \n                          RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3  \n       else (same as then clause with \"right\" and \"left\" exchanged)      \ncolor[root[T]] ← BLACK\n```\n\n#### C++ Implementation\n\n##### Insert C++ Code\n```\ntemplate <class T>\nbool RedBlackTree<T>::insert(RedBlackNode<T> *&root, RedBlackNode<T> *node) {\n\n\tRedBlackNode<T>* y = nullptr;   \n\tRedBlackNode<T>* x = root;     \n\n\twhile (x != nullptr) {          \n\n\t\tif(x->key == node->key){    \n\t\t\treturn false;\n\t\t}\n\n\t\ty = x;                     \n\t\tif(node->key < x->key) {   \n\t\t\tx = x->pLeft;           \n\t\t} else {\n\t\t\tx = x->pRight;\t\t\t\n\t\t}\n\n\t}\n\n\t\n\tnode->pParent = y;\t\t\t\t\n\n\tif(y != nullptr) {\t\t\t\t\n\t\tif(node->key < y->key) {\t\n\t\t\ty->pLeft = node;\t\t\n\t\t} else {\t\t\t\t\t\n\t\t\ty->pRight = node;\t\t\n\t\t}\n\t} else {\n\t\troot = node;\t\t\t\t\n\t}\n\n\tset_red(node);\t\t\n\n\tinsertFixUp(root, node);\n\n\treturn true;\n\n}\n```\n##### Insert-Fixed C++ Code\n\n```\ntemplate <class T>\nvoid RedBlackTree<T>::insertFixUp(RedBlackNode<T> *&root, RedBlackNode<T> *node) {\n\n\tRedBlackNode<T>* parent;\n\tRedBlackNode<T>* gparnet;\n\n\twhile ((parent = get_parent(node))&&(is_red(parent))) {\n\n\t\tgparnet = get_parent(parent);\n\n\t\tif(parent == gparnet->pLeft) {\n            RedBlackNode<T>* uncle = gparnet->pRight;\n            if(uncle && is_red(uncle)) {\n                set_black(uncle);\n                set_black(parent);\n                set_red(gparnet);\n                node = gparnet;\n                continue;\n            }\n            if(parent->pRight == node) {\n                RedBlackNode<T>* tmp;\n                leftRotate(root, parent);\n                tmp = parent;\n                parent = node;\n                node = tmp;\n            }\n            set_black(parent);\n            set_red(gparnet);\n            rightRotate(root, gparnet);\n\n\t\t}\n\t\telse {\n            RedBlackNode<T>* uncle = gparnet->pLeft;\n            if(uncle && is_red(uncle)) {\n                set_black(uncle);\n                set_black(parent);\n                set_red(gparnet);\n                node = gparnet;\n                continue;\n            }\n            if(parent->pLeft == node) {\n                RedBlackNode<T>* tmp;\n                rightRotate(root, parent);\n                tmp = parent;\n                parent = node;\n                node = tmp;\n            }\n            set_black(parent);\n            set_red(gparnet);\n            leftRotate(root, gparnet);\n        }\n\n\t}\n\tset_black(root);\n}\n```\n\n[The Next Section](http://hucoco.com/2018/03/02/RedBlackTree-II/)","slug":"RedBlackTree-II","published":1,"updated":"2018-03-03T14:24:17.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36u7000tssb9r9vaokro","content":"<p><a href=\"http://hucoco.coding.me/2016/11/09/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">RedBlackTree II Chinese version address</a></p>\n<p><a href=\"http://hucoco.com/2018/03/02/RedBlackTree-I/\">The Last Section</a></p>\n<h2 id=\"Basic-operation-of-red-black-trees\"><a href=\"#Basic-operation-of-red-black-trees\" class=\"headerlink\" title=\"Basic operation of red black trees\"></a>Basic operation of red black trees</h2><h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p>Insert a node into the red-black tree, which steps need to be performed?</p>\n<ol>\n<li>think of the red-black tree as a binary search tree and insert the node.</li>\n<li>Set this node to red.</li>\n<li>Modify the tree by rotating and recoloring it to make it a red-black tree again.</li>\n</ol>\n<a id=\"more\"></a>\n<h4 id=\"Step-Description\"><a href=\"#Step-Description\" class=\"headerlink\" title=\"Step Description\"></a>Step Description</h4><h5 id=\"Step-1\"><a href=\"#Step-1\" class=\"headerlink\" title=\"Step 1\"></a>Step 1</h5><p>The red-black tree is a binary search tree, which is still a binary search tree after the node is inserted. This means that the key of the tree is still ordered. In addition, whether it is left-rotation or right-rotation, the tree is a binary search tree before rotation, and after rotation it must be a binary search tree.</p>\n<h5 id=\"Step-2\"><a href=\"#Step-2\" class=\"headerlink\" title=\"Step 2\"></a>Step 2</h5><p>Why should set the node’s color to red?</p>\n<p>Because it is not violate 5 features. violate more less feature mean less things we need to deal with.</p>\n<h5 id=\"Step-3\"><a href=\"#Step-3\" class=\"headerlink\" title=\"Step 3\"></a>Step 3</h5><p>So how many features it violate?</p>\n<ol>\n<li>As for feature 1, obviously not violate.</li>\n<li>As for feature 2, insert operation does not change the root node, so the color of root node is still black.</li>\n<li>As for feature 3, leaf node is null node, inserting non-null node does not affect feature.</li>\n<li>As for feature 4, Is possible to violate.</li>\n</ol>\n<h4 id=\"Case-Description\"><a href=\"#Case-Description\" class=\"headerlink\" title=\"Case Description\"></a>Case Description</h4><h5 id=\"Case-1\"><a href=\"#Case-1\" class=\"headerlink\" title=\"Case 1\"></a>Case 1</h5><h6 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h6><p>The current node’s parent node is red, and the current node’s grandparent node’s other child node (uncle node) is also red</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while color[p[z]] = RED                                                  </span><br><span class=\"line\">    do if p[z] = left[p[p[z]]]                                           </span><br><span class=\"line\">          then y ← right[p[p[z]]]                                       </span><br><span class=\"line\">               if color[y] = RED</span><br></pre></td></tr></table></figure>\n<p>Grandfather node must exist at this time, otherwise it is not black red tree before inserting. At this point is divided into the parent node is the grandfather’s left child or right child, according to symmetry, we just untie a direction on it. Here only consider the parent node left grandfather’s situation, as shown below.</p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/insertFix1.png\" alt=\"\"></p>\n<h6 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h6><p>Strategy is as follows: </p>\n<ol>\n<li>Sets the parent node to black.</li>\n<li>Sets the node of the uncle to black.</li>\n<li>set grandfather node to red.</li>\n<li>The grandfather node is set as the current node (red node).</li>\n</ol>\n<p>As shown in the following pseudo code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then color[p[z]] ← BLACK                  ▹ Case 1   </span><br><span class=\"line\">   color[y] ← BLACK                       ▹ Case 1   </span><br><span class=\"line\">   color[p[p[z]]] ← RED                   ▹ Case 1   </span><br><span class=\"line\">   z ← p[p[z]]                            ▹ Case 1</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/insertFix2.png\" alt=\"\"></p>\n<p>Then, insert repair case 1 translates into insert repair case 2.</p>\n<h5 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2\"></a>Case 2</h5><h6 id=\"Description-1\"><a href=\"#Description-1\" class=\"headerlink\" title=\"Description\"></a>Description</h6><p>The current node’s parent node is red, the uncle node is black, and the current node is the right child of its parent node</p>\n<h6 id=\"Method-1\"><a href=\"#Method-1\" class=\"headerlink\" title=\"Method\"></a>Method</h6><p>Strategy is as follows: </p>\n<ol>\n<li>Set the parent as the new current node.</li>\n<li>Do left rotation on current node.</li>\n</ol>\n<p>As shown in the following pseudo code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">else if z = right[p[z]]                                </span><br><span class=\"line\">      then z ← p[z]                       ▹ Case 2   </span><br><span class=\"line\">           LEFT-ROTATE(T, z)              ▹ Case 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/insertFix3.png\" alt=\"\"></p>\n<p>Insertion Repair Case 2 translates into insert repair case 3.</p>\n<h5 id=\"Case-3\"><a href=\"#Case-3\" class=\"headerlink\" title=\"Case 3\"></a>Case 3</h5><h6 id=\"Description-2\"><a href=\"#Description-2\" class=\"headerlink\" title=\"Description\"></a>Description</h6><p>The current node’s parent node is red, the uncle node is black, and the current node is the left child of its parent node</p>\n<h6 id=\"Method-2\"><a href=\"#Method-2\" class=\"headerlink\" title=\"Method\"></a>Method</h6><p>Strategy is as follows: </p>\n<ol>\n<li>Sets the parent node to black.</li>\n<li>set grandfather node to red.</li>\n<li>Do right rotation on grandfather node.</li>\n</ol>\n<p>As shown in the following pseudo code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color[p[z]] ← BLACK                 ▹ Case 3   </span><br><span class=\"line\">color[p[p[z]]] ← RED                ▹ Case 3   </span><br><span class=\"line\">RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/insertFix4.png\" alt=\"\"></p>\n<h3 id=\"Code-Reference\"><a href=\"#Code-Reference\" class=\"headerlink\" title=\"Code Reference\"></a>Code Reference</h3><h4 id=\"Pseudo-code\"><a href=\"#Pseudo-code\" class=\"headerlink\" title=\"Pseudo code:\"></a>Pseudo code:</h4><h5 id=\"Insert-Pseudo-Code\"><a href=\"#Insert-Pseudo-Code\" class=\"headerlink\" title=\"Insert Pseudo Code\"></a>Insert Pseudo Code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RB-INSERT(T, z)  </span><br><span class=\"line\"> y ← nil[T]                        </span><br><span class=\"line\"> x ← root[T]                       </span><br><span class=\"line\"> while x ≠ nil[T]                  </span><br><span class=\"line\">     do y ← x                      </span><br><span class=\"line\">        if key[z] &lt; key[x]  </span><br><span class=\"line\">           then x ← left[x]  </span><br><span class=\"line\">           else x ← right[x]  </span><br><span class=\"line\"> p[z] ← y                          </span><br><span class=\"line\"> if y = nil[T]                     </span><br><span class=\"line\">    then root[T] ← z               </span><br><span class=\"line\">    else if key[z] &lt; key[y]        </span><br><span class=\"line\">            then left[y] ← z       </span><br><span class=\"line\">            else right[y] ← z       </span><br><span class=\"line\"> left[z] ← nil[T]                  </span><br><span class=\"line\"> right[z] ← nil[T]                 </span><br><span class=\"line\"> color[z] ← RED                    </span><br><span class=\"line\"> RB-INSERT-FIXUP(T, z)</span><br></pre></td></tr></table></figure>\n<h5 id=\"Insert-Fixed-Pseudo-Code\"><a href=\"#Insert-Fixed-Pseudo-Code\" class=\"headerlink\" title=\"Insert-Fixed Pseudo Code\"></a>Insert-Fixed Pseudo Code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RB-INSERT-FIXUP(T, z)</span><br><span class=\"line\">while color[p[z]] = RED                                                  </span><br><span class=\"line\">    do if p[z] = left[p[p[z]]]                                           </span><br><span class=\"line\">          then y ← right[p[p[z]]]                                       </span><br><span class=\"line\">               if color[y] = RED                                         </span><br><span class=\"line\">                  then color[p[z]] ← BLACK                    ▹ Case 1   </span><br><span class=\"line\">                       color[y] ← BLACK                       ▹ Case 1   </span><br><span class=\"line\">                       color[p[p[z]]] ← RED                   ▹ Case 1   </span><br><span class=\"line\">                       z ← p[p[z]]                            ▹ Case 1   </span><br><span class=\"line\">                  else if z = right[p[z]]                                </span><br><span class=\"line\">                          then z ← p[z]                       ▹ Case 2   </span><br><span class=\"line\">                               LEFT-ROTATE(T, z)              ▹ Case 2   </span><br><span class=\"line\">                          color[p[z]] ← BLACK                 ▹ Case 3   </span><br><span class=\"line\">                          color[p[p[z]]] ← RED                ▹ Case 3   </span><br><span class=\"line\">                          RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3  </span><br><span class=\"line\">       else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)      </span><br><span class=\"line\">color[root[T]] ← BLACK</span><br></pre></td></tr></table></figure>\n<h4 id=\"C-Implementation\"><a href=\"#C-Implementation\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h4><h5 id=\"Insert-C-Code\"><a href=\"#Insert-C-Code\" class=\"headerlink\" title=\"Insert C++ Code\"></a>Insert C++ Code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">bool RedBlackTree&lt;T&gt;::insert(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRedBlackNode&lt;T&gt;* y = nullptr;   </span><br><span class=\"line\">\tRedBlackNode&lt;T&gt;* x = root;     </span><br><span class=\"line\"></span><br><span class=\"line\">\twhile (x != nullptr) &#123;          </span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif(x-&gt;key == node-&gt;key)&#123;    </span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ty = x;                     </span><br><span class=\"line\">\t\tif(node-&gt;key &lt; x-&gt;key) &#123;   </span><br><span class=\"line\">\t\t\tx = x-&gt;pLeft;           </span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tx = x-&gt;pRight;\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tnode-&gt;pParent = y;\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(y != nullptr) &#123;\t\t\t\t</span><br><span class=\"line\">\t\tif(node-&gt;key &lt; y-&gt;key) &#123;\t</span><br><span class=\"line\">\t\t\ty-&gt;pLeft = node;\t\t</span><br><span class=\"line\">\t\t&#125; else &#123;\t\t\t\t\t</span><br><span class=\"line\">\t\t\ty-&gt;pRight = node;\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\troot = node;\t\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tset_red(node);\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tinsertFixUp(root, node);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Insert-Fixed-C-Code\"><a href=\"#Insert-Fixed-C-Code\" class=\"headerlink\" title=\"Insert-Fixed C++ Code\"></a>Insert-Fixed C++ Code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void RedBlackTree&lt;T&gt;::insertFixUp(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRedBlackNode&lt;T&gt;* parent;</span><br><span class=\"line\">\tRedBlackNode&lt;T&gt;* gparnet;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile ((parent = get_parent(node))&amp;&amp;(is_red(parent))) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgparnet = get_parent(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif(parent == gparnet-&gt;pLeft) &#123;</span><br><span class=\"line\">            RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pRight;</span><br><span class=\"line\">            if(uncle &amp;&amp; is_red(uncle)) &#123;</span><br><span class=\"line\">                set_black(uncle);</span><br><span class=\"line\">                set_black(parent);</span><br><span class=\"line\">                set_red(gparnet);</span><br><span class=\"line\">                node = gparnet;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(parent-&gt;pRight == node) &#123;</span><br><span class=\"line\">                RedBlackNode&lt;T&gt;* tmp;</span><br><span class=\"line\">                leftRotate(root, parent);</span><br><span class=\"line\">                tmp = parent;</span><br><span class=\"line\">                parent = node;</span><br><span class=\"line\">                node = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set_black(parent);</span><br><span class=\"line\">            set_red(gparnet);</span><br><span class=\"line\">            rightRotate(root, gparnet);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">            RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pLeft;</span><br><span class=\"line\">            if(uncle &amp;&amp; is_red(uncle)) &#123;</span><br><span class=\"line\">                set_black(uncle);</span><br><span class=\"line\">                set_black(parent);</span><br><span class=\"line\">                set_red(gparnet);</span><br><span class=\"line\">                node = gparnet;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(parent-&gt;pLeft == node) &#123;</span><br><span class=\"line\">                RedBlackNode&lt;T&gt;* tmp;</span><br><span class=\"line\">                rightRotate(root, parent);</span><br><span class=\"line\">                tmp = parent;</span><br><span class=\"line\">                parent = node;</span><br><span class=\"line\">                node = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set_black(parent);</span><br><span class=\"line\">            set_red(gparnet);</span><br><span class=\"line\">            leftRotate(root, gparnet);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tset_black(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://hucoco.com/2018/03/02/RedBlackTree-II/\">The Next Section</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/09/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">RedBlackTree II Chinese version address</a></p>\n<p><a href=\"http://hucoco.com/2018/03/02/RedBlackTree-I/\">The Last Section</a></p>\n<h2 id=\"Basic-operation-of-red-black-trees\"><a href=\"#Basic-operation-of-red-black-trees\" class=\"headerlink\" title=\"Basic operation of red black trees\"></a>Basic operation of red black trees</h2><h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p>Insert a node into the red-black tree, which steps need to be performed?</p>\n<ol>\n<li>think of the red-black tree as a binary search tree and insert the node.</li>\n<li>Set this node to red.</li>\n<li>Modify the tree by rotating and recoloring it to make it a red-black tree again.</li>\n</ol>","more":"<h4 id=\"Step-Description\"><a href=\"#Step-Description\" class=\"headerlink\" title=\"Step Description\"></a>Step Description</h4><h5 id=\"Step-1\"><a href=\"#Step-1\" class=\"headerlink\" title=\"Step 1\"></a>Step 1</h5><p>The red-black tree is a binary search tree, which is still a binary search tree after the node is inserted. This means that the key of the tree is still ordered. In addition, whether it is left-rotation or right-rotation, the tree is a binary search tree before rotation, and after rotation it must be a binary search tree.</p>\n<h5 id=\"Step-2\"><a href=\"#Step-2\" class=\"headerlink\" title=\"Step 2\"></a>Step 2</h5><p>Why should set the node’s color to red?</p>\n<p>Because it is not violate 5 features. violate more less feature mean less things we need to deal with.</p>\n<h5 id=\"Step-3\"><a href=\"#Step-3\" class=\"headerlink\" title=\"Step 3\"></a>Step 3</h5><p>So how many features it violate?</p>\n<ol>\n<li>As for feature 1, obviously not violate.</li>\n<li>As for feature 2, insert operation does not change the root node, so the color of root node is still black.</li>\n<li>As for feature 3, leaf node is null node, inserting non-null node does not affect feature.</li>\n<li>As for feature 4, Is possible to violate.</li>\n</ol>\n<h4 id=\"Case-Description\"><a href=\"#Case-Description\" class=\"headerlink\" title=\"Case Description\"></a>Case Description</h4><h5 id=\"Case-1\"><a href=\"#Case-1\" class=\"headerlink\" title=\"Case 1\"></a>Case 1</h5><h6 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h6><p>The current node’s parent node is red, and the current node’s grandparent node’s other child node (uncle node) is also red</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while color[p[z]] = RED                                                  </span><br><span class=\"line\">    do if p[z] = left[p[p[z]]]                                           </span><br><span class=\"line\">          then y ← right[p[p[z]]]                                       </span><br><span class=\"line\">               if color[y] = RED</span><br></pre></td></tr></table></figure>\n<p>Grandfather node must exist at this time, otherwise it is not black red tree before inserting. At this point is divided into the parent node is the grandfather’s left child or right child, according to symmetry, we just untie a direction on it. Here only consider the parent node left grandfather’s situation, as shown below.</p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/insertFix1.png\" alt=\"\"></p>\n<h6 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h6><p>Strategy is as follows: </p>\n<ol>\n<li>Sets the parent node to black.</li>\n<li>Sets the node of the uncle to black.</li>\n<li>set grandfather node to red.</li>\n<li>The grandfather node is set as the current node (red node).</li>\n</ol>\n<p>As shown in the following pseudo code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then color[p[z]] ← BLACK                  ▹ Case 1   </span><br><span class=\"line\">   color[y] ← BLACK                       ▹ Case 1   </span><br><span class=\"line\">   color[p[p[z]]] ← RED                   ▹ Case 1   </span><br><span class=\"line\">   z ← p[p[z]]                            ▹ Case 1</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/insertFix2.png\" alt=\"\"></p>\n<p>Then, insert repair case 1 translates into insert repair case 2.</p>\n<h5 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2\"></a>Case 2</h5><h6 id=\"Description-1\"><a href=\"#Description-1\" class=\"headerlink\" title=\"Description\"></a>Description</h6><p>The current node’s parent node is red, the uncle node is black, and the current node is the right child of its parent node</p>\n<h6 id=\"Method-1\"><a href=\"#Method-1\" class=\"headerlink\" title=\"Method\"></a>Method</h6><p>Strategy is as follows: </p>\n<ol>\n<li>Set the parent as the new current node.</li>\n<li>Do left rotation on current node.</li>\n</ol>\n<p>As shown in the following pseudo code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">else if z = right[p[z]]                                </span><br><span class=\"line\">      then z ← p[z]                       ▹ Case 2   </span><br><span class=\"line\">           LEFT-ROTATE(T, z)              ▹ Case 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/insertFix3.png\" alt=\"\"></p>\n<p>Insertion Repair Case 2 translates into insert repair case 3.</p>\n<h5 id=\"Case-3\"><a href=\"#Case-3\" class=\"headerlink\" title=\"Case 3\"></a>Case 3</h5><h6 id=\"Description-2\"><a href=\"#Description-2\" class=\"headerlink\" title=\"Description\"></a>Description</h6><p>The current node’s parent node is red, the uncle node is black, and the current node is the left child of its parent node</p>\n<h6 id=\"Method-2\"><a href=\"#Method-2\" class=\"headerlink\" title=\"Method\"></a>Method</h6><p>Strategy is as follows: </p>\n<ol>\n<li>Sets the parent node to black.</li>\n<li>set grandfather node to red.</li>\n<li>Do right rotation on grandfather node.</li>\n</ol>\n<p>As shown in the following pseudo code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color[p[z]] ← BLACK                 ▹ Case 3   </span><br><span class=\"line\">color[p[p[z]]] ← RED                ▹ Case 3   </span><br><span class=\"line\">RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/insertFix4.png\" alt=\"\"></p>\n<h3 id=\"Code-Reference\"><a href=\"#Code-Reference\" class=\"headerlink\" title=\"Code Reference\"></a>Code Reference</h3><h4 id=\"Pseudo-code\"><a href=\"#Pseudo-code\" class=\"headerlink\" title=\"Pseudo code:\"></a>Pseudo code:</h4><h5 id=\"Insert-Pseudo-Code\"><a href=\"#Insert-Pseudo-Code\" class=\"headerlink\" title=\"Insert Pseudo Code\"></a>Insert Pseudo Code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RB-INSERT(T, z)  </span><br><span class=\"line\"> y ← nil[T]                        </span><br><span class=\"line\"> x ← root[T]                       </span><br><span class=\"line\"> while x ≠ nil[T]                  </span><br><span class=\"line\">     do y ← x                      </span><br><span class=\"line\">        if key[z] &lt; key[x]  </span><br><span class=\"line\">           then x ← left[x]  </span><br><span class=\"line\">           else x ← right[x]  </span><br><span class=\"line\"> p[z] ← y                          </span><br><span class=\"line\"> if y = nil[T]                     </span><br><span class=\"line\">    then root[T] ← z               </span><br><span class=\"line\">    else if key[z] &lt; key[y]        </span><br><span class=\"line\">            then left[y] ← z       </span><br><span class=\"line\">            else right[y] ← z       </span><br><span class=\"line\"> left[z] ← nil[T]                  </span><br><span class=\"line\"> right[z] ← nil[T]                 </span><br><span class=\"line\"> color[z] ← RED                    </span><br><span class=\"line\"> RB-INSERT-FIXUP(T, z)</span><br></pre></td></tr></table></figure>\n<h5 id=\"Insert-Fixed-Pseudo-Code\"><a href=\"#Insert-Fixed-Pseudo-Code\" class=\"headerlink\" title=\"Insert-Fixed Pseudo Code\"></a>Insert-Fixed Pseudo Code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RB-INSERT-FIXUP(T, z)</span><br><span class=\"line\">while color[p[z]] = RED                                                  </span><br><span class=\"line\">    do if p[z] = left[p[p[z]]]                                           </span><br><span class=\"line\">          then y ← right[p[p[z]]]                                       </span><br><span class=\"line\">               if color[y] = RED                                         </span><br><span class=\"line\">                  then color[p[z]] ← BLACK                    ▹ Case 1   </span><br><span class=\"line\">                       color[y] ← BLACK                       ▹ Case 1   </span><br><span class=\"line\">                       color[p[p[z]]] ← RED                   ▹ Case 1   </span><br><span class=\"line\">                       z ← p[p[z]]                            ▹ Case 1   </span><br><span class=\"line\">                  else if z = right[p[z]]                                </span><br><span class=\"line\">                          then z ← p[z]                       ▹ Case 2   </span><br><span class=\"line\">                               LEFT-ROTATE(T, z)              ▹ Case 2   </span><br><span class=\"line\">                          color[p[z]] ← BLACK                 ▹ Case 3   </span><br><span class=\"line\">                          color[p[p[z]]] ← RED                ▹ Case 3   </span><br><span class=\"line\">                          RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3  </span><br><span class=\"line\">       else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)      </span><br><span class=\"line\">color[root[T]] ← BLACK</span><br></pre></td></tr></table></figure>\n<h4 id=\"C-Implementation\"><a href=\"#C-Implementation\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h4><h5 id=\"Insert-C-Code\"><a href=\"#Insert-C-Code\" class=\"headerlink\" title=\"Insert C++ Code\"></a>Insert C++ Code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">bool RedBlackTree&lt;T&gt;::insert(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRedBlackNode&lt;T&gt;* y = nullptr;   </span><br><span class=\"line\">\tRedBlackNode&lt;T&gt;* x = root;     </span><br><span class=\"line\"></span><br><span class=\"line\">\twhile (x != nullptr) &#123;          </span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif(x-&gt;key == node-&gt;key)&#123;    </span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ty = x;                     </span><br><span class=\"line\">\t\tif(node-&gt;key &lt; x-&gt;key) &#123;   </span><br><span class=\"line\">\t\t\tx = x-&gt;pLeft;           </span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tx = x-&gt;pRight;\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tnode-&gt;pParent = y;\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(y != nullptr) &#123;\t\t\t\t</span><br><span class=\"line\">\t\tif(node-&gt;key &lt; y-&gt;key) &#123;\t</span><br><span class=\"line\">\t\t\ty-&gt;pLeft = node;\t\t</span><br><span class=\"line\">\t\t&#125; else &#123;\t\t\t\t\t</span><br><span class=\"line\">\t\t\ty-&gt;pRight = node;\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\troot = node;\t\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tset_red(node);\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tinsertFixUp(root, node);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Insert-Fixed-C-Code\"><a href=\"#Insert-Fixed-C-Code\" class=\"headerlink\" title=\"Insert-Fixed C++ Code\"></a>Insert-Fixed C++ Code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void RedBlackTree&lt;T&gt;::insertFixUp(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRedBlackNode&lt;T&gt;* parent;</span><br><span class=\"line\">\tRedBlackNode&lt;T&gt;* gparnet;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile ((parent = get_parent(node))&amp;&amp;(is_red(parent))) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgparnet = get_parent(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif(parent == gparnet-&gt;pLeft) &#123;</span><br><span class=\"line\">            RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pRight;</span><br><span class=\"line\">            if(uncle &amp;&amp; is_red(uncle)) &#123;</span><br><span class=\"line\">                set_black(uncle);</span><br><span class=\"line\">                set_black(parent);</span><br><span class=\"line\">                set_red(gparnet);</span><br><span class=\"line\">                node = gparnet;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(parent-&gt;pRight == node) &#123;</span><br><span class=\"line\">                RedBlackNode&lt;T&gt;* tmp;</span><br><span class=\"line\">                leftRotate(root, parent);</span><br><span class=\"line\">                tmp = parent;</span><br><span class=\"line\">                parent = node;</span><br><span class=\"line\">                node = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set_black(parent);</span><br><span class=\"line\">            set_red(gparnet);</span><br><span class=\"line\">            rightRotate(root, gparnet);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">            RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pLeft;</span><br><span class=\"line\">            if(uncle &amp;&amp; is_red(uncle)) &#123;</span><br><span class=\"line\">                set_black(uncle);</span><br><span class=\"line\">                set_black(parent);</span><br><span class=\"line\">                set_red(gparnet);</span><br><span class=\"line\">                node = gparnet;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(parent-&gt;pLeft == node) &#123;</span><br><span class=\"line\">                RedBlackNode&lt;T&gt;* tmp;</span><br><span class=\"line\">                rightRotate(root, parent);</span><br><span class=\"line\">                tmp = parent;</span><br><span class=\"line\">                parent = node;</span><br><span class=\"line\">                node = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set_black(parent);</span><br><span class=\"line\">            set_red(gparnet);</span><br><span class=\"line\">            leftRotate(root, gparnet);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tset_black(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://hucoco.com/2018/03/02/RedBlackTree-II/\">The Next Section</a></p>"},{"title":"RedBlackTree_III","date":"2018-03-02T15:38:19.000Z","thumbnail":"http://hucoco.com/img/RedBlackTree/rbtree.png","_content":"\n[RedBlackTree III Chinese version address](http://hucoco.coding.me/2016/11/10/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%88%A0%E9%99%A4%EF%BC%89/)\n\n[The Last Section](http://hucoco.com/2018/03/02/RedBlackTree-II/)\n\n## Basic operation of red black trees \n\n### Delete\n\nThe method of deleting a node is the same as that of deleting a node in a binary search tree.\n\n#### Binary search tree Delete pseudo code\n\n```C++\nTREE-DELETE(T, z)  \n  if left[z] = NIL or right[z] = NIL  \n      then y ← z  \n      else y ← TREE-SUCCESSOR(z)  \n  if left[y] ≠ NIL  \n      then x ← left[y]  \n      else x ← right[y]  \n  if x ≠ NIL  \n      then p[x] ← p[y]  \n  if p[y] = NIL  \n      then root[T] ← x  \n      else if y = left[p[y]]  \n              then left[p[y]] ← x  \n              else right[p[y]] ← x  \n  if y ≠ z  \n      then key[z] ← key[y]  \n           copy y's satellite data into z  \n  return y\n```\n\n<!--more-->\n\nAccording to the node to be deleted according to the number of sons can be divided into three cases\n\n1. No child nodes. just set the child node of the parent node to NULL and delete the child node.\n2. Only one child node, the parent node's child node pointer points to the grandson node, delete the son node.\n3. Two child nodes, After deleting the node, but also to ensure that the search binary tree structure. In this case, the largest element in the left child node or the smallest element in the right child node can be placed in the position of the node to be deleted to ensure the structure is unchanged. \n\n#### Binary search tree Delete pseudo code\n\n```C++\nRB-DELETE(T, z)\nif left[z] = nil[T] or right[z] = nil[T]         \n   then y ← z                                  \n   else y ← TREE-SUCCESSOR(z)                  \nif left[y] ≠ nil[T]\n   then x ← left[y]                            \n   else x ← right[y]                           \np[x] ← p[y]                                    \nif p[y] = nil[T]                               \n   then root[T] ← x                            \n   else if y = left[p[y]]                    \n           then left[p[y]] ← x                 \n           else right[p[y]] ← x                \nif y ≠ z                                    \n   then key[z] ← key[y]                        \n        copy y's satellite data into z         \nif color[y] = BLACK                            \n   then RB-DELETE-FIXUP(T, x)                  \nreturn y\n```\n\nAfter you delete a node, it may violate the feature of the red black tree.\n\n1. If you delete the red node, then the feature of red black tree remains. At this time do not do the correction operation.\n2. If the deleted node is a black node, the feature of the red black tree may be changed, and we want to make corrections to it\n\nSo what are the feature of trees that will change?\n\n1. If the delete node is not the only node in the tree, then the number of black nodes to each leaf node of the delete node will change, and the property 5 is destroyed.\n2. If the deleted node's only non-empty child node is red, and the deleted node's parent node is also red, then the feature of 4 is destroyed.\n3. If the deleted node is the root node and its only non-empty child node is red, the new root node will be red after deletion, violating property 2.\n\nThe above repair looks a bit complicated, here we use an analytical skills:\n\nbegin to adjust the node from which the node was removed later, And think it has an extra black color. What is the meaning of an extra black here? We do not add the nodes of the red and black trees to another color of red and black. Here is just an assumption, and we think we are currently pointing to it, so there is an extra black. It can be thought that its black color is inherited from its parent after it was deleted. It can now hold two colors. If it was originally red, then it is red + black, and if it is black then its current color It is black + black. With this extra black, the feature of red-black tree 5 will remain unchanged. Now it is enough to resume other things as far as possible, and try to move all the possibilities to the root as far as possible.\n\nIf it is the case, the recovery is relatively simple:\n\n###### The current node is red + black.\n\nThe current node is set to black, the end of the red-black tree at this time the nature of all recovery.\n\n###### The current node is black + black and is the root node.\n\ndo nothing, the end.\n\nBut the following situation, it will be more complicated\n\n|Case|Description|\n|:-:|:--|\n|1|The current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black).|\n|2|The current node is black and black and the brother is black and both siblings have black children.|\n|3|The current node color is black + black, brother node is black, brother's left child is red, the right child is black.|\n|4|The current node color is black-black, its sibling node is black, but the sibling node's right child is red, the sibling node's left child's color is arbitrary|\n\n#### Case Description\n\n#### Case 1\n\n##### Description\n\nThe current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black).\n\n##### Method\n\n1. Set the parent node to red.\n2. Set the brother nodes to black.\n3. Do left rotation on parent node.\n4. reset the brother nodes.\n\n###### pseudo code\n\n```\nwhile x ≠ root[T] and color[x] = BLACK    \n    do if x = left[p[x]]    \n          then w ← right[p[x]]    \n               if color[w] = RED    \n                  then color[w] ← BLACK                 ▹  Case 1    \n                       color[p[x]] ← RED                ▹  Case 1    \n                       LEFT-ROTATE(T, p[x])             ▹  Case 1    \n                       w ← right[p[x]]                  ▹  Case 1\n\n```\n\n![Before Handle Case 1](http://hucoco.com/img/RedBlackTree/removeFix1.jpg)\n\n![After Handle Case 1](http://hucoco.com/img/RedBlackTree/removeFix2.jpg)\n\n#### Case 2\n\n##### Description\n\nThe current node is black and black and the brother is black and both siblings have black children.\n\n##### Method\n\n1. Set brother node to red.\n2. Set current node to parent node.\n\n###### pseudo code\n\n```\nif color[left[w]] = BLACK and color[right[w]] = BLACK    \n   then color[w] ← RED                          ▹  Case 2    \n        x ← p[x]                                ▹  Case 2\n```\n\n![Before Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix3.jpg)\n\n![After Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix4.jpg)\n\n#### Case 3\n\n##### Description\n\nThe current node color is black + black, brother node is black, brother's left child is red, the right child is black.\n\n##### Method\n\n1. Set brother node's left child node to black.\n2. Set brother node to red.\n3. Do right rotation on brother node.\n4. reset brother node.\n\n###### pseudo code\n\n```\nelse if color[right[w]] = BLACK    \n        then color[left[w]] ← BLACK          ▹  Case 3    \n             color[w] ← RED                  ▹  Case 3    \n             RIGHT-ROTATE(T, w)              ▹  Case 3    \n             w ← right[p[x]]                 ▹  Case 3\n```\n\n![Before Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix5.jpg)\n\n![After Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix6.jpg)\n\n#### Case 4\n\n##### Description\n\nThe current node color is black-black, its sibling node is black, but the sibling node's right child is red, the sibling node's left child's color is arbitrary\n\n##### Method\n\n1. Set the brother node to the color of parent node.\n2. Set parent node to black.\n3. Set the brother node's right left node to black.\n4. Do right rotation on parent node.\n5. set current node to root node.\n\n###### pseudo code\n\n```\ncolor[w] ← color[p[x]]                 ▹  Case 4    \ncolor[p[x]] ← BLACK                    ▹  Case 4    \ncolor[right[w]] ← BLACK                ▹  Case 4    \nLEFT-ROTATE(T, p[x])                   ▹  Case 4    \nx ← root[T]                            ▹  Case 4 \n```\n\n![Before Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix7.jpg)\n\n![After Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix8.jpg)\n","source":"_posts/RedBlackTree-III.md","raw":"---\ntitle: RedBlackTree_III\ndate: 2018-03-02 23:38:19\nthumbnail: http://hucoco.com/img/RedBlackTree/rbtree.png\ntags: \n- C++\n- Data Structure\n- Tree\ncategories:\n- Data Structure\n- Tree\n---\n\n[RedBlackTree III Chinese version address](http://hucoco.coding.me/2016/11/10/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%88%A0%E9%99%A4%EF%BC%89/)\n\n[The Last Section](http://hucoco.com/2018/03/02/RedBlackTree-II/)\n\n## Basic operation of red black trees \n\n### Delete\n\nThe method of deleting a node is the same as that of deleting a node in a binary search tree.\n\n#### Binary search tree Delete pseudo code\n\n```C++\nTREE-DELETE(T, z)  \n  if left[z] = NIL or right[z] = NIL  \n      then y ← z  \n      else y ← TREE-SUCCESSOR(z)  \n  if left[y] ≠ NIL  \n      then x ← left[y]  \n      else x ← right[y]  \n  if x ≠ NIL  \n      then p[x] ← p[y]  \n  if p[y] = NIL  \n      then root[T] ← x  \n      else if y = left[p[y]]  \n              then left[p[y]] ← x  \n              else right[p[y]] ← x  \n  if y ≠ z  \n      then key[z] ← key[y]  \n           copy y's satellite data into z  \n  return y\n```\n\n<!--more-->\n\nAccording to the node to be deleted according to the number of sons can be divided into three cases\n\n1. No child nodes. just set the child node of the parent node to NULL and delete the child node.\n2. Only one child node, the parent node's child node pointer points to the grandson node, delete the son node.\n3. Two child nodes, After deleting the node, but also to ensure that the search binary tree structure. In this case, the largest element in the left child node or the smallest element in the right child node can be placed in the position of the node to be deleted to ensure the structure is unchanged. \n\n#### Binary search tree Delete pseudo code\n\n```C++\nRB-DELETE(T, z)\nif left[z] = nil[T] or right[z] = nil[T]         \n   then y ← z                                  \n   else y ← TREE-SUCCESSOR(z)                  \nif left[y] ≠ nil[T]\n   then x ← left[y]                            \n   else x ← right[y]                           \np[x] ← p[y]                                    \nif p[y] = nil[T]                               \n   then root[T] ← x                            \n   else if y = left[p[y]]                    \n           then left[p[y]] ← x                 \n           else right[p[y]] ← x                \nif y ≠ z                                    \n   then key[z] ← key[y]                        \n        copy y's satellite data into z         \nif color[y] = BLACK                            \n   then RB-DELETE-FIXUP(T, x)                  \nreturn y\n```\n\nAfter you delete a node, it may violate the feature of the red black tree.\n\n1. If you delete the red node, then the feature of red black tree remains. At this time do not do the correction operation.\n2. If the deleted node is a black node, the feature of the red black tree may be changed, and we want to make corrections to it\n\nSo what are the feature of trees that will change?\n\n1. If the delete node is not the only node in the tree, then the number of black nodes to each leaf node of the delete node will change, and the property 5 is destroyed.\n2. If the deleted node's only non-empty child node is red, and the deleted node's parent node is also red, then the feature of 4 is destroyed.\n3. If the deleted node is the root node and its only non-empty child node is red, the new root node will be red after deletion, violating property 2.\n\nThe above repair looks a bit complicated, here we use an analytical skills:\n\nbegin to adjust the node from which the node was removed later, And think it has an extra black color. What is the meaning of an extra black here? We do not add the nodes of the red and black trees to another color of red and black. Here is just an assumption, and we think we are currently pointing to it, so there is an extra black. It can be thought that its black color is inherited from its parent after it was deleted. It can now hold two colors. If it was originally red, then it is red + black, and if it is black then its current color It is black + black. With this extra black, the feature of red-black tree 5 will remain unchanged. Now it is enough to resume other things as far as possible, and try to move all the possibilities to the root as far as possible.\n\nIf it is the case, the recovery is relatively simple:\n\n###### The current node is red + black.\n\nThe current node is set to black, the end of the red-black tree at this time the nature of all recovery.\n\n###### The current node is black + black and is the root node.\n\ndo nothing, the end.\n\nBut the following situation, it will be more complicated\n\n|Case|Description|\n|:-:|:--|\n|1|The current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black).|\n|2|The current node is black and black and the brother is black and both siblings have black children.|\n|3|The current node color is black + black, brother node is black, brother's left child is red, the right child is black.|\n|4|The current node color is black-black, its sibling node is black, but the sibling node's right child is red, the sibling node's left child's color is arbitrary|\n\n#### Case Description\n\n#### Case 1\n\n##### Description\n\nThe current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black).\n\n##### Method\n\n1. Set the parent node to red.\n2. Set the brother nodes to black.\n3. Do left rotation on parent node.\n4. reset the brother nodes.\n\n###### pseudo code\n\n```\nwhile x ≠ root[T] and color[x] = BLACK    \n    do if x = left[p[x]]    \n          then w ← right[p[x]]    \n               if color[w] = RED    \n                  then color[w] ← BLACK                 ▹  Case 1    \n                       color[p[x]] ← RED                ▹  Case 1    \n                       LEFT-ROTATE(T, p[x])             ▹  Case 1    \n                       w ← right[p[x]]                  ▹  Case 1\n\n```\n\n![Before Handle Case 1](http://hucoco.com/img/RedBlackTree/removeFix1.jpg)\n\n![After Handle Case 1](http://hucoco.com/img/RedBlackTree/removeFix2.jpg)\n\n#### Case 2\n\n##### Description\n\nThe current node is black and black and the brother is black and both siblings have black children.\n\n##### Method\n\n1. Set brother node to red.\n2. Set current node to parent node.\n\n###### pseudo code\n\n```\nif color[left[w]] = BLACK and color[right[w]] = BLACK    \n   then color[w] ← RED                          ▹  Case 2    \n        x ← p[x]                                ▹  Case 2\n```\n\n![Before Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix3.jpg)\n\n![After Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix4.jpg)\n\n#### Case 3\n\n##### Description\n\nThe current node color is black + black, brother node is black, brother's left child is red, the right child is black.\n\n##### Method\n\n1. Set brother node's left child node to black.\n2. Set brother node to red.\n3. Do right rotation on brother node.\n4. reset brother node.\n\n###### pseudo code\n\n```\nelse if color[right[w]] = BLACK    \n        then color[left[w]] ← BLACK          ▹  Case 3    \n             color[w] ← RED                  ▹  Case 3    \n             RIGHT-ROTATE(T, w)              ▹  Case 3    \n             w ← right[p[x]]                 ▹  Case 3\n```\n\n![Before Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix5.jpg)\n\n![After Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix6.jpg)\n\n#### Case 4\n\n##### Description\n\nThe current node color is black-black, its sibling node is black, but the sibling node's right child is red, the sibling node's left child's color is arbitrary\n\n##### Method\n\n1. Set the brother node to the color of parent node.\n2. Set parent node to black.\n3. Set the brother node's right left node to black.\n4. Do right rotation on parent node.\n5. set current node to root node.\n\n###### pseudo code\n\n```\ncolor[w] ← color[p[x]]                 ▹  Case 4    \ncolor[p[x]] ← BLACK                    ▹  Case 4    \ncolor[right[w]] ← BLACK                ▹  Case 4    \nLEFT-ROTATE(T, p[x])                   ▹  Case 4    \nx ← root[T]                            ▹  Case 4 \n```\n\n![Before Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix7.jpg)\n\n![After Handle Case 2](http://hucoco.com/img/RedBlackTree/removeFix8.jpg)\n","slug":"RedBlackTree-III","published":1,"updated":"2018-03-05T14:00:03.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36u9000ussb9mfuznqcg","content":"<p><a href=\"http://hucoco.coding.me/2016/11/10/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%88%A0%E9%99%A4%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">RedBlackTree III Chinese version address</a></p>\n<p><a href=\"http://hucoco.com/2018/03/02/RedBlackTree-II/\">The Last Section</a></p>\n<h2 id=\"Basic-operation-of-red-black-trees\"><a href=\"#Basic-operation-of-red-black-trees\" class=\"headerlink\" title=\"Basic operation of red black trees\"></a>Basic operation of red black trees</h2><h3 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><p>The method of deleting a node is the same as that of deleting a node in a binary search tree.</p>\n<h4 id=\"Binary-search-tree-Delete-pseudo-code\"><a href=\"#Binary-search-tree-Delete-pseudo-code\" class=\"headerlink\" title=\"Binary search tree Delete pseudo code\"></a>Binary search tree Delete pseudo code</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TREE-DELETE(T, z)  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> left[z] = NIL <span class=\"keyword\">or</span> right[z] = NIL  </span><br><span class=\"line\">      then y ← z  </span><br><span class=\"line\">      <span class=\"keyword\">else</span> y ← TREE-SUCCESSOR(z)  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> left[y] ≠ NIL  </span><br><span class=\"line\">      then x ← left[y]  </span><br><span class=\"line\">      <span class=\"keyword\">else</span> x ← right[y]  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> x ≠ NIL  </span><br><span class=\"line\">      then p[x] ← p[y]  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> p[y] = NIL  </span><br><span class=\"line\">      then root[T] ← x  </span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> y = left[p[y]]  </span><br><span class=\"line\">              then left[p[y]] ← x  </span><br><span class=\"line\">              <span class=\"keyword\">else</span> right[p[y]] ← x  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> y ≠ z  </span><br><span class=\"line\">      then key[z] ← key[y]  </span><br><span class=\"line\">           copy y's satellite data into z  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> y</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>According to the node to be deleted according to the number of sons can be divided into three cases</p>\n<ol>\n<li>No child nodes. just set the child node of the parent node to NULL and delete the child node.</li>\n<li>Only one child node, the parent node’s child node pointer points to the grandson node, delete the son node.</li>\n<li>Two child nodes, After deleting the node, but also to ensure that the search binary tree structure. In this case, the largest element in the left child node or the smallest element in the right child node can be placed in the position of the node to be deleted to ensure the structure is unchanged. </li>\n</ol>\n<h4 id=\"Binary-search-tree-Delete-pseudo-code-1\"><a href=\"#Binary-search-tree-Delete-pseudo-code-1\" class=\"headerlink\" title=\"Binary search tree Delete pseudo code\"></a>Binary search tree Delete pseudo code</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RB-DELETE(T, z)</span><br><span class=\"line\"><span class=\"keyword\">if</span> left[z] = nil[T] <span class=\"keyword\">or</span> right[z] = nil[T]         </span><br><span class=\"line\">   then y ← z                                  </span><br><span class=\"line\">   <span class=\"keyword\">else</span> y ← TREE-SUCCESSOR(z)                  </span><br><span class=\"line\"><span class=\"keyword\">if</span> left[y] ≠ nil[T]</span><br><span class=\"line\">   then x ← left[y]                            </span><br><span class=\"line\">   <span class=\"keyword\">else</span> x ← right[y]                           </span><br><span class=\"line\">p[x] ← p[y]                                    </span><br><span class=\"line\"><span class=\"keyword\">if</span> p[y] = nil[T]                               </span><br><span class=\"line\">   then root[T] ← x                            </span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> y = left[p[y]]                    </span><br><span class=\"line\">           then left[p[y]] ← x                 </span><br><span class=\"line\">           <span class=\"keyword\">else</span> right[p[y]] ← x                </span><br><span class=\"line\"><span class=\"keyword\">if</span> y ≠ z                                    </span><br><span class=\"line\">   then key[z] ← key[y]                        </span><br><span class=\"line\">        copy y's satellite data into z         </span><br><span class=\"line\"><span class=\"keyword\">if</span> color[y] = BLACK                            </span><br><span class=\"line\">   then RB-DELETE-FIXUP(T, x)                  </span><br><span class=\"line\"><span class=\"keyword\">return</span> y</span><br></pre></td></tr></table></figure>\n<p>After you delete a node, it may violate the feature of the red black tree.</p>\n<ol>\n<li>If you delete the red node, then the feature of red black tree remains. At this time do not do the correction operation.</li>\n<li>If the deleted node is a black node, the feature of the red black tree may be changed, and we want to make corrections to it</li>\n</ol>\n<p>So what are the feature of trees that will change?</p>\n<ol>\n<li>If the delete node is not the only node in the tree, then the number of black nodes to each leaf node of the delete node will change, and the property 5 is destroyed.</li>\n<li>If the deleted node’s only non-empty child node is red, and the deleted node’s parent node is also red, then the feature of 4 is destroyed.</li>\n<li>If the deleted node is the root node and its only non-empty child node is red, the new root node will be red after deletion, violating property 2.</li>\n</ol>\n<p>The above repair looks a bit complicated, here we use an analytical skills:</p>\n<p>begin to adjust the node from which the node was removed later, And think it has an extra black color. What is the meaning of an extra black here? We do not add the nodes of the red and black trees to another color of red and black. Here is just an assumption, and we think we are currently pointing to it, so there is an extra black. It can be thought that its black color is inherited from its parent after it was deleted. It can now hold two colors. If it was originally red, then it is red + black, and if it is black then its current color It is black + black. With this extra black, the feature of red-black tree 5 will remain unchanged. Now it is enough to resume other things as far as possible, and try to move all the possibilities to the root as far as possible.</p>\n<p>If it is the case, the recovery is relatively simple:</p>\n<h6 id=\"The-current-node-is-red-black\"><a href=\"#The-current-node-is-red-black\" class=\"headerlink\" title=\"The current node is red + black.\"></a>The current node is red + black.</h6><p>The current node is set to black, the end of the red-black tree at this time the nature of all recovery.</p>\n<h6 id=\"The-current-node-is-black-black-and-is-the-root-node\"><a href=\"#The-current-node-is-black-black-and-is-the-root-node\" class=\"headerlink\" title=\"The current node is black + black and is the root node.\"></a>The current node is black + black and is the root node.</h6><p>do nothing, the end.</p>\n<p>But the following situation, it will be more complicated</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Case</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">The current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black).</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\">The current node is black and black and the brother is black and both siblings have black children.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:left\">The current node color is black + black, brother node is black, brother’s left child is red, the right child is black.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:left\">The current node color is black-black, its sibling node is black, but the sibling node’s right child is red, the sibling node’s left child’s color is arbitrary</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"Case-Description\"><a href=\"#Case-Description\" class=\"headerlink\" title=\"Case Description\"></a>Case Description</h4><h4 id=\"Case-1\"><a href=\"#Case-1\" class=\"headerlink\" title=\"Case 1\"></a>Case 1</h4><h5 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h5><p>The current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black).</p>\n<h5 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h5><ol>\n<li>Set the parent node to red.</li>\n<li>Set the brother nodes to black.</li>\n<li>Do left rotation on parent node.</li>\n<li>reset the brother nodes.</li>\n</ol>\n<h6 id=\"pseudo-code\"><a href=\"#pseudo-code\" class=\"headerlink\" title=\"pseudo code\"></a>pseudo code</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while x ≠ root[T] and color[x] = BLACK    </span><br><span class=\"line\">    do if x = left[p[x]]    </span><br><span class=\"line\">          then w ← right[p[x]]    </span><br><span class=\"line\">               if color[w] = RED    </span><br><span class=\"line\">                  then color[w] ← BLACK                 ▹  Case 1    </span><br><span class=\"line\">                       color[p[x]] ← RED                ▹  Case 1    </span><br><span class=\"line\">                       LEFT-ROTATE(T, p[x])             ▹  Case 1    </span><br><span class=\"line\">                       w ← right[p[x]]                  ▹  Case 1</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix1.jpg\" alt=\"Before Handle Case 1\"></p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix2.jpg\" alt=\"After Handle Case 1\"></p>\n<h4 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2\"></a>Case 2</h4><h5 id=\"Description-1\"><a href=\"#Description-1\" class=\"headerlink\" title=\"Description\"></a>Description</h5><p>The current node is black and black and the brother is black and both siblings have black children.</p>\n<h5 id=\"Method-1\"><a href=\"#Method-1\" class=\"headerlink\" title=\"Method\"></a>Method</h5><ol>\n<li>Set brother node to red.</li>\n<li>Set current node to parent node.</li>\n</ol>\n<h6 id=\"pseudo-code-1\"><a href=\"#pseudo-code-1\" class=\"headerlink\" title=\"pseudo code\"></a>pseudo code</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if color[left[w]] = BLACK and color[right[w]] = BLACK    </span><br><span class=\"line\">   then color[w] ← RED                          ▹  Case 2    </span><br><span class=\"line\">        x ← p[x]                                ▹  Case 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix3.jpg\" alt=\"Before Handle Case 2\"></p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix4.jpg\" alt=\"After Handle Case 2\"></p>\n<h4 id=\"Case-3\"><a href=\"#Case-3\" class=\"headerlink\" title=\"Case 3\"></a>Case 3</h4><h5 id=\"Description-2\"><a href=\"#Description-2\" class=\"headerlink\" title=\"Description\"></a>Description</h5><p>The current node color is black + black, brother node is black, brother’s left child is red, the right child is black.</p>\n<h5 id=\"Method-2\"><a href=\"#Method-2\" class=\"headerlink\" title=\"Method\"></a>Method</h5><ol>\n<li>Set brother node’s left child node to black.</li>\n<li>Set brother node to red.</li>\n<li>Do right rotation on brother node.</li>\n<li>reset brother node.</li>\n</ol>\n<h6 id=\"pseudo-code-2\"><a href=\"#pseudo-code-2\" class=\"headerlink\" title=\"pseudo code\"></a>pseudo code</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">else if color[right[w]] = BLACK    </span><br><span class=\"line\">        then color[left[w]] ← BLACK          ▹  Case 3    </span><br><span class=\"line\">             color[w] ← RED                  ▹  Case 3    </span><br><span class=\"line\">             RIGHT-ROTATE(T, w)              ▹  Case 3    </span><br><span class=\"line\">             w ← right[p[x]]                 ▹  Case 3</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix5.jpg\" alt=\"Before Handle Case 2\"></p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix6.jpg\" alt=\"After Handle Case 2\"></p>\n<h4 id=\"Case-4\"><a href=\"#Case-4\" class=\"headerlink\" title=\"Case 4\"></a>Case 4</h4><h5 id=\"Description-3\"><a href=\"#Description-3\" class=\"headerlink\" title=\"Description\"></a>Description</h5><p>The current node color is black-black, its sibling node is black, but the sibling node’s right child is red, the sibling node’s left child’s color is arbitrary</p>\n<h5 id=\"Method-3\"><a href=\"#Method-3\" class=\"headerlink\" title=\"Method\"></a>Method</h5><ol>\n<li>Set the brother node to the color of parent node.</li>\n<li>Set parent node to black.</li>\n<li>Set the brother node’s right left node to black.</li>\n<li>Do right rotation on parent node.</li>\n<li>set current node to root node.</li>\n</ol>\n<h6 id=\"pseudo-code-3\"><a href=\"#pseudo-code-3\" class=\"headerlink\" title=\"pseudo code\"></a>pseudo code</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color[w] ← color[p[x]]                 ▹  Case 4    </span><br><span class=\"line\">color[p[x]] ← BLACK                    ▹  Case 4    </span><br><span class=\"line\">color[right[w]] ← BLACK                ▹  Case 4    </span><br><span class=\"line\">LEFT-ROTATE(T, p[x])                   ▹  Case 4    </span><br><span class=\"line\">x ← root[T]                            ▹  Case 4</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix7.jpg\" alt=\"Before Handle Case 2\"></p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix8.jpg\" alt=\"After Handle Case 2\"></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/10/Tree/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%88%A0%E9%99%A4%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">RedBlackTree III Chinese version address</a></p>\n<p><a href=\"http://hucoco.com/2018/03/02/RedBlackTree-II/\">The Last Section</a></p>\n<h2 id=\"Basic-operation-of-red-black-trees\"><a href=\"#Basic-operation-of-red-black-trees\" class=\"headerlink\" title=\"Basic operation of red black trees\"></a>Basic operation of red black trees</h2><h3 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><p>The method of deleting a node is the same as that of deleting a node in a binary search tree.</p>\n<h4 id=\"Binary-search-tree-Delete-pseudo-code\"><a href=\"#Binary-search-tree-Delete-pseudo-code\" class=\"headerlink\" title=\"Binary search tree Delete pseudo code\"></a>Binary search tree Delete pseudo code</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TREE-DELETE(T, z)  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> left[z] = NIL <span class=\"keyword\">or</span> right[z] = NIL  </span><br><span class=\"line\">      then y ← z  </span><br><span class=\"line\">      <span class=\"keyword\">else</span> y ← TREE-SUCCESSOR(z)  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> left[y] ≠ NIL  </span><br><span class=\"line\">      then x ← left[y]  </span><br><span class=\"line\">      <span class=\"keyword\">else</span> x ← right[y]  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> x ≠ NIL  </span><br><span class=\"line\">      then p[x] ← p[y]  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> p[y] = NIL  </span><br><span class=\"line\">      then root[T] ← x  </span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> y = left[p[y]]  </span><br><span class=\"line\">              then left[p[y]] ← x  </span><br><span class=\"line\">              <span class=\"keyword\">else</span> right[p[y]] ← x  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> y ≠ z  </span><br><span class=\"line\">      then key[z] ← key[y]  </span><br><span class=\"line\">           copy y's satellite data into z  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> y</span><br></pre></td></tr></table></figure>","more":"<p>According to the node to be deleted according to the number of sons can be divided into three cases</p>\n<ol>\n<li>No child nodes. just set the child node of the parent node to NULL and delete the child node.</li>\n<li>Only one child node, the parent node’s child node pointer points to the grandson node, delete the son node.</li>\n<li>Two child nodes, After deleting the node, but also to ensure that the search binary tree structure. In this case, the largest element in the left child node or the smallest element in the right child node can be placed in the position of the node to be deleted to ensure the structure is unchanged. </li>\n</ol>\n<h4 id=\"Binary-search-tree-Delete-pseudo-code-1\"><a href=\"#Binary-search-tree-Delete-pseudo-code-1\" class=\"headerlink\" title=\"Binary search tree Delete pseudo code\"></a>Binary search tree Delete pseudo code</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RB-DELETE(T, z)</span><br><span class=\"line\"><span class=\"keyword\">if</span> left[z] = nil[T] <span class=\"keyword\">or</span> right[z] = nil[T]         </span><br><span class=\"line\">   then y ← z                                  </span><br><span class=\"line\">   <span class=\"keyword\">else</span> y ← TREE-SUCCESSOR(z)                  </span><br><span class=\"line\"><span class=\"keyword\">if</span> left[y] ≠ nil[T]</span><br><span class=\"line\">   then x ← left[y]                            </span><br><span class=\"line\">   <span class=\"keyword\">else</span> x ← right[y]                           </span><br><span class=\"line\">p[x] ← p[y]                                    </span><br><span class=\"line\"><span class=\"keyword\">if</span> p[y] = nil[T]                               </span><br><span class=\"line\">   then root[T] ← x                            </span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> y = left[p[y]]                    </span><br><span class=\"line\">           then left[p[y]] ← x                 </span><br><span class=\"line\">           <span class=\"keyword\">else</span> right[p[y]] ← x                </span><br><span class=\"line\"><span class=\"keyword\">if</span> y ≠ z                                    </span><br><span class=\"line\">   then key[z] ← key[y]                        </span><br><span class=\"line\">        copy y's satellite data into z         </span><br><span class=\"line\"><span class=\"keyword\">if</span> color[y] = BLACK                            </span><br><span class=\"line\">   then RB-DELETE-FIXUP(T, x)                  </span><br><span class=\"line\"><span class=\"keyword\">return</span> y</span><br></pre></td></tr></table></figure>\n<p>After you delete a node, it may violate the feature of the red black tree.</p>\n<ol>\n<li>If you delete the red node, then the feature of red black tree remains. At this time do not do the correction operation.</li>\n<li>If the deleted node is a black node, the feature of the red black tree may be changed, and we want to make corrections to it</li>\n</ol>\n<p>So what are the feature of trees that will change?</p>\n<ol>\n<li>If the delete node is not the only node in the tree, then the number of black nodes to each leaf node of the delete node will change, and the property 5 is destroyed.</li>\n<li>If the deleted node’s only non-empty child node is red, and the deleted node’s parent node is also red, then the feature of 4 is destroyed.</li>\n<li>If the deleted node is the root node and its only non-empty child node is red, the new root node will be red after deletion, violating property 2.</li>\n</ol>\n<p>The above repair looks a bit complicated, here we use an analytical skills:</p>\n<p>begin to adjust the node from which the node was removed later, And think it has an extra black color. What is the meaning of an extra black here? We do not add the nodes of the red and black trees to another color of red and black. Here is just an assumption, and we think we are currently pointing to it, so there is an extra black. It can be thought that its black color is inherited from its parent after it was deleted. It can now hold two colors. If it was originally red, then it is red + black, and if it is black then its current color It is black + black. With this extra black, the feature of red-black tree 5 will remain unchanged. Now it is enough to resume other things as far as possible, and try to move all the possibilities to the root as far as possible.</p>\n<p>If it is the case, the recovery is relatively simple:</p>\n<h6 id=\"The-current-node-is-red-black\"><a href=\"#The-current-node-is-red-black\" class=\"headerlink\" title=\"The current node is red + black.\"></a>The current node is red + black.</h6><p>The current node is set to black, the end of the red-black tree at this time the nature of all recovery.</p>\n<h6 id=\"The-current-node-is-black-black-and-is-the-root-node\"><a href=\"#The-current-node-is-black-black-and-is-the-root-node\" class=\"headerlink\" title=\"The current node is black + black and is the root node.\"></a>The current node is black + black and is the root node.</h6><p>do nothing, the end.</p>\n<p>But the following situation, it will be more complicated</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Case</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">The current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black).</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\">The current node is black and black and the brother is black and both siblings have black children.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:left\">The current node color is black + black, brother node is black, brother’s left child is red, the right child is black.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:left\">The current node color is black-black, its sibling node is black, but the sibling node’s right child is red, the sibling node’s left child’s color is arbitrary</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"Case-Description\"><a href=\"#Case-Description\" class=\"headerlink\" title=\"Case Description\"></a>Case Description</h4><h4 id=\"Case-1\"><a href=\"#Case-1\" class=\"headerlink\" title=\"Case 1\"></a>Case 1</h4><h5 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h5><p>The current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black).</p>\n<h5 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h5><ol>\n<li>Set the parent node to red.</li>\n<li>Set the brother nodes to black.</li>\n<li>Do left rotation on parent node.</li>\n<li>reset the brother nodes.</li>\n</ol>\n<h6 id=\"pseudo-code\"><a href=\"#pseudo-code\" class=\"headerlink\" title=\"pseudo code\"></a>pseudo code</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while x ≠ root[T] and color[x] = BLACK    </span><br><span class=\"line\">    do if x = left[p[x]]    </span><br><span class=\"line\">          then w ← right[p[x]]    </span><br><span class=\"line\">               if color[w] = RED    </span><br><span class=\"line\">                  then color[w] ← BLACK                 ▹  Case 1    </span><br><span class=\"line\">                       color[p[x]] ← RED                ▹  Case 1    </span><br><span class=\"line\">                       LEFT-ROTATE(T, p[x])             ▹  Case 1    </span><br><span class=\"line\">                       w ← right[p[x]]                  ▹  Case 1</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix1.jpg\" alt=\"Before Handle Case 1\"></p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix2.jpg\" alt=\"After Handle Case 1\"></p>\n<h4 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2\"></a>Case 2</h4><h5 id=\"Description-1\"><a href=\"#Description-1\" class=\"headerlink\" title=\"Description\"></a>Description</h5><p>The current node is black and black and the brother is black and both siblings have black children.</p>\n<h5 id=\"Method-1\"><a href=\"#Method-1\" class=\"headerlink\" title=\"Method\"></a>Method</h5><ol>\n<li>Set brother node to red.</li>\n<li>Set current node to parent node.</li>\n</ol>\n<h6 id=\"pseudo-code-1\"><a href=\"#pseudo-code-1\" class=\"headerlink\" title=\"pseudo code\"></a>pseudo code</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if color[left[w]] = BLACK and color[right[w]] = BLACK    </span><br><span class=\"line\">   then color[w] ← RED                          ▹  Case 2    </span><br><span class=\"line\">        x ← p[x]                                ▹  Case 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix3.jpg\" alt=\"Before Handle Case 2\"></p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix4.jpg\" alt=\"After Handle Case 2\"></p>\n<h4 id=\"Case-3\"><a href=\"#Case-3\" class=\"headerlink\" title=\"Case 3\"></a>Case 3</h4><h5 id=\"Description-2\"><a href=\"#Description-2\" class=\"headerlink\" title=\"Description\"></a>Description</h5><p>The current node color is black + black, brother node is black, brother’s left child is red, the right child is black.</p>\n<h5 id=\"Method-2\"><a href=\"#Method-2\" class=\"headerlink\" title=\"Method\"></a>Method</h5><ol>\n<li>Set brother node’s left child node to black.</li>\n<li>Set brother node to red.</li>\n<li>Do right rotation on brother node.</li>\n<li>reset brother node.</li>\n</ol>\n<h6 id=\"pseudo-code-2\"><a href=\"#pseudo-code-2\" class=\"headerlink\" title=\"pseudo code\"></a>pseudo code</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">else if color[right[w]] = BLACK    </span><br><span class=\"line\">        then color[left[w]] ← BLACK          ▹  Case 3    </span><br><span class=\"line\">             color[w] ← RED                  ▹  Case 3    </span><br><span class=\"line\">             RIGHT-ROTATE(T, w)              ▹  Case 3    </span><br><span class=\"line\">             w ← right[p[x]]                 ▹  Case 3</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix5.jpg\" alt=\"Before Handle Case 2\"></p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix6.jpg\" alt=\"After Handle Case 2\"></p>\n<h4 id=\"Case-4\"><a href=\"#Case-4\" class=\"headerlink\" title=\"Case 4\"></a>Case 4</h4><h5 id=\"Description-3\"><a href=\"#Description-3\" class=\"headerlink\" title=\"Description\"></a>Description</h5><p>The current node color is black-black, its sibling node is black, but the sibling node’s right child is red, the sibling node’s left child’s color is arbitrary</p>\n<h5 id=\"Method-3\"><a href=\"#Method-3\" class=\"headerlink\" title=\"Method\"></a>Method</h5><ol>\n<li>Set the brother node to the color of parent node.</li>\n<li>Set parent node to black.</li>\n<li>Set the brother node’s right left node to black.</li>\n<li>Do right rotation on parent node.</li>\n<li>set current node to root node.</li>\n</ol>\n<h6 id=\"pseudo-code-3\"><a href=\"#pseudo-code-3\" class=\"headerlink\" title=\"pseudo code\"></a>pseudo code</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color[w] ← color[p[x]]                 ▹  Case 4    </span><br><span class=\"line\">color[p[x]] ← BLACK                    ▹  Case 4    </span><br><span class=\"line\">color[right[w]] ← BLACK                ▹  Case 4    </span><br><span class=\"line\">LEFT-ROTATE(T, p[x])                   ▹  Case 4    </span><br><span class=\"line\">x ← root[T]                            ▹  Case 4</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix7.jpg\" alt=\"Before Handle Case 2\"></p>\n<p><img src=\"http://hucoco.com/img/RedBlackTree/removeFix8.jpg\" alt=\"After Handle Case 2\"></p>"},{"title":"SSE Instruction List","date":"2018-03-26T14:22:53.000Z","thumbnail":"http://hucoco.com/img/SIMD/Example_SIMD.jpg","_content":"\n## move instruction\n\n|Instruction|Description|\n|::|::|\n|movaps|move 4 alignment single precision value to xmm register|\n|movups|move 4 non-alignment single precision value to xmm register|\n|movss|move 1 alignment single precision value to low 4 bytes of register|\n|movlps|move 2 alignment single precision value to low 8 bytes of register|\n|movhps|move 2 alignment single precision value to high 8 bytes of register|\n|movlhps|move 2 alignment single precision value to high 8 bytes of register from low 8 bytes|\n|movhlps|move 2 alignment single precision value to low 8 bytes of register from high 8 bytes|\n\n\n## basic operation instruction\n\n|Instruction|Description|\n|::|::|\n|addps|add operation|\n|subps|sub operation|\n|mulps|mul operation|\n|divps|div operation|\n|rcpps|rcp opeartion|\n|sqrtps|sqrt operation|\n|rsqrtps|rcp sqrt operation|\n|maxps|get max operation|\t\n|minps|get min operation|\n|andps|and operation|\n|andnps|negation operation|\n|orps|or operation|\n|xorps|xor operation|\n\n## compared instruction\n\n|Instruction|Description|\n|::|::|\n|cmpps|compared operation|\n|cmpss|compared operation|\n|comiss|compared and set eflags register|\n|ucomiss|compared and set eflags register|\n\nthose instruction will return a value:\n\n|Return Value|Description|\n|::|::|\n|0|Equal to|\n|1|Less-than|\n|2|Less than or equal to|\n|3|Disorder|\n|4|Not equal to|\n|5|Greater than|\n|6|Greater than or equal to|\n|7|Order|","source":"_posts/SSE-Instruction-List.md","raw":"---\ntitle: SSE Instruction List\ndate: 2018-03-26 22:22:53\nthumbnail: http://hucoco.com/img/SIMD/Example_SIMD.jpg\ntags: \n- C++\n- SIMD\n- SSE\ncategories:\n- SIMD\n- SSE\n---\n\n## move instruction\n\n|Instruction|Description|\n|::|::|\n|movaps|move 4 alignment single precision value to xmm register|\n|movups|move 4 non-alignment single precision value to xmm register|\n|movss|move 1 alignment single precision value to low 4 bytes of register|\n|movlps|move 2 alignment single precision value to low 8 bytes of register|\n|movhps|move 2 alignment single precision value to high 8 bytes of register|\n|movlhps|move 2 alignment single precision value to high 8 bytes of register from low 8 bytes|\n|movhlps|move 2 alignment single precision value to low 8 bytes of register from high 8 bytes|\n\n\n## basic operation instruction\n\n|Instruction|Description|\n|::|::|\n|addps|add operation|\n|subps|sub operation|\n|mulps|mul operation|\n|divps|div operation|\n|rcpps|rcp opeartion|\n|sqrtps|sqrt operation|\n|rsqrtps|rcp sqrt operation|\n|maxps|get max operation|\t\n|minps|get min operation|\n|andps|and operation|\n|andnps|negation operation|\n|orps|or operation|\n|xorps|xor operation|\n\n## compared instruction\n\n|Instruction|Description|\n|::|::|\n|cmpps|compared operation|\n|cmpss|compared operation|\n|comiss|compared and set eflags register|\n|ucomiss|compared and set eflags register|\n\nthose instruction will return a value:\n\n|Return Value|Description|\n|::|::|\n|0|Equal to|\n|1|Less-than|\n|2|Less than or equal to|\n|3|Disorder|\n|4|Not equal to|\n|5|Greater than|\n|6|Greater than or equal to|\n|7|Order|","slug":"SSE-Instruction-List","published":1,"updated":"2018-03-26T14:50:20.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36ua000yssb9nwmnt33b","content":"<h2 id=\"move-instruction\"><a href=\"#move-instruction\" class=\"headerlink\" title=\"move instruction\"></a>move instruction</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Instruction</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>movaps</td>\n<td>move 4 alignment single precision value to xmm register</td>\n</tr>\n<tr>\n<td>movups</td>\n<td>move 4 non-alignment single precision value to xmm register</td>\n</tr>\n<tr>\n<td>movss</td>\n<td>move 1 alignment single precision value to low 4 bytes of register</td>\n</tr>\n<tr>\n<td>movlps</td>\n<td>move 2 alignment single precision value to low 8 bytes of register</td>\n</tr>\n<tr>\n<td>movhps</td>\n<td>move 2 alignment single precision value to high 8 bytes of register</td>\n</tr>\n<tr>\n<td>movlhps</td>\n<td>move 2 alignment single precision value to high 8 bytes of register from low 8 bytes</td>\n</tr>\n<tr>\n<td>movhlps</td>\n<td>move 2 alignment single precision value to low 8 bytes of register from high 8 bytes</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"basic-operation-instruction\"><a href=\"#basic-operation-instruction\" class=\"headerlink\" title=\"basic operation instruction\"></a>basic operation instruction</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Instruction</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>addps</td>\n<td>add operation</td>\n</tr>\n<tr>\n<td>subps</td>\n<td>sub operation</td>\n</tr>\n<tr>\n<td>mulps</td>\n<td>mul operation</td>\n</tr>\n<tr>\n<td>divps</td>\n<td>div operation</td>\n</tr>\n<tr>\n<td>rcpps</td>\n<td>rcp opeartion</td>\n</tr>\n<tr>\n<td>sqrtps</td>\n<td>sqrt operation</td>\n</tr>\n<tr>\n<td>rsqrtps</td>\n<td>rcp sqrt operation</td>\n</tr>\n<tr>\n<td>maxps</td>\n<td>get max operation</td>\n</tr>\n<tr>\n<td>minps</td>\n<td>get min operation</td>\n</tr>\n<tr>\n<td>andps</td>\n<td>and operation</td>\n</tr>\n<tr>\n<td>andnps</td>\n<td>negation operation</td>\n</tr>\n<tr>\n<td>orps</td>\n<td>or operation</td>\n</tr>\n<tr>\n<td>xorps</td>\n<td>xor operation</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"compared-instruction\"><a href=\"#compared-instruction\" class=\"headerlink\" title=\"compared instruction\"></a>compared instruction</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Instruction</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cmpps</td>\n<td>compared operation</td>\n</tr>\n<tr>\n<td>cmpss</td>\n<td>compared operation</td>\n</tr>\n<tr>\n<td>comiss</td>\n<td>compared and set eflags register</td>\n</tr>\n<tr>\n<td>ucomiss</td>\n<td>compared and set eflags register</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>those instruction will return a value:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Return Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>Equal to</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Less-than</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Less than or equal to</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Disorder</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Not equal to</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Greater than</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Greater than or equal to</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Order</td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"move-instruction\"><a href=\"#move-instruction\" class=\"headerlink\" title=\"move instruction\"></a>move instruction</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Instruction</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>movaps</td>\n<td>move 4 alignment single precision value to xmm register</td>\n</tr>\n<tr>\n<td>movups</td>\n<td>move 4 non-alignment single precision value to xmm register</td>\n</tr>\n<tr>\n<td>movss</td>\n<td>move 1 alignment single precision value to low 4 bytes of register</td>\n</tr>\n<tr>\n<td>movlps</td>\n<td>move 2 alignment single precision value to low 8 bytes of register</td>\n</tr>\n<tr>\n<td>movhps</td>\n<td>move 2 alignment single precision value to high 8 bytes of register</td>\n</tr>\n<tr>\n<td>movlhps</td>\n<td>move 2 alignment single precision value to high 8 bytes of register from low 8 bytes</td>\n</tr>\n<tr>\n<td>movhlps</td>\n<td>move 2 alignment single precision value to low 8 bytes of register from high 8 bytes</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"basic-operation-instruction\"><a href=\"#basic-operation-instruction\" class=\"headerlink\" title=\"basic operation instruction\"></a>basic operation instruction</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Instruction</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>addps</td>\n<td>add operation</td>\n</tr>\n<tr>\n<td>subps</td>\n<td>sub operation</td>\n</tr>\n<tr>\n<td>mulps</td>\n<td>mul operation</td>\n</tr>\n<tr>\n<td>divps</td>\n<td>div operation</td>\n</tr>\n<tr>\n<td>rcpps</td>\n<td>rcp opeartion</td>\n</tr>\n<tr>\n<td>sqrtps</td>\n<td>sqrt operation</td>\n</tr>\n<tr>\n<td>rsqrtps</td>\n<td>rcp sqrt operation</td>\n</tr>\n<tr>\n<td>maxps</td>\n<td>get max operation</td>\n</tr>\n<tr>\n<td>minps</td>\n<td>get min operation</td>\n</tr>\n<tr>\n<td>andps</td>\n<td>and operation</td>\n</tr>\n<tr>\n<td>andnps</td>\n<td>negation operation</td>\n</tr>\n<tr>\n<td>orps</td>\n<td>or operation</td>\n</tr>\n<tr>\n<td>xorps</td>\n<td>xor operation</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"compared-instruction\"><a href=\"#compared-instruction\" class=\"headerlink\" title=\"compared instruction\"></a>compared instruction</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Instruction</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cmpps</td>\n<td>compared operation</td>\n</tr>\n<tr>\n<td>cmpss</td>\n<td>compared operation</td>\n</tr>\n<tr>\n<td>comiss</td>\n<td>compared and set eflags register</td>\n</tr>\n<tr>\n<td>ucomiss</td>\n<td>compared and set eflags register</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>those instruction will return a value:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Return Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>Equal to</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Less-than</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Less than or equal to</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Disorder</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Not equal to</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Greater than</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Greater than or equal to</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Order</td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"Sorting Algorithm","date":"2018-03-10T05:07:14.000Z","thumbnail":"http://hucoco.com/img/PythonSort/6.gif","_content":"\n# 8 Kind of Sorting Algorithm\n\n## Bubble sort\n\n```\ndef bubble_sort(lists):\n    count = len(lists)\n    for i in range(0, count):\n        for j in range(i + 1, count):\n            if lists[i] > lists[j]:\n                lists[i], lists[j] = lists[j], lists[i]\n    return lists\n```\n\n![](http://hucoco.com/img/PythonSort/2.gif)\n\n<!--more-->\n\n## Insertion sort\n\n```\ndef insert_sort(lists):\n    count = len(lists)\n    for i in range(1, count):\n        key = lists[i]\n        j = i - 1\n        while j >= 0:\n            if lists[j] > key:\n                lists[j + 1] = lists[j]\n                lists[j] = key\n            j -= 1\n    return lists\n```\n\n![]()\n\n## Shell Sort\n\n```\ndef shell_sort(lists):\n    count = len(lists)\n    step = 2\n    group = count // step\n    while group > 0:\n        for i in range(0, group):\n            j = i + group\n            while j < count:\n                k = j - group\n                key = lists[j]\n                while k >= 0:\n                    if lists[k] > key:\n                        lists[k + group] = lists[k]\n                        lists[k] = key\n                    k -= group\n                j += group\n        group //= step\n    return lists\n```\n\n![](http://hucoco.com/img/PythonSort/1.gif)\n\n## Selection Sort\n\n```\ndef select_sort(lists):\n    count = len(lists)\n    for i in range(0, count):\n        min = i\n        for j in range(i + 1, count):\n            if lists[min] > lists[j]:\n                min = j\n        lists[min], lists[i] = lists[i], lists[min]\n    return lists\n```\n\n![](http://hucoco.com/img/PythonSort/3.gif)\n\n## heap sort\n\n```\ndef adjust_heap(lists, i, size):\n    lchild = 2 * i + 1\n    rchild = 2 * i + 2\n    max = i\n    if i < size // 2:\n        if lchild < size and lists[lchild] > lists[max]:\n            max = lchild\n        if rchild < size and lists[rchild] > lists[max]:\n            max = rchild\n        if max != i:\n            lists[max], lists[i] = lists[i], lists[max]\n            adjust_heap(lists, max, size)\n \ndef build_heap(lists, size):\n    for i in range(0, (size//2))[::-1]:\n        adjust_heap(lists, i, size)\n \ndef heap_sort(lists):\n    size = len(lists)\n    build_heap(lists, size)\n    for i in range(0, size)[::-1]:\n        lists[0], lists[i] = lists[i], lists[0]\n        adjust_heap(lists, 0, i)\n```\n\n![](http://hucoco.com/img/PythonSort/4.gif)\n\n## Fast sorting\n\n```\ndef quick_sort(lists, left, right):\n    if left >= right:\n        return lists\n    key = lists[left]\n    low = left\n    high = right\n    while left < right:\n        while left < right and lists[right] >= key:\n            right -= 1\n        lists[left] = lists[right]\n        while left < right and lists[left] <= key:\n            left += 1\n        lists[right] = lists[left]\n    lists[right] = key\n    quick_sort(lists, low, left - 1)\n    quick_sort(lists, left + 1, high)\n    return lists\n```\n\n![]()\n\n## Merging sorting\n\n```\ndef merge(left, right):\n    i, j = 0, 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result += left[i:]\n    result += right[j:]\n    return result\n \ndef merge_sort(lists):\n    if len(lists) <= 1:\n        return lists\n    num = len(lists) // 2\n    left = merge_sort(lists[:num])\n    right = merge_sort(lists[num:])\n    return merge(left, right)\n```\n\n![](http://hucoco.com/img/PythonSort/6.gif)\n","source":"_posts/Sorting-Algorithm.md","raw":"---\ntitle: Sorting Algorithm\ndate: 2018-03-10 13:07:14\nthumbnail: http://hucoco.com/img/PythonSort/6.gif\ntags: \n- Python\n- Algorithm\n- Sort\ncategories:\n- Algorithm\n- Sort\n---\n\n# 8 Kind of Sorting Algorithm\n\n## Bubble sort\n\n```\ndef bubble_sort(lists):\n    count = len(lists)\n    for i in range(0, count):\n        for j in range(i + 1, count):\n            if lists[i] > lists[j]:\n                lists[i], lists[j] = lists[j], lists[i]\n    return lists\n```\n\n![](http://hucoco.com/img/PythonSort/2.gif)\n\n<!--more-->\n\n## Insertion sort\n\n```\ndef insert_sort(lists):\n    count = len(lists)\n    for i in range(1, count):\n        key = lists[i]\n        j = i - 1\n        while j >= 0:\n            if lists[j] > key:\n                lists[j + 1] = lists[j]\n                lists[j] = key\n            j -= 1\n    return lists\n```\n\n![]()\n\n## Shell Sort\n\n```\ndef shell_sort(lists):\n    count = len(lists)\n    step = 2\n    group = count // step\n    while group > 0:\n        for i in range(0, group):\n            j = i + group\n            while j < count:\n                k = j - group\n                key = lists[j]\n                while k >= 0:\n                    if lists[k] > key:\n                        lists[k + group] = lists[k]\n                        lists[k] = key\n                    k -= group\n                j += group\n        group //= step\n    return lists\n```\n\n![](http://hucoco.com/img/PythonSort/1.gif)\n\n## Selection Sort\n\n```\ndef select_sort(lists):\n    count = len(lists)\n    for i in range(0, count):\n        min = i\n        for j in range(i + 1, count):\n            if lists[min] > lists[j]:\n                min = j\n        lists[min], lists[i] = lists[i], lists[min]\n    return lists\n```\n\n![](http://hucoco.com/img/PythonSort/3.gif)\n\n## heap sort\n\n```\ndef adjust_heap(lists, i, size):\n    lchild = 2 * i + 1\n    rchild = 2 * i + 2\n    max = i\n    if i < size // 2:\n        if lchild < size and lists[lchild] > lists[max]:\n            max = lchild\n        if rchild < size and lists[rchild] > lists[max]:\n            max = rchild\n        if max != i:\n            lists[max], lists[i] = lists[i], lists[max]\n            adjust_heap(lists, max, size)\n \ndef build_heap(lists, size):\n    for i in range(0, (size//2))[::-1]:\n        adjust_heap(lists, i, size)\n \ndef heap_sort(lists):\n    size = len(lists)\n    build_heap(lists, size)\n    for i in range(0, size)[::-1]:\n        lists[0], lists[i] = lists[i], lists[0]\n        adjust_heap(lists, 0, i)\n```\n\n![](http://hucoco.com/img/PythonSort/4.gif)\n\n## Fast sorting\n\n```\ndef quick_sort(lists, left, right):\n    if left >= right:\n        return lists\n    key = lists[left]\n    low = left\n    high = right\n    while left < right:\n        while left < right and lists[right] >= key:\n            right -= 1\n        lists[left] = lists[right]\n        while left < right and lists[left] <= key:\n            left += 1\n        lists[right] = lists[left]\n    lists[right] = key\n    quick_sort(lists, low, left - 1)\n    quick_sort(lists, left + 1, high)\n    return lists\n```\n\n![]()\n\n## Merging sorting\n\n```\ndef merge(left, right):\n    i, j = 0, 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result += left[i:]\n    result += right[j:]\n    return result\n \ndef merge_sort(lists):\n    if len(lists) <= 1:\n        return lists\n    num = len(lists) // 2\n    left = merge_sort(lists[:num])\n    right = merge_sort(lists[num:])\n    return merge(left, right)\n```\n\n![](http://hucoco.com/img/PythonSort/6.gif)\n","slug":"Sorting-Algorithm","published":1,"updated":"2018-03-10T05:34:49.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36uc0011ssb97y60h5a5","content":"<h1 id=\"8-Kind-of-Sorting-Algorithm\"><a href=\"#8-Kind-of-Sorting-Algorithm\" class=\"headerlink\" title=\"8 Kind of Sorting Algorithm\"></a>8 Kind of Sorting Algorithm</h1><h2 id=\"Bubble-sort\"><a href=\"#Bubble-sort\" class=\"headerlink\" title=\"Bubble sort\"></a>Bubble sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def bubble_sort(lists):</span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    for i in range(0, count):</span><br><span class=\"line\">        for j in range(i + 1, count):</span><br><span class=\"line\">            if lists[i] &gt; lists[j]:</span><br><span class=\"line\">                lists[i], lists[j] = lists[j], lists[i]</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/2.gif\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"Insertion-sort\"><a href=\"#Insertion-sort\" class=\"headerlink\" title=\"Insertion sort\"></a>Insertion sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def insert_sort(lists):</span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    for i in range(1, count):</span><br><span class=\"line\">        key = lists[i]</span><br><span class=\"line\">        j = i - 1</span><br><span class=\"line\">        while j &gt;= 0:</span><br><span class=\"line\">            if lists[j] &gt; key:</span><br><span class=\"line\">                lists[j + 1] = lists[j]</span><br><span class=\"line\">                lists[j] = key</span><br><span class=\"line\">            j -= 1</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"\" alt=\"\"></p>\n<h2 id=\"Shell-Sort\"><a href=\"#Shell-Sort\" class=\"headerlink\" title=\"Shell Sort\"></a>Shell Sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def shell_sort(lists):</span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    step = 2</span><br><span class=\"line\">    group = count // step</span><br><span class=\"line\">    while group &gt; 0:</span><br><span class=\"line\">        for i in range(0, group):</span><br><span class=\"line\">            j = i + group</span><br><span class=\"line\">            while j &lt; count:</span><br><span class=\"line\">                k = j - group</span><br><span class=\"line\">                key = lists[j]</span><br><span class=\"line\">                while k &gt;= 0:</span><br><span class=\"line\">                    if lists[k] &gt; key:</span><br><span class=\"line\">                        lists[k + group] = lists[k]</span><br><span class=\"line\">                        lists[k] = key</span><br><span class=\"line\">                    k -= group</span><br><span class=\"line\">                j += group</span><br><span class=\"line\">        group //= step</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/1.gif\" alt=\"\"></p>\n<h2 id=\"Selection-Sort\"><a href=\"#Selection-Sort\" class=\"headerlink\" title=\"Selection Sort\"></a>Selection Sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def select_sort(lists):</span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    for i in range(0, count):</span><br><span class=\"line\">        min = i</span><br><span class=\"line\">        for j in range(i + 1, count):</span><br><span class=\"line\">            if lists[min] &gt; lists[j]:</span><br><span class=\"line\">                min = j</span><br><span class=\"line\">        lists[min], lists[i] = lists[i], lists[min]</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/3.gif\" alt=\"\"></p>\n<h2 id=\"heap-sort\"><a href=\"#heap-sort\" class=\"headerlink\" title=\"heap sort\"></a>heap sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def adjust_heap(lists, i, size):</span><br><span class=\"line\">    lchild = 2 * i + 1</span><br><span class=\"line\">    rchild = 2 * i + 2</span><br><span class=\"line\">    max = i</span><br><span class=\"line\">    if i &lt; size // 2:</span><br><span class=\"line\">        if lchild &lt; size and lists[lchild] &gt; lists[max]:</span><br><span class=\"line\">            max = lchild</span><br><span class=\"line\">        if rchild &lt; size and lists[rchild] &gt; lists[max]:</span><br><span class=\"line\">            max = rchild</span><br><span class=\"line\">        if max != i:</span><br><span class=\"line\">            lists[max], lists[i] = lists[i], lists[max]</span><br><span class=\"line\">            adjust_heap(lists, max, size)</span><br><span class=\"line\"> </span><br><span class=\"line\">def build_heap(lists, size):</span><br><span class=\"line\">    for i in range(0, (size//2))[::-1]:</span><br><span class=\"line\">        adjust_heap(lists, i, size)</span><br><span class=\"line\"> </span><br><span class=\"line\">def heap_sort(lists):</span><br><span class=\"line\">    size = len(lists)</span><br><span class=\"line\">    build_heap(lists, size)</span><br><span class=\"line\">    for i in range(0, size)[::-1]:</span><br><span class=\"line\">        lists[0], lists[i] = lists[i], lists[0]</span><br><span class=\"line\">        adjust_heap(lists, 0, i)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/4.gif\" alt=\"\"></p>\n<h2 id=\"Fast-sorting\"><a href=\"#Fast-sorting\" class=\"headerlink\" title=\"Fast sorting\"></a>Fast sorting</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def quick_sort(lists, left, right):</span><br><span class=\"line\">    if left &gt;= right:</span><br><span class=\"line\">        return lists</span><br><span class=\"line\">    key = lists[left]</span><br><span class=\"line\">    low = left</span><br><span class=\"line\">    high = right</span><br><span class=\"line\">    while left &lt; right:</span><br><span class=\"line\">        while left &lt; right and lists[right] &gt;= key:</span><br><span class=\"line\">            right -= 1</span><br><span class=\"line\">        lists[left] = lists[right]</span><br><span class=\"line\">        while left &lt; right and lists[left] &lt;= key:</span><br><span class=\"line\">            left += 1</span><br><span class=\"line\">        lists[right] = lists[left]</span><br><span class=\"line\">    lists[right] = key</span><br><span class=\"line\">    quick_sort(lists, low, left - 1)</span><br><span class=\"line\">    quick_sort(lists, left + 1, high)</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"\" alt=\"\"></p>\n<h2 id=\"Merging-sorting\"><a href=\"#Merging-sorting\" class=\"headerlink\" title=\"Merging sorting\"></a>Merging sorting</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def merge(left, right):</span><br><span class=\"line\">    i, j = 0, 0</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    while i &lt; len(left) and j &lt; len(right):</span><br><span class=\"line\">        if left[i] &lt;= right[j]:</span><br><span class=\"line\">            result.append(left[i])</span><br><span class=\"line\">            i += 1</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            result.append(right[j])</span><br><span class=\"line\">            j += 1</span><br><span class=\"line\">    result += left[i:]</span><br><span class=\"line\">    result += right[j:]</span><br><span class=\"line\">    return result</span><br><span class=\"line\"> </span><br><span class=\"line\">def merge_sort(lists):</span><br><span class=\"line\">    if len(lists) &lt;= 1:</span><br><span class=\"line\">        return lists</span><br><span class=\"line\">    num = len(lists) // 2</span><br><span class=\"line\">    left = merge_sort(lists[:num])</span><br><span class=\"line\">    right = merge_sort(lists[num:])</span><br><span class=\"line\">    return merge(left, right)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/6.gif\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"8-Kind-of-Sorting-Algorithm\"><a href=\"#8-Kind-of-Sorting-Algorithm\" class=\"headerlink\" title=\"8 Kind of Sorting Algorithm\"></a>8 Kind of Sorting Algorithm</h1><h2 id=\"Bubble-sort\"><a href=\"#Bubble-sort\" class=\"headerlink\" title=\"Bubble sort\"></a>Bubble sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def bubble_sort(lists):</span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    for i in range(0, count):</span><br><span class=\"line\">        for j in range(i + 1, count):</span><br><span class=\"line\">            if lists[i] &gt; lists[j]:</span><br><span class=\"line\">                lists[i], lists[j] = lists[j], lists[i]</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/2.gif\" alt=\"\"></p>","more":"<h2 id=\"Insertion-sort\"><a href=\"#Insertion-sort\" class=\"headerlink\" title=\"Insertion sort\"></a>Insertion sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def insert_sort(lists):</span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    for i in range(1, count):</span><br><span class=\"line\">        key = lists[i]</span><br><span class=\"line\">        j = i - 1</span><br><span class=\"line\">        while j &gt;= 0:</span><br><span class=\"line\">            if lists[j] &gt; key:</span><br><span class=\"line\">                lists[j + 1] = lists[j]</span><br><span class=\"line\">                lists[j] = key</span><br><span class=\"line\">            j -= 1</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"\" alt=\"\"></p>\n<h2 id=\"Shell-Sort\"><a href=\"#Shell-Sort\" class=\"headerlink\" title=\"Shell Sort\"></a>Shell Sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def shell_sort(lists):</span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    step = 2</span><br><span class=\"line\">    group = count // step</span><br><span class=\"line\">    while group &gt; 0:</span><br><span class=\"line\">        for i in range(0, group):</span><br><span class=\"line\">            j = i + group</span><br><span class=\"line\">            while j &lt; count:</span><br><span class=\"line\">                k = j - group</span><br><span class=\"line\">                key = lists[j]</span><br><span class=\"line\">                while k &gt;= 0:</span><br><span class=\"line\">                    if lists[k] &gt; key:</span><br><span class=\"line\">                        lists[k + group] = lists[k]</span><br><span class=\"line\">                        lists[k] = key</span><br><span class=\"line\">                    k -= group</span><br><span class=\"line\">                j += group</span><br><span class=\"line\">        group //= step</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/1.gif\" alt=\"\"></p>\n<h2 id=\"Selection-Sort\"><a href=\"#Selection-Sort\" class=\"headerlink\" title=\"Selection Sort\"></a>Selection Sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def select_sort(lists):</span><br><span class=\"line\">    count = len(lists)</span><br><span class=\"line\">    for i in range(0, count):</span><br><span class=\"line\">        min = i</span><br><span class=\"line\">        for j in range(i + 1, count):</span><br><span class=\"line\">            if lists[min] &gt; lists[j]:</span><br><span class=\"line\">                min = j</span><br><span class=\"line\">        lists[min], lists[i] = lists[i], lists[min]</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/3.gif\" alt=\"\"></p>\n<h2 id=\"heap-sort\"><a href=\"#heap-sort\" class=\"headerlink\" title=\"heap sort\"></a>heap sort</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def adjust_heap(lists, i, size):</span><br><span class=\"line\">    lchild = 2 * i + 1</span><br><span class=\"line\">    rchild = 2 * i + 2</span><br><span class=\"line\">    max = i</span><br><span class=\"line\">    if i &lt; size // 2:</span><br><span class=\"line\">        if lchild &lt; size and lists[lchild] &gt; lists[max]:</span><br><span class=\"line\">            max = lchild</span><br><span class=\"line\">        if rchild &lt; size and lists[rchild] &gt; lists[max]:</span><br><span class=\"line\">            max = rchild</span><br><span class=\"line\">        if max != i:</span><br><span class=\"line\">            lists[max], lists[i] = lists[i], lists[max]</span><br><span class=\"line\">            adjust_heap(lists, max, size)</span><br><span class=\"line\"> </span><br><span class=\"line\">def build_heap(lists, size):</span><br><span class=\"line\">    for i in range(0, (size//2))[::-1]:</span><br><span class=\"line\">        adjust_heap(lists, i, size)</span><br><span class=\"line\"> </span><br><span class=\"line\">def heap_sort(lists):</span><br><span class=\"line\">    size = len(lists)</span><br><span class=\"line\">    build_heap(lists, size)</span><br><span class=\"line\">    for i in range(0, size)[::-1]:</span><br><span class=\"line\">        lists[0], lists[i] = lists[i], lists[0]</span><br><span class=\"line\">        adjust_heap(lists, 0, i)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/4.gif\" alt=\"\"></p>\n<h2 id=\"Fast-sorting\"><a href=\"#Fast-sorting\" class=\"headerlink\" title=\"Fast sorting\"></a>Fast sorting</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def quick_sort(lists, left, right):</span><br><span class=\"line\">    if left &gt;= right:</span><br><span class=\"line\">        return lists</span><br><span class=\"line\">    key = lists[left]</span><br><span class=\"line\">    low = left</span><br><span class=\"line\">    high = right</span><br><span class=\"line\">    while left &lt; right:</span><br><span class=\"line\">        while left &lt; right and lists[right] &gt;= key:</span><br><span class=\"line\">            right -= 1</span><br><span class=\"line\">        lists[left] = lists[right]</span><br><span class=\"line\">        while left &lt; right and lists[left] &lt;= key:</span><br><span class=\"line\">            left += 1</span><br><span class=\"line\">        lists[right] = lists[left]</span><br><span class=\"line\">    lists[right] = key</span><br><span class=\"line\">    quick_sort(lists, low, left - 1)</span><br><span class=\"line\">    quick_sort(lists, left + 1, high)</span><br><span class=\"line\">    return lists</span><br></pre></td></tr></table></figure>\n<p><img src=\"\" alt=\"\"></p>\n<h2 id=\"Merging-sorting\"><a href=\"#Merging-sorting\" class=\"headerlink\" title=\"Merging sorting\"></a>Merging sorting</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def merge(left, right):</span><br><span class=\"line\">    i, j = 0, 0</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    while i &lt; len(left) and j &lt; len(right):</span><br><span class=\"line\">        if left[i] &lt;= right[j]:</span><br><span class=\"line\">            result.append(left[i])</span><br><span class=\"line\">            i += 1</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            result.append(right[j])</span><br><span class=\"line\">            j += 1</span><br><span class=\"line\">    result += left[i:]</span><br><span class=\"line\">    result += right[j:]</span><br><span class=\"line\">    return result</span><br><span class=\"line\"> </span><br><span class=\"line\">def merge_sort(lists):</span><br><span class=\"line\">    if len(lists) &lt;= 1:</span><br><span class=\"line\">        return lists</span><br><span class=\"line\">    num = len(lists) // 2</span><br><span class=\"line\">    left = merge_sort(lists[:num])</span><br><span class=\"line\">    right = merge_sort(lists[num:])</span><br><span class=\"line\">    return merge(left, right)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hucoco.com/img/PythonSort/6.gif\" alt=\"\"></p>"},{"title":"Theory of PBR","date":"2018-07-10T14:16:57.000Z","thumbnail":"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png","_content":"\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png)\n\n## Overview\n\nPBR (**Physically Base Rendering**) is a rendering technique that are more or less based on the same underlying theory which more closely matches that of the physical world. the biggest difference between the physical rendering model and the traditional rendering method is that it can more accurately describe and draw the interaction between the light and the surface of the object.\n\n<!--more-->\n\n## Diffusion and Reflection\n\nDiffusion and Reflection are two words that describe the most basic differences in light and surface interaction.\n\nWhen light hits the edge of the surface of the object, some of the light will reflect from the surface. On a smooth surface, which makes the surface looks like a mirror. **Specular Reflection** is often used to describe this effect.\n\nBut not all of light will reflect form the surface, Usually some light will penetrate into the inside of the object.\n\nIn this case, the light is either absorbed by the object (converted to heat) or scattered within the object. Some scattered light may return to the surface and be captured by the eye or camera. This is the well-known **Diffuse**.\n\nBy the way, Diffuse and Subsurface Scattering are all describe the same phenomenon.\n\nScattering is usually random in the direction, so **albedo** is a color that describes which color is most easily scattered back.\n\n## Translucency and Transparency\n\nIn some cases, diffuse reflections become more complicated—in materials with longer scattering distances, such as skin, wax, jade, and so on.In this case a simple color usually does not determine everything, and it also must consider the shape and thickness of the object.If these objects are thin enough, these objects usually have some light scattered from one surface and the nemitted from the other side. This phenomenon is called Translucent. If the scattering intensity is lower (such as glass), so that the scattered part is almost negligible, then the landscape on the other side of the object can directly enter the human eye through the object. This phenomenon is very far from the typical \"difficulty near the surface\" of the diffuse reflection, so a special shader is usually needed to simulate them.\n\n## Mircofacet Model\n\nAll the PBR techniques are based on the theory of microfacets. The theory describes that any surface at a microscopic scale can be described by tiny little perfectly reflective mirrors called microfacets. According to the roughness of a surface the alignment of these tiny little mirrors can differ quite a lot:\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_03.png)\n\nThe rougher a surface is, the more chaotically aligned each microfacet will be along the surface. The effect of these tiny-like mirror alignments is that when specifically talking about specular lighting/reflection the incoming light rays are more likely to scatter along completely different directions on rougher surfaces, resulting in a more widespread specular reflection. In contrast, on a smooth surface the light rays are more likely to reflect in roughly the same direction, giving us smaller and sharper reflections:\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_04.png)\n\n## Energy Conservation\n\nEnergy Conservation is describe a phenomenon: outgoing light energy should never exceed the incoming light energy (excluding emissive surfaces). \n\n![roughness increase form left to right](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_02.png)\n\nLooking at the above image we see the specular reflection area increase, but also its brightness decrease at increasing roughness levels. If the specular intensity were to be the same at each pixel regardless of the size of the specular shape the rougher surfaces would emit much more energy, violating the energy conservation principle. This is why we see specular reflections more intensely on smooth surfaces and more dimly on rough surfaces.\n\nFor energy conservation to hold we need to make a clear distinction between diffuse and specular light. The moment a light ray hits a surface, it gets split in both a refraction part and a reflection part. The reflection part is light that directly gets reflected and doesn't enter the surface; this is what we know as specular lighting. The refraction part is the remaining light that enters the surface and gets absorbed; this is what we know as diffuse lighting.\n\nFrom physics, we know that light can effectively be considered a beam of energy that keeps moving forward until it loses all of its energy, the way a light beam loses energy is by collision. Each material consists of tiny little particles that can collide with the light ray as illustrated below. The particles absorb some or all of the light's energy at each collision which is converted into heat.\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_01.png)\n\n## PBR materials\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png)\n\n**Albedo:** the albedo texture specifies for each texel the color of the surface, or the base reflectivity if that texel is metallic. This is largely similar to what we've been using before as a diffuse texture, but all lighting information is extracted from the texture. Diffuse textures often have slight shadows or darkened crevices inside the image which is something you don't want in an albedo texture; it should only contain the color (or refracted absorption coefficients) of the surface.\n\n**Normal:** the normal map texture is exactly as we've been using before in the normal mapping tutorial. The normal map allows us to specify per fragment a unique normal to give the illusion that a surface is bumpier than its flat counterpart.\n\n**Metallic:** the metallic map specifies per texel whether a texel is either metallic or it isn't. Based on how the PBR engine is set up, artists can author metalness as either grayscale values or as binary black or white.\n\n**Roughness:** the roughness map specifies how rough a surface is on a per texel basis. The sampled roughness value of the roughness influences the statistical microfacet orientations of the surface. A rougher surface gets wider and blurrier reflections, while a smooth surface gets focused and clear reflections. Some PBR engines expect a smoothness map instead of a roughness map which some artists find more intuitive, but these values get translated (1.0 - smoothness) to roughness the moment they're sampled.\n\n**AO:** the ambient occlusion or AO map specifies an extra shadowing factor of the surface and potentially surrounding geometry. If we have a brick surface for instance, the albedo texture should have no shadowing information inside the brick's crevices. The AO map however does specify these darkened edges as it's more difficult for light to escape. Taking ambient occlusion in account at the end of the lighting stage can significantly boost the visual quality of your scene. The ambient occlusion map of a mesh/surface is either manually generated or pre-calculated in 3D modeling programs.\n\n## Reference\n\n**[Learn OpenGL PBR Theory](https://learnopengl.com/PBR/Theory) **\n\n","source":"_posts/Theory-of-PBR.md","raw":"---\ntitle: Theory of PBR\ndate: 2018-07-10 22:16:57\nthumbnail: http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png\ntags: \n- Graphics\n- PBR\ncategories:\n- Graphics\n- PBR\n---\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png)\n\n## Overview\n\nPBR (**Physically Base Rendering**) is a rendering technique that are more or less based on the same underlying theory which more closely matches that of the physical world. the biggest difference between the physical rendering model and the traditional rendering method is that it can more accurately describe and draw the interaction between the light and the surface of the object.\n\n<!--more-->\n\n## Diffusion and Reflection\n\nDiffusion and Reflection are two words that describe the most basic differences in light and surface interaction.\n\nWhen light hits the edge of the surface of the object, some of the light will reflect from the surface. On a smooth surface, which makes the surface looks like a mirror. **Specular Reflection** is often used to describe this effect.\n\nBut not all of light will reflect form the surface, Usually some light will penetrate into the inside of the object.\n\nIn this case, the light is either absorbed by the object (converted to heat) or scattered within the object. Some scattered light may return to the surface and be captured by the eye or camera. This is the well-known **Diffuse**.\n\nBy the way, Diffuse and Subsurface Scattering are all describe the same phenomenon.\n\nScattering is usually random in the direction, so **albedo** is a color that describes which color is most easily scattered back.\n\n## Translucency and Transparency\n\nIn some cases, diffuse reflections become more complicated—in materials with longer scattering distances, such as skin, wax, jade, and so on.In this case a simple color usually does not determine everything, and it also must consider the shape and thickness of the object.If these objects are thin enough, these objects usually have some light scattered from one surface and the nemitted from the other side. This phenomenon is called Translucent. If the scattering intensity is lower (such as glass), so that the scattered part is almost negligible, then the landscape on the other side of the object can directly enter the human eye through the object. This phenomenon is very far from the typical \"difficulty near the surface\" of the diffuse reflection, so a special shader is usually needed to simulate them.\n\n## Mircofacet Model\n\nAll the PBR techniques are based on the theory of microfacets. The theory describes that any surface at a microscopic scale can be described by tiny little perfectly reflective mirrors called microfacets. According to the roughness of a surface the alignment of these tiny little mirrors can differ quite a lot:\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_03.png)\n\nThe rougher a surface is, the more chaotically aligned each microfacet will be along the surface. The effect of these tiny-like mirror alignments is that when specifically talking about specular lighting/reflection the incoming light rays are more likely to scatter along completely different directions on rougher surfaces, resulting in a more widespread specular reflection. In contrast, on a smooth surface the light rays are more likely to reflect in roughly the same direction, giving us smaller and sharper reflections:\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_04.png)\n\n## Energy Conservation\n\nEnergy Conservation is describe a phenomenon: outgoing light energy should never exceed the incoming light energy (excluding emissive surfaces). \n\n![roughness increase form left to right](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_02.png)\n\nLooking at the above image we see the specular reflection area increase, but also its brightness decrease at increasing roughness levels. If the specular intensity were to be the same at each pixel regardless of the size of the specular shape the rougher surfaces would emit much more energy, violating the energy conservation principle. This is why we see specular reflections more intensely on smooth surfaces and more dimly on rough surfaces.\n\nFor energy conservation to hold we need to make a clear distinction between diffuse and specular light. The moment a light ray hits a surface, it gets split in both a refraction part and a reflection part. The reflection part is light that directly gets reflected and doesn't enter the surface; this is what we know as specular lighting. The refraction part is the remaining light that enters the surface and gets absorbed; this is what we know as diffuse lighting.\n\nFrom physics, we know that light can effectively be considered a beam of energy that keeps moving forward until it loses all of its energy, the way a light beam loses energy is by collision. Each material consists of tiny little particles that can collide with the light ray as illustrated below. The particles absorb some or all of the light's energy at each collision which is converted into heat.\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_01.png)\n\n## PBR materials\n\n![](http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png)\n\n**Albedo:** the albedo texture specifies for each texel the color of the surface, or the base reflectivity if that texel is metallic. This is largely similar to what we've been using before as a diffuse texture, but all lighting information is extracted from the texture. Diffuse textures often have slight shadows or darkened crevices inside the image which is something you don't want in an albedo texture; it should only contain the color (or refracted absorption coefficients) of the surface.\n\n**Normal:** the normal map texture is exactly as we've been using before in the normal mapping tutorial. The normal map allows us to specify per fragment a unique normal to give the illusion that a surface is bumpier than its flat counterpart.\n\n**Metallic:** the metallic map specifies per texel whether a texel is either metallic or it isn't. Based on how the PBR engine is set up, artists can author metalness as either grayscale values or as binary black or white.\n\n**Roughness:** the roughness map specifies how rough a surface is on a per texel basis. The sampled roughness value of the roughness influences the statistical microfacet orientations of the surface. A rougher surface gets wider and blurrier reflections, while a smooth surface gets focused and clear reflections. Some PBR engines expect a smoothness map instead of a roughness map which some artists find more intuitive, but these values get translated (1.0 - smoothness) to roughness the moment they're sampled.\n\n**AO:** the ambient occlusion or AO map specifies an extra shadowing factor of the surface and potentially surrounding geometry. If we have a brick surface for instance, the albedo texture should have no shadowing information inside the brick's crevices. The AO map however does specify these darkened edges as it's more difficult for light to escape. Taking ambient occlusion in account at the end of the lighting stage can significantly boost the visual quality of your scene. The ambient occlusion map of a mesh/surface is either manually generated or pre-calculated in 3D modeling programs.\n\n## Reference\n\n**[Learn OpenGL PBR Theory](https://learnopengl.com/PBR/Theory) **\n\n","slug":"Theory-of-PBR","published":1,"updated":"2018-07-10T15:15:37.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36ud0015ssb9cibm6ndn","content":"<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png\" alt=\"\"></p>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>PBR (<strong>Physically Base Rendering</strong>) is a rendering technique that are more or less based on the same underlying theory which more closely matches that of the physical world. the biggest difference between the physical rendering model and the traditional rendering method is that it can more accurately describe and draw the interaction between the light and the surface of the object.</p>\n<a id=\"more\"></a>\n<h2 id=\"Diffusion-and-Reflection\"><a href=\"#Diffusion-and-Reflection\" class=\"headerlink\" title=\"Diffusion and Reflection\"></a>Diffusion and Reflection</h2><p>Diffusion and Reflection are two words that describe the most basic differences in light and surface interaction.</p>\n<p>When light hits the edge of the surface of the object, some of the light will reflect from the surface. On a smooth surface, which makes the surface looks like a mirror. <strong>Specular Reflection</strong> is often used to describe this effect.</p>\n<p>But not all of light will reflect form the surface, Usually some light will penetrate into the inside of the object.</p>\n<p>In this case, the light is either absorbed by the object (converted to heat) or scattered within the object. Some scattered light may return to the surface and be captured by the eye or camera. This is the well-known <strong>Diffuse</strong>.</p>\n<p>By the way, Diffuse and Subsurface Scattering are all describe the same phenomenon.</p>\n<p>Scattering is usually random in the direction, so <strong>albedo</strong> is a color that describes which color is most easily scattered back.</p>\n<h2 id=\"Translucency-and-Transparency\"><a href=\"#Translucency-and-Transparency\" class=\"headerlink\" title=\"Translucency and Transparency\"></a>Translucency and Transparency</h2><p>In some cases, diffuse reflections become more complicated—in materials with longer scattering distances, such as skin, wax, jade, and so on.In this case a simple color usually does not determine everything, and it also must consider the shape and thickness of the object.If these objects are thin enough, these objects usually have some light scattered from one surface and the nemitted from the other side. This phenomenon is called Translucent. If the scattering intensity is lower (such as glass), so that the scattered part is almost negligible, then the landscape on the other side of the object can directly enter the human eye through the object. This phenomenon is very far from the typical “difficulty near the surface” of the diffuse reflection, so a special shader is usually needed to simulate them.</p>\n<h2 id=\"Mircofacet-Model\"><a href=\"#Mircofacet-Model\" class=\"headerlink\" title=\"Mircofacet Model\"></a>Mircofacet Model</h2><p>All the PBR techniques are based on the theory of microfacets. The theory describes that any surface at a microscopic scale can be described by tiny little perfectly reflective mirrors called microfacets. According to the roughness of a surface the alignment of these tiny little mirrors can differ quite a lot:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_03.png\" alt=\"\"></p>\n<p>The rougher a surface is, the more chaotically aligned each microfacet will be along the surface. The effect of these tiny-like mirror alignments is that when specifically talking about specular lighting/reflection the incoming light rays are more likely to scatter along completely different directions on rougher surfaces, resulting in a more widespread specular reflection. In contrast, on a smooth surface the light rays are more likely to reflect in roughly the same direction, giving us smaller and sharper reflections:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_04.png\" alt=\"\"></p>\n<h2 id=\"Energy-Conservation\"><a href=\"#Energy-Conservation\" class=\"headerlink\" title=\"Energy Conservation\"></a>Energy Conservation</h2><p>Energy Conservation is describe a phenomenon: outgoing light energy should never exceed the incoming light energy (excluding emissive surfaces). </p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_02.png\" alt=\"roughness increase form left to right\"></p>\n<p>Looking at the above image we see the specular reflection area increase, but also its brightness decrease at increasing roughness levels. If the specular intensity were to be the same at each pixel regardless of the size of the specular shape the rougher surfaces would emit much more energy, violating the energy conservation principle. This is why we see specular reflections more intensely on smooth surfaces and more dimly on rough surfaces.</p>\n<p>For energy conservation to hold we need to make a clear distinction between diffuse and specular light. The moment a light ray hits a surface, it gets split in both a refraction part and a reflection part. The reflection part is light that directly gets reflected and doesn’t enter the surface; this is what we know as specular lighting. The refraction part is the remaining light that enters the surface and gets absorbed; this is what we know as diffuse lighting.</p>\n<p>From physics, we know that light can effectively be considered a beam of energy that keeps moving forward until it loses all of its energy, the way a light beam loses energy is by collision. Each material consists of tiny little particles that can collide with the light ray as illustrated below. The particles absorb some or all of the light’s energy at each collision which is converted into heat.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_01.png\" alt=\"\"></p>\n<h2 id=\"PBR-materials\"><a href=\"#PBR-materials\" class=\"headerlink\" title=\"PBR materials\"></a>PBR materials</h2><p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png\" alt=\"\"></p>\n<p><strong>Albedo:</strong> the albedo texture specifies for each texel the color of the surface, or the base reflectivity if that texel is metallic. This is largely similar to what we’ve been using before as a diffuse texture, but all lighting information is extracted from the texture. Diffuse textures often have slight shadows or darkened crevices inside the image which is something you don’t want in an albedo texture; it should only contain the color (or refracted absorption coefficients) of the surface.</p>\n<p><strong>Normal:</strong> the normal map texture is exactly as we’ve been using before in the normal mapping tutorial. The normal map allows us to specify per fragment a unique normal to give the illusion that a surface is bumpier than its flat counterpart.</p>\n<p><strong>Metallic:</strong> the metallic map specifies per texel whether a texel is either metallic or it isn’t. Based on how the PBR engine is set up, artists can author metalness as either grayscale values or as binary black or white.</p>\n<p><strong>Roughness:</strong> the roughness map specifies how rough a surface is on a per texel basis. The sampled roughness value of the roughness influences the statistical microfacet orientations of the surface. A rougher surface gets wider and blurrier reflections, while a smooth surface gets focused and clear reflections. Some PBR engines expect a smoothness map instead of a roughness map which some artists find more intuitive, but these values get translated (1.0 - smoothness) to roughness the moment they’re sampled.</p>\n<p><strong>AO:</strong> the ambient occlusion or AO map specifies an extra shadowing factor of the surface and potentially surrounding geometry. If we have a brick surface for instance, the albedo texture should have no shadowing information inside the brick’s crevices. The AO map however does specify these darkened edges as it’s more difficult for light to escape. Taking ambient occlusion in account at the end of the lighting stage can significantly boost the visual quality of your scene. The ambient occlusion map of a mesh/surface is either manually generated or pre-calculated in 3D modeling programs.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/PBR/Theory\" target=\"_blank\" rel=\"noopener\">Learn OpenGL PBR Theory</a> </strong></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png\" alt=\"\"></p>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>PBR (<strong>Physically Base Rendering</strong>) is a rendering technique that are more or less based on the same underlying theory which more closely matches that of the physical world. the biggest difference between the physical rendering model and the traditional rendering method is that it can more accurately describe and draw the interaction between the light and the surface of the object.</p>","more":"<h2 id=\"Diffusion-and-Reflection\"><a href=\"#Diffusion-and-Reflection\" class=\"headerlink\" title=\"Diffusion and Reflection\"></a>Diffusion and Reflection</h2><p>Diffusion and Reflection are two words that describe the most basic differences in light and surface interaction.</p>\n<p>When light hits the edge of the surface of the object, some of the light will reflect from the surface. On a smooth surface, which makes the surface looks like a mirror. <strong>Specular Reflection</strong> is often used to describe this effect.</p>\n<p>But not all of light will reflect form the surface, Usually some light will penetrate into the inside of the object.</p>\n<p>In this case, the light is either absorbed by the object (converted to heat) or scattered within the object. Some scattered light may return to the surface and be captured by the eye or camera. This is the well-known <strong>Diffuse</strong>.</p>\n<p>By the way, Diffuse and Subsurface Scattering are all describe the same phenomenon.</p>\n<p>Scattering is usually random in the direction, so <strong>albedo</strong> is a color that describes which color is most easily scattered back.</p>\n<h2 id=\"Translucency-and-Transparency\"><a href=\"#Translucency-and-Transparency\" class=\"headerlink\" title=\"Translucency and Transparency\"></a>Translucency and Transparency</h2><p>In some cases, diffuse reflections become more complicated—in materials with longer scattering distances, such as skin, wax, jade, and so on.In this case a simple color usually does not determine everything, and it also must consider the shape and thickness of the object.If these objects are thin enough, these objects usually have some light scattered from one surface and the nemitted from the other side. This phenomenon is called Translucent. If the scattering intensity is lower (such as glass), so that the scattered part is almost negligible, then the landscape on the other side of the object can directly enter the human eye through the object. This phenomenon is very far from the typical “difficulty near the surface” of the diffuse reflection, so a special shader is usually needed to simulate them.</p>\n<h2 id=\"Mircofacet-Model\"><a href=\"#Mircofacet-Model\" class=\"headerlink\" title=\"Mircofacet Model\"></a>Mircofacet Model</h2><p>All the PBR techniques are based on the theory of microfacets. The theory describes that any surface at a microscopic scale can be described by tiny little perfectly reflective mirrors called microfacets. According to the roughness of a surface the alignment of these tiny little mirrors can differ quite a lot:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_03.png\" alt=\"\"></p>\n<p>The rougher a surface is, the more chaotically aligned each microfacet will be along the surface. The effect of these tiny-like mirror alignments is that when specifically talking about specular lighting/reflection the incoming light rays are more likely to scatter along completely different directions on rougher surfaces, resulting in a more widespread specular reflection. In contrast, on a smooth surface the light rays are more likely to reflect in roughly the same direction, giving us smaller and sharper reflections:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_04.png\" alt=\"\"></p>\n<h2 id=\"Energy-Conservation\"><a href=\"#Energy-Conservation\" class=\"headerlink\" title=\"Energy Conservation\"></a>Energy Conservation</h2><p>Energy Conservation is describe a phenomenon: outgoing light energy should never exceed the incoming light energy (excluding emissive surfaces). </p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_02.png\" alt=\"roughness increase form left to right\"></p>\n<p>Looking at the above image we see the specular reflection area increase, but also its brightness decrease at increasing roughness levels. If the specular intensity were to be the same at each pixel regardless of the size of the specular shape the rougher surfaces would emit much more energy, violating the energy conservation principle. This is why we see specular reflections more intensely on smooth surfaces and more dimly on rough surfaces.</p>\n<p>For energy conservation to hold we need to make a clear distinction between diffuse and specular light. The moment a light ray hits a surface, it gets split in both a refraction part and a reflection part. The reflection part is light that directly gets reflected and doesn’t enter the surface; this is what we know as specular lighting. The refraction part is the remaining light that enters the surface and gets absorbed; this is what we know as diffuse lighting.</p>\n<p>From physics, we know that light can effectively be considered a beam of energy that keeps moving forward until it loses all of its energy, the way a light beam loses energy is by collision. Each material consists of tiny little particles that can collide with the light ray as illustrated below. The particles absorb some or all of the light’s energy at each collision which is converted into heat.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_01.png\" alt=\"\"></p>\n<h2 id=\"PBR-materials\"><a href=\"#PBR-materials\" class=\"headerlink\" title=\"PBR materials\"></a>PBR materials</h2><p><img src=\"http://hucoco.com/img/Graphics/PBR/Threoy_of_PBR_00.png\" alt=\"\"></p>\n<p><strong>Albedo:</strong> the albedo texture specifies for each texel the color of the surface, or the base reflectivity if that texel is metallic. This is largely similar to what we’ve been using before as a diffuse texture, but all lighting information is extracted from the texture. Diffuse textures often have slight shadows or darkened crevices inside the image which is something you don’t want in an albedo texture; it should only contain the color (or refracted absorption coefficients) of the surface.</p>\n<p><strong>Normal:</strong> the normal map texture is exactly as we’ve been using before in the normal mapping tutorial. The normal map allows us to specify per fragment a unique normal to give the illusion that a surface is bumpier than its flat counterpart.</p>\n<p><strong>Metallic:</strong> the metallic map specifies per texel whether a texel is either metallic or it isn’t. Based on how the PBR engine is set up, artists can author metalness as either grayscale values or as binary black or white.</p>\n<p><strong>Roughness:</strong> the roughness map specifies how rough a surface is on a per texel basis. The sampled roughness value of the roughness influences the statistical microfacet orientations of the surface. A rougher surface gets wider and blurrier reflections, while a smooth surface gets focused and clear reflections. Some PBR engines expect a smoothness map instead of a roughness map which some artists find more intuitive, but these values get translated (1.0 - smoothness) to roughness the moment they’re sampled.</p>\n<p><strong>AO:</strong> the ambient occlusion or AO map specifies an extra shadowing factor of the surface and potentially surrounding geometry. If we have a brick surface for instance, the albedo texture should have no shadowing information inside the brick’s crevices. The AO map however does specify these darkened edges as it’s more difficult for light to escape. Taking ambient occlusion in account at the end of the lighting stage can significantly boost the visual quality of your scene. The ambient occlusion map of a mesh/surface is either manually generated or pre-calculated in 3D modeling programs.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/PBR/Theory\" target=\"_blank\" rel=\"noopener\">Learn OpenGL PBR Theory</a> </strong></p>"},{"title":"Topological Sort","date":"2018-03-08T12:14:15.000Z","thumbnail":"http://hucoco.com/img/Graph/Topological%20Order.png","_content":"\n[Topological Sort Chinese version address](http://hucoco.coding.me/2016/11/24/Graph/TopologicalOrder/)\n\n# Topological Sort\n\n## Overview\n\nTopological sorting means ordering a Directed Acyclic Graph(DAG) to get an ordered linear sequence.\n\nIn this way, it may be understood more abstractly.\n\nFor example, a project consists of four subsections A, B, C, and D, and A depends on B and D. C depends on D. Now to develop a plan to write A, B, C, D the order of execution. At this point, you can use topological sorting, which is used to determine the order in which things happen.\n\nIn topological sorting, if there is a path from the vertex A to the vertex B, B appears behind the A in the ranking result.\n\n## Algorithm Introduction\n\n1. Create a queue Q and a topological ordered result queue T.\n2. Put all the nodes that do not depend on the vertex in the Q.\n3. When Q has vertices, perform the following steps.\n\t1. Take a vertex n from Q (delete n from Q) and put it in T (add n to the result set).\n\t2. For every adjacent point m (n is the starting point and m is the ending point).\n\t\t1. Remove the edge (n, m).\n\t\t2. If m does not depend on the vertex, put b into Q.\n\n> The vertex A does not depend on the vertex, which means there is no edge to the end of the A.\n\n<!--more-->\n\n![Sample Graph](http://hucoco.com/img/Graph/Topological%20Order.png)\n\nThe above diagram is an example of a demonstration of the topological sort.\n\n![Step One](http://hucoco.com/img/Graph/Topological%20Order%201.png)\n\n![Step Two](http://hucoco.com/img/Graph/Topological%20Order%202.png)\n\n![Step Three](http://hucoco.com/img/Graph/Topological%20Order%203.png)\n\n1. Add B and C to the sorting result.\n\n\tVertex B and vertex C are not dependent on the vertices, so C and C added to the result set T. Suppose ABCDEFG is stored sequentially, so visit B first and then C again. After accessing B, remove the edges (B, A) and (B, D) and add A and D to the queue Q. Similarly, remove the edges (C, F) and (C, G) and add F and G to Q.\n\n\tAdd B to the sorted result, and then remove the edges (B, A) and (B, D); at this point, since A and D do not depend on vertices, add A and D to queue Q.\n\n\tThe C is added to the sorting result, then the edge (C, F) and (C, G) are removed; at this time, since F has a dependency on the vertex D, G has a dependency on the vertex A, so it does not handle F and G.\n\n2. A, D is added to the sorting result in turn.\n\n\tAfter the first step, both A and D are not dependent on the vertex, accessing the A first and then accessing the D according to the storage order. After the access, the edges of the vertex A and the vertex D are deleted.\n\n3. Add E, F, G to the sorting result.\n\n\n## C++ Implementation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```\n\n\n\n\n","source":"_posts/Topological-Sort.md","raw":"---\ntitle: Topological Sort\ndate: 2018-03-08 20:14:15\nthumbnail: http://hucoco.com/img/Graph/Topological%20Order.png\ntags: \n- C++\n- Algorithm\n- Graph\ncategories:\n- Algorithm\n- Sort\n---\n\n[Topological Sort Chinese version address](http://hucoco.coding.me/2016/11/24/Graph/TopologicalOrder/)\n\n# Topological Sort\n\n## Overview\n\nTopological sorting means ordering a Directed Acyclic Graph(DAG) to get an ordered linear sequence.\n\nIn this way, it may be understood more abstractly.\n\nFor example, a project consists of four subsections A, B, C, and D, and A depends on B and D. C depends on D. Now to develop a plan to write A, B, C, D the order of execution. At this point, you can use topological sorting, which is used to determine the order in which things happen.\n\nIn topological sorting, if there is a path from the vertex A to the vertex B, B appears behind the A in the ranking result.\n\n## Algorithm Introduction\n\n1. Create a queue Q and a topological ordered result queue T.\n2. Put all the nodes that do not depend on the vertex in the Q.\n3. When Q has vertices, perform the following steps.\n\t1. Take a vertex n from Q (delete n from Q) and put it in T (add n to the result set).\n\t2. For every adjacent point m (n is the starting point and m is the ending point).\n\t\t1. Remove the edge (n, m).\n\t\t2. If m does not depend on the vertex, put b into Q.\n\n> The vertex A does not depend on the vertex, which means there is no edge to the end of the A.\n\n<!--more-->\n\n![Sample Graph](http://hucoco.com/img/Graph/Topological%20Order.png)\n\nThe above diagram is an example of a demonstration of the topological sort.\n\n![Step One](http://hucoco.com/img/Graph/Topological%20Order%201.png)\n\n![Step Two](http://hucoco.com/img/Graph/Topological%20Order%202.png)\n\n![Step Three](http://hucoco.com/img/Graph/Topological%20Order%203.png)\n\n1. Add B and C to the sorting result.\n\n\tVertex B and vertex C are not dependent on the vertices, so C and C added to the result set T. Suppose ABCDEFG is stored sequentially, so visit B first and then C again. After accessing B, remove the edges (B, A) and (B, D) and add A and D to the queue Q. Similarly, remove the edges (C, F) and (C, G) and add F and G to Q.\n\n\tAdd B to the sorted result, and then remove the edges (B, A) and (B, D); at this point, since A and D do not depend on vertices, add A and D to queue Q.\n\n\tThe C is added to the sorting result, then the edge (C, F) and (C, G) are removed; at this time, since F has a dependency on the vertex D, G has a dependency on the vertex A, so it does not handle F and G.\n\n2. A, D is added to the sorting result in turn.\n\n\tAfter the first step, both A and D are not dependent on the vertex, accessing the A first and then accessing the D according to the storage order. After the access, the edges of the vertex A and the vertex D are deleted.\n\n3. Add E, F, G to the sorting result.\n\n\n## C++ Implementation\n\n##### Adjacency Matrix Version\n\n```\n// Work in progress \n```\n\n##### Adjacency List Version\n\n```\n// Work in progress \n```\n\n\n\n\n","slug":"Topological-Sort","published":1,"updated":"2018-03-08T12:43:16.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36uf0019ssb9ow0wveuw","content":"<p><a href=\"http://hucoco.coding.me/2016/11/24/Graph/TopologicalOrder/\" target=\"_blank\" rel=\"noopener\">Topological Sort Chinese version address</a></p>\n<h1 id=\"Topological-Sort\"><a href=\"#Topological-Sort\" class=\"headerlink\" title=\"Topological Sort\"></a>Topological Sort</h1><h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>Topological sorting means ordering a Directed Acyclic Graph(DAG) to get an ordered linear sequence.</p>\n<p>In this way, it may be understood more abstractly.</p>\n<p>For example, a project consists of four subsections A, B, C, and D, and A depends on B and D. C depends on D. Now to develop a plan to write A, B, C, D the order of execution. At this point, you can use topological sorting, which is used to determine the order in which things happen.</p>\n<p>In topological sorting, if there is a path from the vertex A to the vertex B, B appears behind the A in the ranking result.</p>\n<h2 id=\"Algorithm-Introduction\"><a href=\"#Algorithm-Introduction\" class=\"headerlink\" title=\"Algorithm Introduction\"></a>Algorithm Introduction</h2><ol>\n<li>Create a queue Q and a topological ordered result queue T.</li>\n<li>Put all the nodes that do not depend on the vertex in the Q.</li>\n<li>When Q has vertices, perform the following steps.<ol>\n<li>Take a vertex n from Q (delete n from Q) and put it in T (add n to the result set).</li>\n<li>For every adjacent point m (n is the starting point and m is the ending point).<ol>\n<li>Remove the edge (n, m).</li>\n<li>If m does not depend on the vertex, put b into Q.</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>The vertex A does not depend on the vertex, which means there is no edge to the end of the A.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"http://hucoco.com/img/Graph/Topological%20Order.png\" alt=\"Sample Graph\"></p>\n<p>The above diagram is an example of a demonstration of the topological sort.</p>\n<p><img src=\"http://hucoco.com/img/Graph/Topological%20Order%201.png\" alt=\"Step One\"></p>\n<p><img src=\"http://hucoco.com/img/Graph/Topological%20Order%202.png\" alt=\"Step Two\"></p>\n<p><img src=\"http://hucoco.com/img/Graph/Topological%20Order%203.png\" alt=\"Step Three\"></p>\n<ol>\n<li><p>Add B and C to the sorting result.</p>\n<p> Vertex B and vertex C are not dependent on the vertices, so C and C added to the result set T. Suppose ABCDEFG is stored sequentially, so visit B first and then C again. After accessing B, remove the edges (B, A) and (B, D) and add A and D to the queue Q. Similarly, remove the edges (C, F) and (C, G) and add F and G to Q.</p>\n<p> Add B to the sorted result, and then remove the edges (B, A) and (B, D); at this point, since A and D do not depend on vertices, add A and D to queue Q.</p>\n<p> The C is added to the sorting result, then the edge (C, F) and (C, G) are removed; at this time, since F has a dependency on the vertex D, G has a dependency on the vertex A, so it does not handle F and G.</p>\n</li>\n<li><p>A, D is added to the sorting result in turn.</p>\n<p> After the first step, both A and D are not dependent on the vertex, accessing the A first and then accessing the D according to the storage order. After the access, the edges of the vertex A and the vertex D are deleted.</p>\n</li>\n<li><p>Add E, F, G to the sorting result.</p>\n</li>\n</ol>\n<h2 id=\"C-Implementation\"><a href=\"#C-Implementation\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h2><h5 id=\"Adjacency-Matrix-Version\"><a href=\"#Adjacency-Matrix-Version\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version\"><a href=\"#Adjacency-List-Version\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://hucoco.coding.me/2016/11/24/Graph/TopologicalOrder/\" target=\"_blank\" rel=\"noopener\">Topological Sort Chinese version address</a></p>\n<h1 id=\"Topological-Sort\"><a href=\"#Topological-Sort\" class=\"headerlink\" title=\"Topological Sort\"></a>Topological Sort</h1><h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>Topological sorting means ordering a Directed Acyclic Graph(DAG) to get an ordered linear sequence.</p>\n<p>In this way, it may be understood more abstractly.</p>\n<p>For example, a project consists of four subsections A, B, C, and D, and A depends on B and D. C depends on D. Now to develop a plan to write A, B, C, D the order of execution. At this point, you can use topological sorting, which is used to determine the order in which things happen.</p>\n<p>In topological sorting, if there is a path from the vertex A to the vertex B, B appears behind the A in the ranking result.</p>\n<h2 id=\"Algorithm-Introduction\"><a href=\"#Algorithm-Introduction\" class=\"headerlink\" title=\"Algorithm Introduction\"></a>Algorithm Introduction</h2><ol>\n<li>Create a queue Q and a topological ordered result queue T.</li>\n<li>Put all the nodes that do not depend on the vertex in the Q.</li>\n<li>When Q has vertices, perform the following steps.<ol>\n<li>Take a vertex n from Q (delete n from Q) and put it in T (add n to the result set).</li>\n<li>For every adjacent point m (n is the starting point and m is the ending point).<ol>\n<li>Remove the edge (n, m).</li>\n<li>If m does not depend on the vertex, put b into Q.</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>The vertex A does not depend on the vertex, which means there is no edge to the end of the A.</p>\n</blockquote>","more":"<p><img src=\"http://hucoco.com/img/Graph/Topological%20Order.png\" alt=\"Sample Graph\"></p>\n<p>The above diagram is an example of a demonstration of the topological sort.</p>\n<p><img src=\"http://hucoco.com/img/Graph/Topological%20Order%201.png\" alt=\"Step One\"></p>\n<p><img src=\"http://hucoco.com/img/Graph/Topological%20Order%202.png\" alt=\"Step Two\"></p>\n<p><img src=\"http://hucoco.com/img/Graph/Topological%20Order%203.png\" alt=\"Step Three\"></p>\n<ol>\n<li><p>Add B and C to the sorting result.</p>\n<p> Vertex B and vertex C are not dependent on the vertices, so C and C added to the result set T. Suppose ABCDEFG is stored sequentially, so visit B first and then C again. After accessing B, remove the edges (B, A) and (B, D) and add A and D to the queue Q. Similarly, remove the edges (C, F) and (C, G) and add F and G to Q.</p>\n<p> Add B to the sorted result, and then remove the edges (B, A) and (B, D); at this point, since A and D do not depend on vertices, add A and D to queue Q.</p>\n<p> The C is added to the sorting result, then the edge (C, F) and (C, G) are removed; at this time, since F has a dependency on the vertex D, G has a dependency on the vertex A, so it does not handle F and G.</p>\n</li>\n<li><p>A, D is added to the sorting result in turn.</p>\n<p> After the first step, both A and D are not dependent on the vertex, accessing the A first and then accessing the D according to the storage order. After the access, the edges of the vertex A and the vertex D are deleted.</p>\n</li>\n<li><p>Add E, F, G to the sorting result.</p>\n</li>\n</ol>\n<h2 id=\"C-Implementation\"><a href=\"#C-Implementation\" class=\"headerlink\" title=\"C++ Implementation\"></a>C++ Implementation</h2><h5 id=\"Adjacency-Matrix-Version\"><a href=\"#Adjacency-Matrix-Version\" class=\"headerlink\" title=\"Adjacency Matrix Version\"></a>Adjacency Matrix Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>\n<h5 id=\"Adjacency-List-Version\"><a href=\"#Adjacency-List-Version\" class=\"headerlink\" title=\"Adjacency List Version\"></a>Adjacency List Version</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Work in progress</span><br></pre></td></tr></table></figure>"},{"title":"Various surfaces","date":"2018-07-06T15:28:40.000Z","thumbnail":"http://hucoco.com/img/Graphics/RayTracing/RayTracing_0.png","mathjax":true,"_content":"\n## Ray-Plane Intersection\n\nPlane is often represented in implicit form :\n\n$$Ax + By + Cz + D = 0$$\n\nEquivalent:\n\n$$N \\cdot P + D = 0$$ \n\nwhere $N = [A B C]^T$ and $P = [x y z]^T$\n\nTo find ray-plane intersection, substitute ray equation $P(t)$ into plane equation:\n\n1. We get $N \\cdot P + D = 0$.\n2. Sovle for $t$ to get $t_0$.\n3. if $t_0$ is infinity, no intersection (ray is parallel to plane).\n4. Intersection point is $P(t_0)$.\n5. Verify that intersection is not behind ray origin.\n\nThe normal at the intersection is $N$ (or $-N$)\n\n<!--more-->\n\n```c++\nbool Plane::hit( const Ray &r, double tmin, double tmax, SurfaceHitRecord &rec ) const \n{\n\tVector3d N( A, B, C );\n\tdouble NRd = dot( N, r.direction() );\n\tdouble NRo = dot( N, r.origin() );\n\tdouble t = (-D - NRo) / NRd;\n\tif ( t < tmin || t > tmax ) \n\t{\n\t\treturn false;\n\t}\n\trec.t = t;\n\trec.p = r.pointAtParam(t);\n\trec.normal = N;\n\trec.mat_ptr = matp;\n\treturn true;\n}\n```\n\n## Ray-Sphere Intersection\n\nSphere (centered at origin) is often represented in implicit form:\n\n$$x^2 + y^2 + z^2 - r^2 = 0$$\n\nEquivalent:\n\n$$P \\cdot P - r^2 = 0$$\n\nTo find ray-plane intersection, substitute ray equation P(t) into plane equation:\n\nWe get $P \\cdot P - r^2 = 0$:\n\n$$P(t) \\cdot P(t) - r^2 = 0$$\n\n$$(R_o + tR_d) \\cdot (R_o + tR_d) - r^2 = 0$$\n\n$$R_d \\cdot R_dt^2 + 2R_d \\cdot R_o + R_o \\cdot R_o - r^2 = 0$$\n\n$R_o$ is ray origin, $R_d$ is ray direction.\n\nIt is a quadratic equation in the form $at^2 + bt + c = 0$\n\n* $a = R_o \\cdot R_o = 1$ (Since $|R_d| = 1$)\n* $b = 2R_d \\cdot R_o$\n* $c = R_o \\cdot R_o - r^2$\n\nDiscriminant: $d = b^2 + 4ac$\n\nSolution: $t_\\pm = \\frac{-b\\pm\\sqrt{b^2 + 4ac}}{2a}$\n\nChoose $t_0$ as the closest positive $t$ value ($t_+$ + or $t_-$)\n\nThe normal at the intersection point is $P(t_0)/|P(t_0)|$\n\nVery easy to compute, that is why most ray tracing images have spheres.\n\n```c++\nbool Sphere::hit( const Ray &r, double tmin, double tmax, SurfaceHitRecord &rec ) const \n{\n    Vector3d Rd = r.direction();\n    Vector3d Ro = r.origin() - center;\n    double a = dot(Rd,Rd);\n    double b = 2.0 * dot(Rd, Ro);\n    double c = dot(Ro,Ro) - pow(radius, 2);\n    double d = pow(b, 2) - 4.0 * a * c;\n    if(d < 0)\n    {\n        return false;\n    }\n    double t = (-b - sqrt(d)) / (2.0f * a);\n    if ( t >= tmin && t <= tmax )\n    {\n        rec.t = t ;\n        rec.p = r.pointAtParam(t);\n        rec.normal = (Ro + t * Rd) / radius;\n        rec.mat_ptr = matp;\n        return true;\n    }\n    return false;\n}\n```\n\n## Ray-Box Intersection\n\nTo find ray-box intersection:\n\n* For each pair of parallel plane, find the distance to the first plane ($t_{near}$) and to the second plane ($t_{far}$).\n* Keep the largest $t_{near}$ so far, and smallest $t_{far}$ so far.\n* If largest $t_{near}$ > smallest $t_{far}$ , no intersection.\n* Otherwise, the intersection is at P(largest $t_{near}$ )\n\n![](http://hucoco.com/img/Graphics/RayTracing/Ray_box_Intersection_00.png)\n\n## Ray-Triangle Intersection\n\nFinding intersection between a ray and a general polygon is difficult.\n\n* Compute ray-plane intersection\n* Determine whether intersection is within polygon\n\t* Tedious for non-convex polygon\n* Interpolation of attributes at the vertices are not well-\ndefined\n\nMuch easier to find ray-triangle intersection\n\n* Can use the **barycentric coordinates** method.\n* Interpolation of attributes at the vertices are well-defined using the barycentric coordinates.\n\n```c++\nbool Triangle::hit( const Ray &r, double tmin, double tmax, SurfaceHitRecord &rec ) const \n{\n\tdouble A = v0.x() - v1.x();\n\tdouble B = v0.y() - v1.y();\n\tdouble C = v0.z() - v1.z();\n\n\tdouble D = v0.x() - v2.x();\n\tdouble E = v0.y() - v2.y();\n\tdouble F = v0.z() - v2.z();\n\n\tdouble G = r.direction().x();\n\tdouble H = r.direction().y();\n\tdouble I = r.direction().z();\n\n\tdouble J = v0.x() - r.origin().x();\n\tdouble K = v0.y() - r.origin().y();\n\tdouble L = v0.z() - r.origin().z();\n\n\tdouble EIHF = E*I - H*F;\n\tdouble GFDI = G*F - D*I;\n\tdouble DHEG = D*H - E*G;\n\n\tdouble denom = (A*EIHF + B*GFDI + C*DHEG);\n\n\tdouble beta = (J*EIHF + K*GFDI + L*DHEG) / denom;\n\n\tif ( beta < 0.0 || beta > 1.0 ) return false;\n\n\tdouble AKJB = A*K - J*B;\n\tdouble JCAL = J*C - A*L;\n\tdouble BLKC = B*L - K*C;\n\n\tdouble gamma = (I*AKJB + H*JCAL + G*BLKC) / denom;\n\n\tif ( gamma < 0.0 || beta + gamma > 1.0 ) return false;\n\n\tdouble t = -(F*AKJB + E*JCAL + D*BLKC) / denom;\n\n\tif ( t >= tmin && t <= tmax )\n\t{\n\t\t// We have a hit -- populat hit record. \n\t\trec.t = t;\n\t\trec.p = r.pointAtParam(t);\n\t\tdouble alpha = 1.0 - beta - gamma;\n\t\trec.normal = alpha * n0 + beta * n1 + gamma * n2;\n\t\trec.mat_ptr = matp;\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n### Barycentric Coordinates\n\nThe barycentric coordinates of a point P on a triangle $ABC$ is ($ \\alpha $, $ \\beta $, $ \\gamma $) such that:\n\n$$P = \\alpha A + \\beta B + \\gamma C $$ \n\nwhere\n\n$$ \\alpha + \\beta + \\gamma = 1$$\n\nand \n\n$$ 0 \\leq \\alpha,\\beta,\\gamma \\leq 1$$\n\nWe can rewrite it as:\n\n$$P = (1 - \\beta - \\gamma)A + \\beta B + \\gamma C$$\n\n$$P = A + \\beta(B-A) + \\gamma(C-A)$$\n\n![](http://hucoco.com/img/Graphics/RayTracing/Ray_triangle_Intersection_00.png)\n\nTo find ray-triangle intersection, we let:\n\n$$P(t) = A + \\beta(B-A) + \\gamma(C-A)$$\n\n$$R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)$$\n\nSolve for $t$, $\\beta$ and $\\gamma$\n\nIntersection if $\\beta + \\gamma < 1$ and $\\beta,\\gamma > 0$ and $t > 0$\n\nExpand &R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)&\n\n$$\\begin{cases}\nR_{ox} + tR_{dx} = A_x + \\beta(B_x-A_x) + \\gamma(C_x + A_x) \\\\\nR_{oy} + tR_{dy} = A_y + \\beta(B_y-A_y) + \\gamma(C_y + A_y) \\\\\nR_{oz} + tR_{dz} = A_z + \\beta(B_z-A_z) + \\gamma(C_z + A_z) \\\\\n\\end{cases}$$\n\nwe have 3 equations and 3 unknowns here.\n\nRegroup and write in matrix form\n\n$$\n\\begin{bmatrix}\nA_x - B_x &A_x - C_x &R_{dx}\\\\ \nA_y - B_y &A_y - C_y &R_{dy}\\\\ \nA_z - B_z &A_z - C_z &R_{dz}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\beta \\\\\n\\gamma \\\\\nt\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA_x - R_{ox} \\\\\nA_y - R_{oy} \\\\\nA_z - R_{oz}\n\\end{bmatrix}\n$$\n\nUse Cramer's Rule to solve for $t$, $\\beta$ and $\\gamma$\n\n$$\n\\beta = \n\\frac\n{\n\\begin{vmatrix}\nA_x - R_{ox} &A_x-C_x &R_{dx} \\\\\nA_y - R_{oy} &A_y-C_y &R_{dy} \\\\\nA_z - R_{oz} &A_z-C_z &R_{dz} \n\\end{vmatrix}\n}\n{\n|A|\n}\n$$\n\n$$\n\\gamma = \n\\frac\n{\n\\begin{vmatrix}\nA_x - B_{x} &A_x-R_{ox} &R_{dx} \\\\\nA_y - B_{y} &A_y-R_{oy} &R_{dy} \\\\\nA_z - B_{z} &A_z-R_{oz} &R_{dz} \n\\end{vmatrix}\n}\n{\n|A|\n}\n$$\n\n$$\nt= \n\\frac\n{\n\\begin{vmatrix}\nA_x - B_{x} &A_x - C_{x} &A_x-R_{ox}  \\\\\nA_y - B_{y} &A_x - C_{x} &A_y-R_{oy}  \\\\\nA_z - B_{z} &A_x - C_{x} &A_z-R_{oz} \n\\end{vmatrix}\n}\n{\n|A|\n}\n$$\n\n```c++\nbool Triangle::hit( const Ray &r, double tmin, double tmax, SurfaceHitRecord &rec ) const \n{\t\n    Vector3d e1 = v1 - v0;\n\tVector3d e2 = v2 - v0;\n\tVector3d p = cross( r.direction(), e2 );\t\n\tdouble a = dot( e1, p );\n    double f = 1.0 / a;\n\tVector3d s = r.origin() - v0;\n\tdouble beta = f * dot( s, p );\n    if ( beta < 0.0 || beta > 1.0 ) \n\t{\n\t\treturn false;\n\t}\n\n\tVector3d q = cross( s, e1 );\n    double gamma = f * dot( r.direction(), q );\n    if ( gamma < 0.0 || beta + gamma > 1.0 ) \n\t{\n\t\treturn false;\n\t}\n\n    double t = f * dot( e2, q );\n\n\tif ( t >= tmin && t <= tmax )\n\t{\n\t\trec.t = t;\n\t\trec.p = r.pointAtParam(t);\n\t\tdouble alpha = 1.0 - beta - gamma;\n\t\trec.normal = alpha * n0 + beta * n1 + gamma * n2;\n\t\trec.mat_ptr = matp;\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n\n### Advantages of Barycentric Intersection\n\n* Efficient\n* No need to store plane equation\n* Barycentric coordinates are useful for linear interpolation of normal vectors, texture coordinates, and other attributes at the vertices\n\nFor example, the interpolated normal at $P$ is:\n\n$$N_p = (1 - \\beta - \\gamma)N_A + \\beta N_B + \\gamma N_C$$\n\nand all vector should do a normalization.\n\n## The \"Epsilon\" Problem\n\nShould not accept intersection for very small positive $t$\n\n* May falsely intersect the surface at the ray origin\n* **Method 1:** Use an epsilon value $\\varepsilon$ > 0, and accept an intersection only if its $t > \\varepsilon$.\n* **Method 2:** When a new ray is spawned, advanced the ray origin by an epsilon distance $\\varepsilon$ in the ray direction\n\n![](http://hucoco.com/img/Graphics/RayTracing/epslion_problem_00.png)\n![](http://hucoco.com/img/Graphics/RayTracing/epslion_problem_01.png)\n\n## Reference\n\n**[Learn OpenGL](https://learnopengl.com/) **\n","source":"_posts/Various-surfaces.md","raw":"---\ntitle: Various surfaces\ndate: 2018-07-06 23:28:40\nthumbnail: http://hucoco.com/img/Graphics/RayTracing/RayTracing_0.png\nmathjax: true\ntags: \n- Graphics\n- Ray Tracing\ncategories:\n- Graphics\n- Ray Tracing\n---\n\n## Ray-Plane Intersection\n\nPlane is often represented in implicit form :\n\n$$Ax + By + Cz + D = 0$$\n\nEquivalent:\n\n$$N \\cdot P + D = 0$$ \n\nwhere $N = [A B C]^T$ and $P = [x y z]^T$\n\nTo find ray-plane intersection, substitute ray equation $P(t)$ into plane equation:\n\n1. We get $N \\cdot P + D = 0$.\n2. Sovle for $t$ to get $t_0$.\n3. if $t_0$ is infinity, no intersection (ray is parallel to plane).\n4. Intersection point is $P(t_0)$.\n5. Verify that intersection is not behind ray origin.\n\nThe normal at the intersection is $N$ (or $-N$)\n\n<!--more-->\n\n```c++\nbool Plane::hit( const Ray &r, double tmin, double tmax, SurfaceHitRecord &rec ) const \n{\n\tVector3d N( A, B, C );\n\tdouble NRd = dot( N, r.direction() );\n\tdouble NRo = dot( N, r.origin() );\n\tdouble t = (-D - NRo) / NRd;\n\tif ( t < tmin || t > tmax ) \n\t{\n\t\treturn false;\n\t}\n\trec.t = t;\n\trec.p = r.pointAtParam(t);\n\trec.normal = N;\n\trec.mat_ptr = matp;\n\treturn true;\n}\n```\n\n## Ray-Sphere Intersection\n\nSphere (centered at origin) is often represented in implicit form:\n\n$$x^2 + y^2 + z^2 - r^2 = 0$$\n\nEquivalent:\n\n$$P \\cdot P - r^2 = 0$$\n\nTo find ray-plane intersection, substitute ray equation P(t) into plane equation:\n\nWe get $P \\cdot P - r^2 = 0$:\n\n$$P(t) \\cdot P(t) - r^2 = 0$$\n\n$$(R_o + tR_d) \\cdot (R_o + tR_d) - r^2 = 0$$\n\n$$R_d \\cdot R_dt^2 + 2R_d \\cdot R_o + R_o \\cdot R_o - r^2 = 0$$\n\n$R_o$ is ray origin, $R_d$ is ray direction.\n\nIt is a quadratic equation in the form $at^2 + bt + c = 0$\n\n* $a = R_o \\cdot R_o = 1$ (Since $|R_d| = 1$)\n* $b = 2R_d \\cdot R_o$\n* $c = R_o \\cdot R_o - r^2$\n\nDiscriminant: $d = b^2 + 4ac$\n\nSolution: $t_\\pm = \\frac{-b\\pm\\sqrt{b^2 + 4ac}}{2a}$\n\nChoose $t_0$ as the closest positive $t$ value ($t_+$ + or $t_-$)\n\nThe normal at the intersection point is $P(t_0)/|P(t_0)|$\n\nVery easy to compute, that is why most ray tracing images have spheres.\n\n```c++\nbool Sphere::hit( const Ray &r, double tmin, double tmax, SurfaceHitRecord &rec ) const \n{\n    Vector3d Rd = r.direction();\n    Vector3d Ro = r.origin() - center;\n    double a = dot(Rd,Rd);\n    double b = 2.0 * dot(Rd, Ro);\n    double c = dot(Ro,Ro) - pow(radius, 2);\n    double d = pow(b, 2) - 4.0 * a * c;\n    if(d < 0)\n    {\n        return false;\n    }\n    double t = (-b - sqrt(d)) / (2.0f * a);\n    if ( t >= tmin && t <= tmax )\n    {\n        rec.t = t ;\n        rec.p = r.pointAtParam(t);\n        rec.normal = (Ro + t * Rd) / radius;\n        rec.mat_ptr = matp;\n        return true;\n    }\n    return false;\n}\n```\n\n## Ray-Box Intersection\n\nTo find ray-box intersection:\n\n* For each pair of parallel plane, find the distance to the first plane ($t_{near}$) and to the second plane ($t_{far}$).\n* Keep the largest $t_{near}$ so far, and smallest $t_{far}$ so far.\n* If largest $t_{near}$ > smallest $t_{far}$ , no intersection.\n* Otherwise, the intersection is at P(largest $t_{near}$ )\n\n![](http://hucoco.com/img/Graphics/RayTracing/Ray_box_Intersection_00.png)\n\n## Ray-Triangle Intersection\n\nFinding intersection between a ray and a general polygon is difficult.\n\n* Compute ray-plane intersection\n* Determine whether intersection is within polygon\n\t* Tedious for non-convex polygon\n* Interpolation of attributes at the vertices are not well-\ndefined\n\nMuch easier to find ray-triangle intersection\n\n* Can use the **barycentric coordinates** method.\n* Interpolation of attributes at the vertices are well-defined using the barycentric coordinates.\n\n```c++\nbool Triangle::hit( const Ray &r, double tmin, double tmax, SurfaceHitRecord &rec ) const \n{\n\tdouble A = v0.x() - v1.x();\n\tdouble B = v0.y() - v1.y();\n\tdouble C = v0.z() - v1.z();\n\n\tdouble D = v0.x() - v2.x();\n\tdouble E = v0.y() - v2.y();\n\tdouble F = v0.z() - v2.z();\n\n\tdouble G = r.direction().x();\n\tdouble H = r.direction().y();\n\tdouble I = r.direction().z();\n\n\tdouble J = v0.x() - r.origin().x();\n\tdouble K = v0.y() - r.origin().y();\n\tdouble L = v0.z() - r.origin().z();\n\n\tdouble EIHF = E*I - H*F;\n\tdouble GFDI = G*F - D*I;\n\tdouble DHEG = D*H - E*G;\n\n\tdouble denom = (A*EIHF + B*GFDI + C*DHEG);\n\n\tdouble beta = (J*EIHF + K*GFDI + L*DHEG) / denom;\n\n\tif ( beta < 0.0 || beta > 1.0 ) return false;\n\n\tdouble AKJB = A*K - J*B;\n\tdouble JCAL = J*C - A*L;\n\tdouble BLKC = B*L - K*C;\n\n\tdouble gamma = (I*AKJB + H*JCAL + G*BLKC) / denom;\n\n\tif ( gamma < 0.0 || beta + gamma > 1.0 ) return false;\n\n\tdouble t = -(F*AKJB + E*JCAL + D*BLKC) / denom;\n\n\tif ( t >= tmin && t <= tmax )\n\t{\n\t\t// We have a hit -- populat hit record. \n\t\trec.t = t;\n\t\trec.p = r.pointAtParam(t);\n\t\tdouble alpha = 1.0 - beta - gamma;\n\t\trec.normal = alpha * n0 + beta * n1 + gamma * n2;\n\t\trec.mat_ptr = matp;\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n### Barycentric Coordinates\n\nThe barycentric coordinates of a point P on a triangle $ABC$ is ($ \\alpha $, $ \\beta $, $ \\gamma $) such that:\n\n$$P = \\alpha A + \\beta B + \\gamma C $$ \n\nwhere\n\n$$ \\alpha + \\beta + \\gamma = 1$$\n\nand \n\n$$ 0 \\leq \\alpha,\\beta,\\gamma \\leq 1$$\n\nWe can rewrite it as:\n\n$$P = (1 - \\beta - \\gamma)A + \\beta B + \\gamma C$$\n\n$$P = A + \\beta(B-A) + \\gamma(C-A)$$\n\n![](http://hucoco.com/img/Graphics/RayTracing/Ray_triangle_Intersection_00.png)\n\nTo find ray-triangle intersection, we let:\n\n$$P(t) = A + \\beta(B-A) + \\gamma(C-A)$$\n\n$$R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)$$\n\nSolve for $t$, $\\beta$ and $\\gamma$\n\nIntersection if $\\beta + \\gamma < 1$ and $\\beta,\\gamma > 0$ and $t > 0$\n\nExpand &R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)&\n\n$$\\begin{cases}\nR_{ox} + tR_{dx} = A_x + \\beta(B_x-A_x) + \\gamma(C_x + A_x) \\\\\nR_{oy} + tR_{dy} = A_y + \\beta(B_y-A_y) + \\gamma(C_y + A_y) \\\\\nR_{oz} + tR_{dz} = A_z + \\beta(B_z-A_z) + \\gamma(C_z + A_z) \\\\\n\\end{cases}$$\n\nwe have 3 equations and 3 unknowns here.\n\nRegroup and write in matrix form\n\n$$\n\\begin{bmatrix}\nA_x - B_x &A_x - C_x &R_{dx}\\\\ \nA_y - B_y &A_y - C_y &R_{dy}\\\\ \nA_z - B_z &A_z - C_z &R_{dz}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\beta \\\\\n\\gamma \\\\\nt\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA_x - R_{ox} \\\\\nA_y - R_{oy} \\\\\nA_z - R_{oz}\n\\end{bmatrix}\n$$\n\nUse Cramer's Rule to solve for $t$, $\\beta$ and $\\gamma$\n\n$$\n\\beta = \n\\frac\n{\n\\begin{vmatrix}\nA_x - R_{ox} &A_x-C_x &R_{dx} \\\\\nA_y - R_{oy} &A_y-C_y &R_{dy} \\\\\nA_z - R_{oz} &A_z-C_z &R_{dz} \n\\end{vmatrix}\n}\n{\n|A|\n}\n$$\n\n$$\n\\gamma = \n\\frac\n{\n\\begin{vmatrix}\nA_x - B_{x} &A_x-R_{ox} &R_{dx} \\\\\nA_y - B_{y} &A_y-R_{oy} &R_{dy} \\\\\nA_z - B_{z} &A_z-R_{oz} &R_{dz} \n\\end{vmatrix}\n}\n{\n|A|\n}\n$$\n\n$$\nt= \n\\frac\n{\n\\begin{vmatrix}\nA_x - B_{x} &A_x - C_{x} &A_x-R_{ox}  \\\\\nA_y - B_{y} &A_x - C_{x} &A_y-R_{oy}  \\\\\nA_z - B_{z} &A_x - C_{x} &A_z-R_{oz} \n\\end{vmatrix}\n}\n{\n|A|\n}\n$$\n\n```c++\nbool Triangle::hit( const Ray &r, double tmin, double tmax, SurfaceHitRecord &rec ) const \n{\t\n    Vector3d e1 = v1 - v0;\n\tVector3d e2 = v2 - v0;\n\tVector3d p = cross( r.direction(), e2 );\t\n\tdouble a = dot( e1, p );\n    double f = 1.0 / a;\n\tVector3d s = r.origin() - v0;\n\tdouble beta = f * dot( s, p );\n    if ( beta < 0.0 || beta > 1.0 ) \n\t{\n\t\treturn false;\n\t}\n\n\tVector3d q = cross( s, e1 );\n    double gamma = f * dot( r.direction(), q );\n    if ( gamma < 0.0 || beta + gamma > 1.0 ) \n\t{\n\t\treturn false;\n\t}\n\n    double t = f * dot( e2, q );\n\n\tif ( t >= tmin && t <= tmax )\n\t{\n\t\trec.t = t;\n\t\trec.p = r.pointAtParam(t);\n\t\tdouble alpha = 1.0 - beta - gamma;\n\t\trec.normal = alpha * n0 + beta * n1 + gamma * n2;\n\t\trec.mat_ptr = matp;\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n\n### Advantages of Barycentric Intersection\n\n* Efficient\n* No need to store plane equation\n* Barycentric coordinates are useful for linear interpolation of normal vectors, texture coordinates, and other attributes at the vertices\n\nFor example, the interpolated normal at $P$ is:\n\n$$N_p = (1 - \\beta - \\gamma)N_A + \\beta N_B + \\gamma N_C$$\n\nand all vector should do a normalization.\n\n## The \"Epsilon\" Problem\n\nShould not accept intersection for very small positive $t$\n\n* May falsely intersect the surface at the ray origin\n* **Method 1:** Use an epsilon value $\\varepsilon$ > 0, and accept an intersection only if its $t > \\varepsilon$.\n* **Method 2:** When a new ray is spawned, advanced the ray origin by an epsilon distance $\\varepsilon$ in the ray direction\n\n![](http://hucoco.com/img/Graphics/RayTracing/epslion_problem_00.png)\n![](http://hucoco.com/img/Graphics/RayTracing/epslion_problem_01.png)\n\n## Reference\n\n**[Learn OpenGL](https://learnopengl.com/) **\n","slug":"Various-surfaces","published":1,"updated":"2018-07-10T07:28:24.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36uh001bssb93f8otiof","content":"<h2 id=\"Ray-Plane-Intersection\"><a href=\"#Ray-Plane-Intersection\" class=\"headerlink\" title=\"Ray-Plane Intersection\"></a>Ray-Plane Intersection</h2><p>Plane is often represented in implicit form :</p>\n<script type=\"math/tex; mode=display\">Ax + By + Cz + D = 0</script><p>Equivalent:</p>\n<script type=\"math/tex; mode=display\">N \\cdot P + D = 0</script><p>where $N = [A B C]^T$ and $P = [x y z]^T$</p>\n<p>To find ray-plane intersection, substitute ray equation $P(t)$ into plane equation:</p>\n<ol>\n<li>We get $N \\cdot P + D = 0$.</li>\n<li>Sovle for $t$ to get $t_0$.</li>\n<li>if $t_0$ is infinity, no intersection (ray is parallel to plane).</li>\n<li>Intersection point is $P(t_0)$.</li>\n<li>Verify that intersection is not behind ray origin.</li>\n</ol>\n<p>The normal at the intersection is $N$ (or $-N$)</p>\n<a id=\"more\"></a>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> Plane::hit( <span class=\"keyword\">const</span> Ray &amp;r, <span class=\"keyword\">double</span> tmin, <span class=\"keyword\">double</span> tmax, SurfaceHitRecord &amp;rec ) <span class=\"keyword\">const</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\">Vector3d <span class=\"title\">N</span><span class=\"params\">( A, B, C )</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> NRd = dot( N, r.direction() );</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> NRo = dot( N, r.origin() );</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> t = (-D - NRo) / NRd;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( t &lt; tmin || t &gt; tmax ) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trec.t = t;</span><br><span class=\"line\">\trec.p = r.pointAtParam(t);</span><br><span class=\"line\">\trec.normal = N;</span><br><span class=\"line\">\trec.mat_ptr = matp;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Ray-Sphere-Intersection\"><a href=\"#Ray-Sphere-Intersection\" class=\"headerlink\" title=\"Ray-Sphere Intersection\"></a>Ray-Sphere Intersection</h2><p>Sphere (centered at origin) is often represented in implicit form:</p>\n<script type=\"math/tex; mode=display\">x^2 + y^2 + z^2 - r^2 = 0</script><p>Equivalent:</p>\n<script type=\"math/tex; mode=display\">P \\cdot P - r^2 = 0</script><p>To find ray-plane intersection, substitute ray equation P(t) into plane equation:</p>\n<p>We get $P \\cdot P - r^2 = 0$:</p>\n<script type=\"math/tex; mode=display\">P(t) \\cdot P(t) - r^2 = 0</script><script type=\"math/tex; mode=display\">(R_o + tR_d) \\cdot (R_o + tR_d) - r^2 = 0</script><script type=\"math/tex; mode=display\">R_d \\cdot R_dt^2 + 2R_d \\cdot R_o + R_o \\cdot R_o - r^2 = 0</script><p>$R_o$ is ray origin, $R_d$ is ray direction.</p>\n<p>It is a quadratic equation in the form $at^2 + bt + c = 0$</p>\n<ul>\n<li>$a = R_o \\cdot R_o = 1$ (Since $|R_d| = 1$)</li>\n<li>$b = 2R_d \\cdot R_o$</li>\n<li>$c = R_o \\cdot R_o - r^2$</li>\n</ul>\n<p>Discriminant: $d = b^2 + 4ac$</p>\n<p>Solution: $t_\\pm = \\frac{-b\\pm\\sqrt{b^2 + 4ac}}{2a}$</p>\n<p>Choose $t_0$ as the closest positive $t$ value ($t_+$ + or $t_-$)</p>\n<p>The normal at the intersection point is $P(t_0)/|P(t_0)|$</p>\n<p>Very easy to compute, that is why most ray tracing images have spheres.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> Sphere::hit( <span class=\"keyword\">const</span> Ray &amp;r, <span class=\"keyword\">double</span> tmin, <span class=\"keyword\">double</span> tmax, SurfaceHitRecord &amp;rec ) <span class=\"keyword\">const</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3d Rd = r.direction();</span><br><span class=\"line\">    Vector3d Ro = r.origin() - center;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> a = dot(Rd,Rd);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> b = <span class=\"number\">2.0</span> * dot(Rd, Ro);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> c = dot(Ro,Ro) - <span class=\"built_in\">pow</span>(radius, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d = <span class=\"built_in\">pow</span>(b, <span class=\"number\">2</span>) - <span class=\"number\">4.0</span> * a * c;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> t = (-b - <span class=\"built_in\">sqrt</span>(d)) / (<span class=\"number\">2.0f</span> * a);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( t &gt;= tmin &amp;&amp; t &lt;= tmax )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rec.t = t ;</span><br><span class=\"line\">        rec.p = r.pointAtParam(t);</span><br><span class=\"line\">        rec.normal = (Ro + t * Rd) / radius;</span><br><span class=\"line\">        rec.mat_ptr = matp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Ray-Box-Intersection\"><a href=\"#Ray-Box-Intersection\" class=\"headerlink\" title=\"Ray-Box Intersection\"></a>Ray-Box Intersection</h2><p>To find ray-box intersection:</p>\n<ul>\n<li>For each pair of parallel plane, find the distance to the first plane ($t_{near}$) and to the second plane ($t_{far}$).</li>\n<li>Keep the largest $t_{near}$ so far, and smallest $t_{far}$ so far.</li>\n<li>If largest $t_{near}$ &gt; smallest $t_{far}$ , no intersection.</li>\n<li>Otherwise, the intersection is at P(largest $t_{near}$ )</li>\n</ul>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/Ray_box_Intersection_00.png\" alt=\"\"></p>\n<h2 id=\"Ray-Triangle-Intersection\"><a href=\"#Ray-Triangle-Intersection\" class=\"headerlink\" title=\"Ray-Triangle Intersection\"></a>Ray-Triangle Intersection</h2><p>Finding intersection between a ray and a general polygon is difficult.</p>\n<ul>\n<li>Compute ray-plane intersection</li>\n<li>Determine whether intersection is within polygon<ul>\n<li>Tedious for non-convex polygon</li>\n</ul>\n</li>\n<li>Interpolation of attributes at the vertices are not well-<br>defined</li>\n</ul>\n<p>Much easier to find ray-triangle intersection</p>\n<ul>\n<li>Can use the <strong>barycentric coordinates</strong> method.</li>\n<li>Interpolation of attributes at the vertices are well-defined using the barycentric coordinates.</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> Triangle::hit( <span class=\"keyword\">const</span> Ray &amp;r, <span class=\"keyword\">double</span> tmin, <span class=\"keyword\">double</span> tmax, SurfaceHitRecord &amp;rec ) <span class=\"keyword\">const</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> A = v0.x() - v1.x();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> B = v0.y() - v1.y();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> C = v0.z() - v1.z();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> D = v0.x() - v2.x();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> E = v0.y() - v2.y();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> F = v0.z() - v2.z();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> G = r.direction().x();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> H = r.direction().y();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> I = r.direction().z();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> J = v0.x() - r.origin().x();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> K = v0.y() - r.origin().y();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> L = v0.z() - r.origin().z();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> EIHF = E*I - H*F;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> GFDI = G*F - D*I;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> DHEG = D*H - E*G;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> denom = (A*EIHF + B*GFDI + C*DHEG);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> beta = (J*EIHF + K*GFDI + L*DHEG) / denom;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( beta &lt; <span class=\"number\">0.0</span> || beta &gt; <span class=\"number\">1.0</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> AKJB = A*K - J*B;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> JCAL = J*C - A*L;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> BLKC = B*L - K*C;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> gamma = (I*AKJB + H*JCAL + G*BLKC) / denom;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( gamma &lt; <span class=\"number\">0.0</span> || beta + gamma &gt; <span class=\"number\">1.0</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> t = -(F*AKJB + E*JCAL + D*BLKC) / denom;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( t &gt;= tmin &amp;&amp; t &lt;= tmax )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// We have a hit -- populat hit record. </span></span><br><span class=\"line\">\t\trec.t = t;</span><br><span class=\"line\">\t\trec.p = r.pointAtParam(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> alpha = <span class=\"number\">1.0</span> - beta - gamma;</span><br><span class=\"line\">\t\trec.normal = alpha * n0 + beta * n1 + gamma * n2;</span><br><span class=\"line\">\t\trec.mat_ptr = matp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Barycentric-Coordinates\"><a href=\"#Barycentric-Coordinates\" class=\"headerlink\" title=\"Barycentric Coordinates\"></a>Barycentric Coordinates</h3><p>The barycentric coordinates of a point P on a triangle $ABC$ is ($ \\alpha $, $ \\beta $, $ \\gamma $) such that:</p>\n<script type=\"math/tex; mode=display\">P = \\alpha A + \\beta B + \\gamma C</script><p>where</p>\n<script type=\"math/tex; mode=display\">\\alpha + \\beta + \\gamma = 1</script><p>and </p>\n<script type=\"math/tex; mode=display\">0 \\leq \\alpha,\\beta,\\gamma \\leq 1</script><p>We can rewrite it as:</p>\n<script type=\"math/tex; mode=display\">P = (1 - \\beta - \\gamma)A + \\beta B + \\gamma C</script><script type=\"math/tex; mode=display\">P = A + \\beta(B-A) + \\gamma(C-A)</script><p><img src=\"http://hucoco.com/img/Graphics/RayTracing/Ray_triangle_Intersection_00.png\" alt=\"\"></p>\n<p>To find ray-triangle intersection, we let:</p>\n<script type=\"math/tex; mode=display\">P(t) = A + \\beta(B-A) + \\gamma(C-A)</script><script type=\"math/tex; mode=display\">R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)</script><p>Solve for $t$, $\\beta$ and $\\gamma$</p>\n<p>Intersection if $\\beta + \\gamma &lt; 1$ and $\\beta,\\gamma &gt; 0$ and $t &gt; 0$</p>\n<p>Expand &amp;R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)&amp;</p>\n<script type=\"math/tex; mode=display\">\\begin{cases}\nR_{ox} + tR_{dx} = A_x + \\beta(B_x-A_x) + \\gamma(C_x + A_x) \\\\\nR_{oy} + tR_{dy} = A_y + \\beta(B_y-A_y) + \\gamma(C_y + A_y) \\\\\nR_{oz} + tR_{dz} = A_z + \\beta(B_z-A_z) + \\gamma(C_z + A_z) \\\\\n\\end{cases}</script><p>we have 3 equations and 3 unknowns here.</p>\n<p>Regroup and write in matrix form</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nA_x - B_x &A_x - C_x &R_{dx}\\\\ \nA_y - B_y &A_y - C_y &R_{dy}\\\\ \nA_z - B_z &A_z - C_z &R_{dz}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\beta \\\\\n\\gamma \\\\\nt\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA_x - R_{ox} \\\\\nA_y - R_{oy} \\\\\nA_z - R_{oz}\n\\end{bmatrix}</script><p>Use Cramer’s Rule to solve for $t$, $\\beta$ and $\\gamma$</p>\n<script type=\"math/tex; mode=display\">\n\\beta = \n\\frac\n{\n\\begin{vmatrix}\nA_x - R_{ox} &A_x-C_x &R_{dx} \\\\\nA_y - R_{oy} &A_y-C_y &R_{dy} \\\\\nA_z - R_{oz} &A_z-C_z &R_{dz} \n\\end{vmatrix}\n}\n{\n|A|\n}</script><script type=\"math/tex; mode=display\">\n\\gamma = \n\\frac\n{\n\\begin{vmatrix}\nA_x - B_{x} &A_x-R_{ox} &R_{dx} \\\\\nA_y - B_{y} &A_y-R_{oy} &R_{dy} \\\\\nA_z - B_{z} &A_z-R_{oz} &R_{dz} \n\\end{vmatrix}\n}\n{\n|A|\n}</script><script type=\"math/tex; mode=display\">\nt= \n\\frac\n{\n\\begin{vmatrix}\nA_x - B_{x} &A_x - C_{x} &A_x-R_{ox}  \\\\\nA_y - B_{y} &A_x - C_{x} &A_y-R_{oy}  \\\\\nA_z - B_{z} &A_x - C_{x} &A_z-R_{oz} \n\\end{vmatrix}\n}\n{\n|A|\n}</script><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> Triangle::hit( <span class=\"keyword\">const</span> Ray &amp;r, <span class=\"keyword\">double</span> tmin, <span class=\"keyword\">double</span> tmax, SurfaceHitRecord &amp;rec ) <span class=\"keyword\">const</span> </span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">    Vector3d e1 = v1 - v0;</span><br><span class=\"line\">\tVector3d e2 = v2 - v0;</span><br><span class=\"line\">\tVector3d p = cross( r.direction(), e2 );\t</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> a = dot( e1, p );</span><br><span class=\"line\">    <span class=\"keyword\">double</span> f = <span class=\"number\">1.0</span> / a;</span><br><span class=\"line\">\tVector3d s = r.origin() - v0;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> beta = f * dot( s, p );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( beta &lt; <span class=\"number\">0.0</span> || beta &gt; <span class=\"number\">1.0</span> ) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tVector3d q = cross( s, e1 );</span><br><span class=\"line\">    <span class=\"keyword\">double</span> gamma = f * dot( r.direction(), q );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( gamma &lt; <span class=\"number\">0.0</span> || beta + gamma &gt; <span class=\"number\">1.0</span> ) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">double</span> t = f * dot( e2, q );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( t &gt;= tmin &amp;&amp; t &lt;= tmax )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trec.t = t;</span><br><span class=\"line\">\t\trec.p = r.pointAtParam(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> alpha = <span class=\"number\">1.0</span> - beta - gamma;</span><br><span class=\"line\">\t\trec.normal = alpha * n0 + beta * n1 + gamma * n2;</span><br><span class=\"line\">\t\trec.mat_ptr = matp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Advantages-of-Barycentric-Intersection\"><a href=\"#Advantages-of-Barycentric-Intersection\" class=\"headerlink\" title=\"Advantages of Barycentric Intersection\"></a>Advantages of Barycentric Intersection</h3><ul>\n<li>Efficient</li>\n<li>No need to store plane equation</li>\n<li>Barycentric coordinates are useful for linear interpolation of normal vectors, texture coordinates, and other attributes at the vertices</li>\n</ul>\n<p>For example, the interpolated normal at $P$ is:</p>\n<script type=\"math/tex; mode=display\">N_p = (1 - \\beta - \\gamma)N_A + \\beta N_B + \\gamma N_C</script><p>and all vector should do a normalization.</p>\n<h2 id=\"The-“Epsilon”-Problem\"><a href=\"#The-“Epsilon”-Problem\" class=\"headerlink\" title=\"The “Epsilon” Problem\"></a>The “Epsilon” Problem</h2><p>Should not accept intersection for very small positive $t$</p>\n<ul>\n<li>May falsely intersect the surface at the ray origin</li>\n<li><strong>Method 1:</strong> Use an epsilon value $\\varepsilon$ &gt; 0, and accept an intersection only if its $t &gt; \\varepsilon$.</li>\n<li><strong>Method 2:</strong> When a new ray is spawned, advanced the ray origin by an epsilon distance $\\varepsilon$ in the ray direction</li>\n</ul>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/epslion_problem_00.png\" alt=\"\"><br><img src=\"http://hucoco.com/img/Graphics/RayTracing/epslion_problem_01.png\" alt=\"\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Ray-Plane-Intersection\"><a href=\"#Ray-Plane-Intersection\" class=\"headerlink\" title=\"Ray-Plane Intersection\"></a>Ray-Plane Intersection</h2><p>Plane is often represented in implicit form :</p>\n<script type=\"math/tex; mode=display\">Ax + By + Cz + D = 0</script><p>Equivalent:</p>\n<script type=\"math/tex; mode=display\">N \\cdot P + D = 0</script><p>where $N = [A B C]^T$ and $P = [x y z]^T$</p>\n<p>To find ray-plane intersection, substitute ray equation $P(t)$ into plane equation:</p>\n<ol>\n<li>We get $N \\cdot P + D = 0$.</li>\n<li>Sovle for $t$ to get $t_0$.</li>\n<li>if $t_0$ is infinity, no intersection (ray is parallel to plane).</li>\n<li>Intersection point is $P(t_0)$.</li>\n<li>Verify that intersection is not behind ray origin.</li>\n</ol>\n<p>The normal at the intersection is $N$ (or $-N$)</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> Plane::hit( <span class=\"keyword\">const</span> Ray &amp;r, <span class=\"keyword\">double</span> tmin, <span class=\"keyword\">double</span> tmax, SurfaceHitRecord &amp;rec ) <span class=\"keyword\">const</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\">Vector3d <span class=\"title\">N</span><span class=\"params\">( A, B, C )</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> NRd = dot( N, r.direction() );</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> NRo = dot( N, r.origin() );</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> t = (-D - NRo) / NRd;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( t &lt; tmin || t &gt; tmax ) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trec.t = t;</span><br><span class=\"line\">\trec.p = r.pointAtParam(t);</span><br><span class=\"line\">\trec.normal = N;</span><br><span class=\"line\">\trec.mat_ptr = matp;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Ray-Sphere-Intersection\"><a href=\"#Ray-Sphere-Intersection\" class=\"headerlink\" title=\"Ray-Sphere Intersection\"></a>Ray-Sphere Intersection</h2><p>Sphere (centered at origin) is often represented in implicit form:</p>\n<script type=\"math/tex; mode=display\">x^2 + y^2 + z^2 - r^2 = 0</script><p>Equivalent:</p>\n<script type=\"math/tex; mode=display\">P \\cdot P - r^2 = 0</script><p>To find ray-plane intersection, substitute ray equation P(t) into plane equation:</p>\n<p>We get $P \\cdot P - r^2 = 0$:</p>\n<script type=\"math/tex; mode=display\">P(t) \\cdot P(t) - r^2 = 0</script><script type=\"math/tex; mode=display\">(R_o + tR_d) \\cdot (R_o + tR_d) - r^2 = 0</script><script type=\"math/tex; mode=display\">R_d \\cdot R_dt^2 + 2R_d \\cdot R_o + R_o \\cdot R_o - r^2 = 0</script><p>$R_o$ is ray origin, $R_d$ is ray direction.</p>\n<p>It is a quadratic equation in the form $at^2 + bt + c = 0$</p>\n<ul>\n<li>$a = R_o \\cdot R_o = 1$ (Since $|R_d| = 1$)</li>\n<li>$b = 2R_d \\cdot R_o$</li>\n<li>$c = R_o \\cdot R_o - r^2$</li>\n</ul>\n<p>Discriminant: $d = b^2 + 4ac$</p>\n<p>Solution: $t_\\pm = \\frac{-b\\pm\\sqrt{b^2 + 4ac}}{2a}$</p>\n<p>Choose $t_0$ as the closest positive $t$ value ($t_+$ + or $t_-$)</p>\n<p>The normal at the intersection point is $P(t_0)/|P(t_0)|$</p>\n<p>Very easy to compute, that is why most ray tracing images have spheres.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> Sphere::hit( <span class=\"keyword\">const</span> Ray &amp;r, <span class=\"keyword\">double</span> tmin, <span class=\"keyword\">double</span> tmax, SurfaceHitRecord &amp;rec ) <span class=\"keyword\">const</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3d Rd = r.direction();</span><br><span class=\"line\">    Vector3d Ro = r.origin() - center;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> a = dot(Rd,Rd);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> b = <span class=\"number\">2.0</span> * dot(Rd, Ro);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> c = dot(Ro,Ro) - <span class=\"built_in\">pow</span>(radius, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d = <span class=\"built_in\">pow</span>(b, <span class=\"number\">2</span>) - <span class=\"number\">4.0</span> * a * c;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> t = (-b - <span class=\"built_in\">sqrt</span>(d)) / (<span class=\"number\">2.0f</span> * a);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( t &gt;= tmin &amp;&amp; t &lt;= tmax )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rec.t = t ;</span><br><span class=\"line\">        rec.p = r.pointAtParam(t);</span><br><span class=\"line\">        rec.normal = (Ro + t * Rd) / radius;</span><br><span class=\"line\">        rec.mat_ptr = matp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Ray-Box-Intersection\"><a href=\"#Ray-Box-Intersection\" class=\"headerlink\" title=\"Ray-Box Intersection\"></a>Ray-Box Intersection</h2><p>To find ray-box intersection:</p>\n<ul>\n<li>For each pair of parallel plane, find the distance to the first plane ($t_{near}$) and to the second plane ($t_{far}$).</li>\n<li>Keep the largest $t_{near}$ so far, and smallest $t_{far}$ so far.</li>\n<li>If largest $t_{near}$ &gt; smallest $t_{far}$ , no intersection.</li>\n<li>Otherwise, the intersection is at P(largest $t_{near}$ )</li>\n</ul>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/Ray_box_Intersection_00.png\" alt=\"\"></p>\n<h2 id=\"Ray-Triangle-Intersection\"><a href=\"#Ray-Triangle-Intersection\" class=\"headerlink\" title=\"Ray-Triangle Intersection\"></a>Ray-Triangle Intersection</h2><p>Finding intersection between a ray and a general polygon is difficult.</p>\n<ul>\n<li>Compute ray-plane intersection</li>\n<li>Determine whether intersection is within polygon<ul>\n<li>Tedious for non-convex polygon</li>\n</ul>\n</li>\n<li>Interpolation of attributes at the vertices are not well-<br>defined</li>\n</ul>\n<p>Much easier to find ray-triangle intersection</p>\n<ul>\n<li>Can use the <strong>barycentric coordinates</strong> method.</li>\n<li>Interpolation of attributes at the vertices are well-defined using the barycentric coordinates.</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> Triangle::hit( <span class=\"keyword\">const</span> Ray &amp;r, <span class=\"keyword\">double</span> tmin, <span class=\"keyword\">double</span> tmax, SurfaceHitRecord &amp;rec ) <span class=\"keyword\">const</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> A = v0.x() - v1.x();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> B = v0.y() - v1.y();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> C = v0.z() - v1.z();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> D = v0.x() - v2.x();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> E = v0.y() - v2.y();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> F = v0.z() - v2.z();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> G = r.direction().x();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> H = r.direction().y();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> I = r.direction().z();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> J = v0.x() - r.origin().x();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> K = v0.y() - r.origin().y();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> L = v0.z() - r.origin().z();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> EIHF = E*I - H*F;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> GFDI = G*F - D*I;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> DHEG = D*H - E*G;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> denom = (A*EIHF + B*GFDI + C*DHEG);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> beta = (J*EIHF + K*GFDI + L*DHEG) / denom;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( beta &lt; <span class=\"number\">0.0</span> || beta &gt; <span class=\"number\">1.0</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> AKJB = A*K - J*B;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> JCAL = J*C - A*L;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> BLKC = B*L - K*C;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> gamma = (I*AKJB + H*JCAL + G*BLKC) / denom;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( gamma &lt; <span class=\"number\">0.0</span> || beta + gamma &gt; <span class=\"number\">1.0</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> t = -(F*AKJB + E*JCAL + D*BLKC) / denom;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( t &gt;= tmin &amp;&amp; t &lt;= tmax )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// We have a hit -- populat hit record. </span></span><br><span class=\"line\">\t\trec.t = t;</span><br><span class=\"line\">\t\trec.p = r.pointAtParam(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> alpha = <span class=\"number\">1.0</span> - beta - gamma;</span><br><span class=\"line\">\t\trec.normal = alpha * n0 + beta * n1 + gamma * n2;</span><br><span class=\"line\">\t\trec.mat_ptr = matp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Barycentric-Coordinates\"><a href=\"#Barycentric-Coordinates\" class=\"headerlink\" title=\"Barycentric Coordinates\"></a>Barycentric Coordinates</h3><p>The barycentric coordinates of a point P on a triangle $ABC$ is ($ \\alpha $, $ \\beta $, $ \\gamma $) such that:</p>\n<script type=\"math/tex; mode=display\">P = \\alpha A + \\beta B + \\gamma C</script><p>where</p>\n<script type=\"math/tex; mode=display\">\\alpha + \\beta + \\gamma = 1</script><p>and </p>\n<script type=\"math/tex; mode=display\">0 \\leq \\alpha,\\beta,\\gamma \\leq 1</script><p>We can rewrite it as:</p>\n<script type=\"math/tex; mode=display\">P = (1 - \\beta - \\gamma)A + \\beta B + \\gamma C</script><script type=\"math/tex; mode=display\">P = A + \\beta(B-A) + \\gamma(C-A)</script><p><img src=\"http://hucoco.com/img/Graphics/RayTracing/Ray_triangle_Intersection_00.png\" alt=\"\"></p>\n<p>To find ray-triangle intersection, we let:</p>\n<script type=\"math/tex; mode=display\">P(t) = A + \\beta(B-A) + \\gamma(C-A)</script><script type=\"math/tex; mode=display\">R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)</script><p>Solve for $t$, $\\beta$ and $\\gamma$</p>\n<p>Intersection if $\\beta + \\gamma &lt; 1$ and $\\beta,\\gamma &gt; 0$ and $t &gt; 0$</p>\n<p>Expand &amp;R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)&amp;</p>\n<script type=\"math/tex; mode=display\">\\begin{cases}\nR_{ox} + tR_{dx} = A_x + \\beta(B_x-A_x) + \\gamma(C_x + A_x) \\\\\nR_{oy} + tR_{dy} = A_y + \\beta(B_y-A_y) + \\gamma(C_y + A_y) \\\\\nR_{oz} + tR_{dz} = A_z + \\beta(B_z-A_z) + \\gamma(C_z + A_z) \\\\\n\\end{cases}</script><p>we have 3 equations and 3 unknowns here.</p>\n<p>Regroup and write in matrix form</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nA_x - B_x &A_x - C_x &R_{dx}\\\\ \nA_y - B_y &A_y - C_y &R_{dy}\\\\ \nA_z - B_z &A_z - C_z &R_{dz}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\beta \\\\\n\\gamma \\\\\nt\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA_x - R_{ox} \\\\\nA_y - R_{oy} \\\\\nA_z - R_{oz}\n\\end{bmatrix}</script><p>Use Cramer’s Rule to solve for $t$, $\\beta$ and $\\gamma$</p>\n<script type=\"math/tex; mode=display\">\n\\beta = \n\\frac\n{\n\\begin{vmatrix}\nA_x - R_{ox} &A_x-C_x &R_{dx} \\\\\nA_y - R_{oy} &A_y-C_y &R_{dy} \\\\\nA_z - R_{oz} &A_z-C_z &R_{dz} \n\\end{vmatrix}\n}\n{\n|A|\n}</script><script type=\"math/tex; mode=display\">\n\\gamma = \n\\frac\n{\n\\begin{vmatrix}\nA_x - B_{x} &A_x-R_{ox} &R_{dx} \\\\\nA_y - B_{y} &A_y-R_{oy} &R_{dy} \\\\\nA_z - B_{z} &A_z-R_{oz} &R_{dz} \n\\end{vmatrix}\n}\n{\n|A|\n}</script><script type=\"math/tex; mode=display\">\nt= \n\\frac\n{\n\\begin{vmatrix}\nA_x - B_{x} &A_x - C_{x} &A_x-R_{ox}  \\\\\nA_y - B_{y} &A_x - C_{x} &A_y-R_{oy}  \\\\\nA_z - B_{z} &A_x - C_{x} &A_z-R_{oz} \n\\end{vmatrix}\n}\n{\n|A|\n}</script><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> Triangle::hit( <span class=\"keyword\">const</span> Ray &amp;r, <span class=\"keyword\">double</span> tmin, <span class=\"keyword\">double</span> tmax, SurfaceHitRecord &amp;rec ) <span class=\"keyword\">const</span> </span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">    Vector3d e1 = v1 - v0;</span><br><span class=\"line\">\tVector3d e2 = v2 - v0;</span><br><span class=\"line\">\tVector3d p = cross( r.direction(), e2 );\t</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> a = dot( e1, p );</span><br><span class=\"line\">    <span class=\"keyword\">double</span> f = <span class=\"number\">1.0</span> / a;</span><br><span class=\"line\">\tVector3d s = r.origin() - v0;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> beta = f * dot( s, p );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( beta &lt; <span class=\"number\">0.0</span> || beta &gt; <span class=\"number\">1.0</span> ) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tVector3d q = cross( s, e1 );</span><br><span class=\"line\">    <span class=\"keyword\">double</span> gamma = f * dot( r.direction(), q );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( gamma &lt; <span class=\"number\">0.0</span> || beta + gamma &gt; <span class=\"number\">1.0</span> ) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">double</span> t = f * dot( e2, q );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( t &gt;= tmin &amp;&amp; t &lt;= tmax )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trec.t = t;</span><br><span class=\"line\">\t\trec.p = r.pointAtParam(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> alpha = <span class=\"number\">1.0</span> - beta - gamma;</span><br><span class=\"line\">\t\trec.normal = alpha * n0 + beta * n1 + gamma * n2;</span><br><span class=\"line\">\t\trec.mat_ptr = matp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Advantages-of-Barycentric-Intersection\"><a href=\"#Advantages-of-Barycentric-Intersection\" class=\"headerlink\" title=\"Advantages of Barycentric Intersection\"></a>Advantages of Barycentric Intersection</h3><ul>\n<li>Efficient</li>\n<li>No need to store plane equation</li>\n<li>Barycentric coordinates are useful for linear interpolation of normal vectors, texture coordinates, and other attributes at the vertices</li>\n</ul>\n<p>For example, the interpolated normal at $P$ is:</p>\n<script type=\"math/tex; mode=display\">N_p = (1 - \\beta - \\gamma)N_A + \\beta N_B + \\gamma N_C</script><p>and all vector should do a normalization.</p>\n<h2 id=\"The-“Epsilon”-Problem\"><a href=\"#The-“Epsilon”-Problem\" class=\"headerlink\" title=\"The “Epsilon” Problem\"></a>The “Epsilon” Problem</h2><p>Should not accept intersection for very small positive $t$</p>\n<ul>\n<li>May falsely intersect the surface at the ray origin</li>\n<li><strong>Method 1:</strong> Use an epsilon value $\\varepsilon$ &gt; 0, and accept an intersection only if its $t &gt; \\varepsilon$.</li>\n<li><strong>Method 2:</strong> When a new ray is spawned, advanced the ray origin by an epsilon distance $\\varepsilon$ in the ray direction</li>\n</ul>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/epslion_problem_00.png\" alt=\"\"><br><img src=\"http://hucoco.com/img/Graphics/RayTracing/epslion_problem_01.png\" alt=\"\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>"},{"title":"The Reflection Equation","date":"2018-07-11T13:46:22.000Z","thumbnail":"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_00.png","mathjax":true,"_content":"\n## Overview\n\nPhysically based rendering strongly follows a more specialized version of the render equation known as the reflectance equation, which is the best model we have for simulating the visuals of light:\n\n$$L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_i$$\n\nTo understand the equation, we have to delve into a bit of **radiometry**. Radiometry is the measurement of electromagnetic radiation (including visible light). There are several radiometric quantities we can use to measure light over surfaces and directions, but we will only discuss a single one that's relevant to the reflectance equation known as **radiance**, denoted here as $L$. Radiance is used to quantify the magnitude or strength of light coming from a single direction.\n\n<!--more-->\n\n## Radiant flux\n\nradiant flux $\\Phi$ is the transmitted energy of a light source measured in Watts. Light is a collective sum of energy over multiple different wavelengths, each wavelength associated with a particular (visible) color. The emitted energy of a light source can therefore be thought of as a function of all its different wavelengths. Wavelengths between 390nm to 700nm (nanometers) are considered part of the visible light spectrum i.e. wavelengths the human eye is able to perceive. Below you'll find an image of the different energies per wavelength of daylight:\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_01.png)\n\nThe radiant flux measures the total area of this function of different wavelengths. Directly taking this measure of wavelengths as input in computer graphics is slightly impractical so we often make the simplification of representing radiant flux not as a function of varying wavelength strengths, but as a light color triplet encoded as **RGB** This encoding does come at quite a loss of information, but this is generally negligible for visual aspects.\n\n## Solid angle\n\nthe solid angle denoted as $\\omega$ tells us the size or area of a shape projected onto a unit sphere. The area of the projected shape onto this unit sphere is known as the **solid angle**; you can visualize the solid angle as a direction with volume:\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_03.png)\n\n## Radiant intensity\n\nradiant intensity measures the amount of radiant flux per solid angle or the strength of a light source over a projected area onto the unit sphere. For instance, given an omnidirectional light that radiates equally in all directions the radiant intensity can give us its energy over a specific area (solid angle):\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_02.png)\n\nThe equation to describe the radiant intensity is defined as follows:\n\n$$I = \\frac{d\\Phi}{d\\omega}$$\n\nWhere $I$ is the radiant flux $\\Phi$ over the solid angle $\\omega$.\n\nWith knowledge of radiant flux, radiant intensity and the solid angle we can finally describe the equation for **radiance**, which is described as the total observed energy over an area $A$ over the solid angle $\\omega$ of a light of radiant intensity $\\Phi$:\n\n$$L = \\frac{d^2\\Phi}{dAd\\omega cos\\theta}$$\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_00.png)\n\nRadiance is a radiometric measure of the amount of light in an area scaled by the **incident** (or incoming) angle $\\theta$ of the light to the surface's normal as $cos\\theta$: light is weaker the less it directly radiates onto the surface and strongest when it is directly perpendicular to the surface. This is similar to our perception of diffuse lighting from the basic lighting tutorials as $cos\\theta$ directly corresponds to the dot product between the light's direction vector and the surface's normal:\n\n```c++\nfloat cosTheta = dot(lightDir, N); \n```\n\n## The Reflection Equation\n\nThe radiance equation is quite useful as it consists of most physical quantities we're interested in. If we consider the solid angle ω and the area A to be infinitely small, we can use radiance to measure the flux of a single ray of light hitting a single point in space. This relation allows us to calculate the radiance of a single light ray influencing a single (fragment) point; we effectively translate the solid angle ω into a direction vector ω, and A into a point p. This way we can directly use radiance in our shaders to calculate a single light ray's per-fragment contribution.\n\nIn fact, when it comes to radiance we generally care about all incoming light onto a point p which is the sum of all radiance known as irradiance. With knowledge of both radiance and irradiance we can get back to the reflectance equation:\n\n$$L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_i$$\n\nWe now know that $L$ in the render equation represents the radiance of some point p and some incoming infinitely small solid angle $\\omega_i$ which can be thought of as an incoming direction vector $\\omega_i$. Remember that $cos\\theta$ scales the energy based on the light's incident angle to the surface which we find in the reflectance equation as $n\\cdot \\omega_o$. The reflectance equation calculates the sum of reflected radiance $L_o(p,\\omega_o)$ of a point $p$ in direction $\\omega_o$ which is the outgoing direction to the viewer. Or to put it differently: $Lo$ measures the reflected sum of the lights' irradiance onto point $p$ as viewed from $\\omega_o$.\n\nAs the reflectance equation is based around irradiance which is the sum of all incoming radiance we measure light of not just a single incoming light direction, but of all incoming light directions within a hemisphere $\\Omega$ centered around point $p$. A **hemisphere** can be described as half a sphere aligned around a surface's normal $n$:\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_04.png)\n\nTo calculate the total of values inside an area or, in the case of a hemisphere, a volume we use a mathematical construct called an integral denoted in the reflectance equation as $\\int$ over all incoming directions $d\\omega_i$ within the hemisphere $\\Omega$. An integral measures the area of a function, which can either be calculated **analytically** or **numerically**. As there is no analytical solution to both the render and reflectance equation we'll want to numerically solve the integral discretely. This translates to taking the result of small discrete steps of the reflectance equation over the hemisphere $\\Omega$ and averaging their results over the step size.\n\nThe reflectance equation sums up the radiance of all incoming light directions $\\omega_i$ over the hemisphere $\\Omega$ scaled by $f_r$ that hit point $p$ and returns the sum of reflected light $L_o$ in the viewer's direction. The incoming radiance can come from light sources.\n\nNow the only unknown left is the $f_r$ symbol known as the **BRDF** or **Bidirectional Reflective Distribution Function** that scales or weighs the incoming radiance based on the surface's material properties.\n\n## Reference\n\n**[Learn OpenGL PBR Theory](https://learnopengl.com/PBR/Theory) **","source":"_posts/The-Reflectance-Equation.md","raw":"---\ntitle: The Reflection Equation\ndate: 2018-07-11 21:46:22\nthumbnail: http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_00.png\nmathjax: true\ntags: \n- Graphics\n- PBR\ncategories:\n- Graphics\n- PBR\n---\n\n## Overview\n\nPhysically based rendering strongly follows a more specialized version of the render equation known as the reflectance equation, which is the best model we have for simulating the visuals of light:\n\n$$L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_i$$\n\nTo understand the equation, we have to delve into a bit of **radiometry**. Radiometry is the measurement of electromagnetic radiation (including visible light). There are several radiometric quantities we can use to measure light over surfaces and directions, but we will only discuss a single one that's relevant to the reflectance equation known as **radiance**, denoted here as $L$. Radiance is used to quantify the magnitude or strength of light coming from a single direction.\n\n<!--more-->\n\n## Radiant flux\n\nradiant flux $\\Phi$ is the transmitted energy of a light source measured in Watts. Light is a collective sum of energy over multiple different wavelengths, each wavelength associated with a particular (visible) color. The emitted energy of a light source can therefore be thought of as a function of all its different wavelengths. Wavelengths between 390nm to 700nm (nanometers) are considered part of the visible light spectrum i.e. wavelengths the human eye is able to perceive. Below you'll find an image of the different energies per wavelength of daylight:\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_01.png)\n\nThe radiant flux measures the total area of this function of different wavelengths. Directly taking this measure of wavelengths as input in computer graphics is slightly impractical so we often make the simplification of representing radiant flux not as a function of varying wavelength strengths, but as a light color triplet encoded as **RGB** This encoding does come at quite a loss of information, but this is generally negligible for visual aspects.\n\n## Solid angle\n\nthe solid angle denoted as $\\omega$ tells us the size or area of a shape projected onto a unit sphere. The area of the projected shape onto this unit sphere is known as the **solid angle**; you can visualize the solid angle as a direction with volume:\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_03.png)\n\n## Radiant intensity\n\nradiant intensity measures the amount of radiant flux per solid angle or the strength of a light source over a projected area onto the unit sphere. For instance, given an omnidirectional light that radiates equally in all directions the radiant intensity can give us its energy over a specific area (solid angle):\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_02.png)\n\nThe equation to describe the radiant intensity is defined as follows:\n\n$$I = \\frac{d\\Phi}{d\\omega}$$\n\nWhere $I$ is the radiant flux $\\Phi$ over the solid angle $\\omega$.\n\nWith knowledge of radiant flux, radiant intensity and the solid angle we can finally describe the equation for **radiance**, which is described as the total observed energy over an area $A$ over the solid angle $\\omega$ of a light of radiant intensity $\\Phi$:\n\n$$L = \\frac{d^2\\Phi}{dAd\\omega cos\\theta}$$\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_00.png)\n\nRadiance is a radiometric measure of the amount of light in an area scaled by the **incident** (or incoming) angle $\\theta$ of the light to the surface's normal as $cos\\theta$: light is weaker the less it directly radiates onto the surface and strongest when it is directly perpendicular to the surface. This is similar to our perception of diffuse lighting from the basic lighting tutorials as $cos\\theta$ directly corresponds to the dot product between the light's direction vector and the surface's normal:\n\n```c++\nfloat cosTheta = dot(lightDir, N); \n```\n\n## The Reflection Equation\n\nThe radiance equation is quite useful as it consists of most physical quantities we're interested in. If we consider the solid angle ω and the area A to be infinitely small, we can use radiance to measure the flux of a single ray of light hitting a single point in space. This relation allows us to calculate the radiance of a single light ray influencing a single (fragment) point; we effectively translate the solid angle ω into a direction vector ω, and A into a point p. This way we can directly use radiance in our shaders to calculate a single light ray's per-fragment contribution.\n\nIn fact, when it comes to radiance we generally care about all incoming light onto a point p which is the sum of all radiance known as irradiance. With knowledge of both radiance and irradiance we can get back to the reflectance equation:\n\n$$L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_i$$\n\nWe now know that $L$ in the render equation represents the radiance of some point p and some incoming infinitely small solid angle $\\omega_i$ which can be thought of as an incoming direction vector $\\omega_i$. Remember that $cos\\theta$ scales the energy based on the light's incident angle to the surface which we find in the reflectance equation as $n\\cdot \\omega_o$. The reflectance equation calculates the sum of reflected radiance $L_o(p,\\omega_o)$ of a point $p$ in direction $\\omega_o$ which is the outgoing direction to the viewer. Or to put it differently: $Lo$ measures the reflected sum of the lights' irradiance onto point $p$ as viewed from $\\omega_o$.\n\nAs the reflectance equation is based around irradiance which is the sum of all incoming radiance we measure light of not just a single incoming light direction, but of all incoming light directions within a hemisphere $\\Omega$ centered around point $p$. A **hemisphere** can be described as half a sphere aligned around a surface's normal $n$:\n\n![](http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_04.png)\n\nTo calculate the total of values inside an area or, in the case of a hemisphere, a volume we use a mathematical construct called an integral denoted in the reflectance equation as $\\int$ over all incoming directions $d\\omega_i$ within the hemisphere $\\Omega$. An integral measures the area of a function, which can either be calculated **analytically** or **numerically**. As there is no analytical solution to both the render and reflectance equation we'll want to numerically solve the integral discretely. This translates to taking the result of small discrete steps of the reflectance equation over the hemisphere $\\Omega$ and averaging their results over the step size.\n\nThe reflectance equation sums up the radiance of all incoming light directions $\\omega_i$ over the hemisphere $\\Omega$ scaled by $f_r$ that hit point $p$ and returns the sum of reflected light $L_o$ in the viewer's direction. The incoming radiance can come from light sources.\n\nNow the only unknown left is the $f_r$ symbol known as the **BRDF** or **Bidirectional Reflective Distribution Function** that scales or weighs the incoming radiance based on the surface's material properties.\n\n## Reference\n\n**[Learn OpenGL PBR Theory](https://learnopengl.com/PBR/Theory) **","slug":"The-Reflectance-Equation","published":1,"updated":"2018-07-11T15:04:18.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36uj001fssb9ok7vhzsi","content":"<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>Physically based rendering strongly follows a more specialized version of the render equation known as the reflectance equation, which is the best model we have for simulating the visuals of light:</p>\n<script type=\"math/tex; mode=display\">L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_i</script><p>To understand the equation, we have to delve into a bit of <strong>radiometry</strong>. Radiometry is the measurement of electromagnetic radiation (including visible light). There are several radiometric quantities we can use to measure light over surfaces and directions, but we will only discuss a single one that’s relevant to the reflectance equation known as <strong>radiance</strong>, denoted here as $L$. Radiance is used to quantify the magnitude or strength of light coming from a single direction.</p>\n<a id=\"more\"></a>\n<h2 id=\"Radiant-flux\"><a href=\"#Radiant-flux\" class=\"headerlink\" title=\"Radiant flux\"></a>Radiant flux</h2><p>radiant flux $\\Phi$ is the transmitted energy of a light source measured in Watts. Light is a collective sum of energy over multiple different wavelengths, each wavelength associated with a particular (visible) color. The emitted energy of a light source can therefore be thought of as a function of all its different wavelengths. Wavelengths between 390nm to 700nm (nanometers) are considered part of the visible light spectrum i.e. wavelengths the human eye is able to perceive. Below you’ll find an image of the different energies per wavelength of daylight:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_01.png\" alt=\"\"></p>\n<p>The radiant flux measures the total area of this function of different wavelengths. Directly taking this measure of wavelengths as input in computer graphics is slightly impractical so we often make the simplification of representing radiant flux not as a function of varying wavelength strengths, but as a light color triplet encoded as <strong>RGB</strong> This encoding does come at quite a loss of information, but this is generally negligible for visual aspects.</p>\n<h2 id=\"Solid-angle\"><a href=\"#Solid-angle\" class=\"headerlink\" title=\"Solid angle\"></a>Solid angle</h2><p>the solid angle denoted as $\\omega$ tells us the size or area of a shape projected onto a unit sphere. The area of the projected shape onto this unit sphere is known as the <strong>solid angle</strong>; you can visualize the solid angle as a direction with volume:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_03.png\" alt=\"\"></p>\n<h2 id=\"Radiant-intensity\"><a href=\"#Radiant-intensity\" class=\"headerlink\" title=\"Radiant intensity\"></a>Radiant intensity</h2><p>radiant intensity measures the amount of radiant flux per solid angle or the strength of a light source over a projected area onto the unit sphere. For instance, given an omnidirectional light that radiates equally in all directions the radiant intensity can give us its energy over a specific area (solid angle):</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_02.png\" alt=\"\"></p>\n<p>The equation to describe the radiant intensity is defined as follows:</p>\n<script type=\"math/tex; mode=display\">I = \\frac{d\\Phi}{d\\omega}</script><p>Where $I$ is the radiant flux $\\Phi$ over the solid angle $\\omega$.</p>\n<p>With knowledge of radiant flux, radiant intensity and the solid angle we can finally describe the equation for <strong>radiance</strong>, which is described as the total observed energy over an area $A$ over the solid angle $\\omega$ of a light of radiant intensity $\\Phi$:</p>\n<script type=\"math/tex; mode=display\">L = \\frac{d^2\\Phi}{dAd\\omega cos\\theta}</script><p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_00.png\" alt=\"\"></p>\n<p>Radiance is a radiometric measure of the amount of light in an area scaled by the <strong>incident</strong> (or incoming) angle $\\theta$ of the light to the surface’s normal as $cos\\theta$: light is weaker the less it directly radiates onto the surface and strongest when it is directly perpendicular to the surface. This is similar to our perception of diffuse lighting from the basic lighting tutorials as $cos\\theta$ directly corresponds to the dot product between the light’s direction vector and the surface’s normal:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> cosTheta = dot(lightDir, N);</span><br></pre></td></tr></table></figure>\n<h2 id=\"The-Reflection-Equation\"><a href=\"#The-Reflection-Equation\" class=\"headerlink\" title=\"The Reflection Equation\"></a>The Reflection Equation</h2><p>The radiance equation is quite useful as it consists of most physical quantities we’re interested in. If we consider the solid angle ω and the area A to be infinitely small, we can use radiance to measure the flux of a single ray of light hitting a single point in space. This relation allows us to calculate the radiance of a single light ray influencing a single (fragment) point; we effectively translate the solid angle ω into a direction vector ω, and A into a point p. This way we can directly use radiance in our shaders to calculate a single light ray’s per-fragment contribution.</p>\n<p>In fact, when it comes to radiance we generally care about all incoming light onto a point p which is the sum of all radiance known as irradiance. With knowledge of both radiance and irradiance we can get back to the reflectance equation:</p>\n<script type=\"math/tex; mode=display\">L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_i</script><p>We now know that $L$ in the render equation represents the radiance of some point p and some incoming infinitely small solid angle $\\omega_i$ which can be thought of as an incoming direction vector $\\omega_i$. Remember that $cos\\theta$ scales the energy based on the light’s incident angle to the surface which we find in the reflectance equation as $n\\cdot \\omega_o$. The reflectance equation calculates the sum of reflected radiance $L_o(p,\\omega_o)$ of a point $p$ in direction $\\omega_o$ which is the outgoing direction to the viewer. Or to put it differently: $Lo$ measures the reflected sum of the lights’ irradiance onto point $p$ as viewed from $\\omega_o$.</p>\n<p>As the reflectance equation is based around irradiance which is the sum of all incoming radiance we measure light of not just a single incoming light direction, but of all incoming light directions within a hemisphere $\\Omega$ centered around point $p$. A <strong>hemisphere</strong> can be described as half a sphere aligned around a surface’s normal $n$:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_04.png\" alt=\"\"></p>\n<p>To calculate the total of values inside an area or, in the case of a hemisphere, a volume we use a mathematical construct called an integral denoted in the reflectance equation as $\\int$ over all incoming directions $d\\omega_i$ within the hemisphere $\\Omega$. An integral measures the area of a function, which can either be calculated <strong>analytically</strong> or <strong>numerically</strong>. As there is no analytical solution to both the render and reflectance equation we’ll want to numerically solve the integral discretely. This translates to taking the result of small discrete steps of the reflectance equation over the hemisphere $\\Omega$ and averaging their results over the step size.</p>\n<p>The reflectance equation sums up the radiance of all incoming light directions $\\omega_i$ over the hemisphere $\\Omega$ scaled by $f_r$ that hit point $p$ and returns the sum of reflected light $L_o$ in the viewer’s direction. The incoming radiance can come from light sources.</p>\n<p>Now the only unknown left is the $f_r$ symbol known as the <strong>BRDF</strong> or <strong>Bidirectional Reflective Distribution Function</strong> that scales or weighs the incoming radiance based on the surface’s material properties.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/PBR/Theory\" target=\"_blank\" rel=\"noopener\">Learn OpenGL PBR Theory</a> </strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>Physically based rendering strongly follows a more specialized version of the render equation known as the reflectance equation, which is the best model we have for simulating the visuals of light:</p>\n<script type=\"math/tex; mode=display\">L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_i</script><p>To understand the equation, we have to delve into a bit of <strong>radiometry</strong>. Radiometry is the measurement of electromagnetic radiation (including visible light). There are several radiometric quantities we can use to measure light over surfaces and directions, but we will only discuss a single one that’s relevant to the reflectance equation known as <strong>radiance</strong>, denoted here as $L$. Radiance is used to quantify the magnitude or strength of light coming from a single direction.</p>","more":"<h2 id=\"Radiant-flux\"><a href=\"#Radiant-flux\" class=\"headerlink\" title=\"Radiant flux\"></a>Radiant flux</h2><p>radiant flux $\\Phi$ is the transmitted energy of a light source measured in Watts. Light is a collective sum of energy over multiple different wavelengths, each wavelength associated with a particular (visible) color. The emitted energy of a light source can therefore be thought of as a function of all its different wavelengths. Wavelengths between 390nm to 700nm (nanometers) are considered part of the visible light spectrum i.e. wavelengths the human eye is able to perceive. Below you’ll find an image of the different energies per wavelength of daylight:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_01.png\" alt=\"\"></p>\n<p>The radiant flux measures the total area of this function of different wavelengths. Directly taking this measure of wavelengths as input in computer graphics is slightly impractical so we often make the simplification of representing radiant flux not as a function of varying wavelength strengths, but as a light color triplet encoded as <strong>RGB</strong> This encoding does come at quite a loss of information, but this is generally negligible for visual aspects.</p>\n<h2 id=\"Solid-angle\"><a href=\"#Solid-angle\" class=\"headerlink\" title=\"Solid angle\"></a>Solid angle</h2><p>the solid angle denoted as $\\omega$ tells us the size or area of a shape projected onto a unit sphere. The area of the projected shape onto this unit sphere is known as the <strong>solid angle</strong>; you can visualize the solid angle as a direction with volume:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_03.png\" alt=\"\"></p>\n<h2 id=\"Radiant-intensity\"><a href=\"#Radiant-intensity\" class=\"headerlink\" title=\"Radiant intensity\"></a>Radiant intensity</h2><p>radiant intensity measures the amount of radiant flux per solid angle or the strength of a light source over a projected area onto the unit sphere. For instance, given an omnidirectional light that radiates equally in all directions the radiant intensity can give us its energy over a specific area (solid angle):</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_02.png\" alt=\"\"></p>\n<p>The equation to describe the radiant intensity is defined as follows:</p>\n<script type=\"math/tex; mode=display\">I = \\frac{d\\Phi}{d\\omega}</script><p>Where $I$ is the radiant flux $\\Phi$ over the solid angle $\\omega$.</p>\n<p>With knowledge of radiant flux, radiant intensity and the solid angle we can finally describe the equation for <strong>radiance</strong>, which is described as the total observed energy over an area $A$ over the solid angle $\\omega$ of a light of radiant intensity $\\Phi$:</p>\n<script type=\"math/tex; mode=display\">L = \\frac{d^2\\Phi}{dAd\\omega cos\\theta}</script><p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_00.png\" alt=\"\"></p>\n<p>Radiance is a radiometric measure of the amount of light in an area scaled by the <strong>incident</strong> (or incoming) angle $\\theta$ of the light to the surface’s normal as $cos\\theta$: light is weaker the less it directly radiates onto the surface and strongest when it is directly perpendicular to the surface. This is similar to our perception of diffuse lighting from the basic lighting tutorials as $cos\\theta$ directly corresponds to the dot product between the light’s direction vector and the surface’s normal:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> cosTheta = dot(lightDir, N);</span><br></pre></td></tr></table></figure>\n<h2 id=\"The-Reflection-Equation\"><a href=\"#The-Reflection-Equation\" class=\"headerlink\" title=\"The Reflection Equation\"></a>The Reflection Equation</h2><p>The radiance equation is quite useful as it consists of most physical quantities we’re interested in. If we consider the solid angle ω and the area A to be infinitely small, we can use radiance to measure the flux of a single ray of light hitting a single point in space. This relation allows us to calculate the radiance of a single light ray influencing a single (fragment) point; we effectively translate the solid angle ω into a direction vector ω, and A into a point p. This way we can directly use radiance in our shaders to calculate a single light ray’s per-fragment contribution.</p>\n<p>In fact, when it comes to radiance we generally care about all incoming light onto a point p which is the sum of all radiance known as irradiance. With knowledge of both radiance and irradiance we can get back to the reflectance equation:</p>\n<script type=\"math/tex; mode=display\">L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_i</script><p>We now know that $L$ in the render equation represents the radiance of some point p and some incoming infinitely small solid angle $\\omega_i$ which can be thought of as an incoming direction vector $\\omega_i$. Remember that $cos\\theta$ scales the energy based on the light’s incident angle to the surface which we find in the reflectance equation as $n\\cdot \\omega_o$. The reflectance equation calculates the sum of reflected radiance $L_o(p,\\omega_o)$ of a point $p$ in direction $\\omega_o$ which is the outgoing direction to the viewer. Or to put it differently: $Lo$ measures the reflected sum of the lights’ irradiance onto point $p$ as viewed from $\\omega_o$.</p>\n<p>As the reflectance equation is based around irradiance which is the sum of all incoming radiance we measure light of not just a single incoming light direction, but of all incoming light directions within a hemisphere $\\Omega$ centered around point $p$. A <strong>hemisphere</strong> can be described as half a sphere aligned around a surface’s normal $n$:</p>\n<p><img src=\"http://hucoco.com/img/Graphics/PBR/The_Reflection_Equation_04.png\" alt=\"\"></p>\n<p>To calculate the total of values inside an area or, in the case of a hemisphere, a volume we use a mathematical construct called an integral denoted in the reflectance equation as $\\int$ over all incoming directions $d\\omega_i$ within the hemisphere $\\Omega$. An integral measures the area of a function, which can either be calculated <strong>analytically</strong> or <strong>numerically</strong>. As there is no analytical solution to both the render and reflectance equation we’ll want to numerically solve the integral discretely. This translates to taking the result of small discrete steps of the reflectance equation over the hemisphere $\\Omega$ and averaging their results over the step size.</p>\n<p>The reflectance equation sums up the radiance of all incoming light directions $\\omega_i$ over the hemisphere $\\Omega$ scaled by $f_r$ that hit point $p$ and returns the sum of reflected light $L_o$ in the viewer’s direction. The incoming radiance can come from light sources.</p>\n<p>Now the only unknown left is the $f_r$ symbol known as the <strong>BRDF</strong> or <strong>Bidirectional Reflective Distribution Function</strong> that scales or weighs the incoming radiance based on the surface’s material properties.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://learnopengl.com/PBR/Theory\" target=\"_blank\" rel=\"noopener\">Learn OpenGL PBR Theory</a> </strong></p>"},{"title":"Ray Tracing Overview","date":"2018-07-05T12:09:50.000Z","thumbnail":"http://hucoco.com/img/Graphics/RayTracing/RayTracing_1.png","_content":"\n## Overview\n\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_10.png)\n\nIn 3D compute graphics, ray tracing is rendering technique for generating an visual image by tracing the path of light. it has better effect than either ray casting and scan-line rendering techniques.\n\nTypically, there are two question need be deal:\n\n* What object has been seen?\n* What color of the object is under the influence of light and environment?\n\nIn nature, a ray will travel to a surface that stop ray traveling, or until out of energy eventually disappears.\nthere are four things might happen with light ray: **absorption**, **reflection**, **refraction**, **fluorescence**,\n\n<!--more-->\n\n### Ray Casting\n\nIn ancient time, it was used for the study of perspective.\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_2.png)\n\nThe first ray tracing algorithm used for rendering was presented by Arthur Appel in 1968.[1] This algorithm has since been termed \"ray casting\". The idea behind ray casting is to shoot rays from the eye, one per pixel, and find the closest object blocking the path of that ray. Think of an image as a screen-door, with each square in the screen being a pixel. This is then the object the eye sees through that pixel. Using the material properties and the effect of the lights in the scene, this algorithm can determine the shading of this object. The simplifying assumption is made that if a surface faces a light, the light will reach that surface and not be blocked or in shadow. The shading of the surface is computed using traditional 3D computer graphics shading models. One important advantage ray casting offered over older scanline algorithms was its ability to easily deal with non-planar surfaces and solids, such as cones and spheres. If a mathematical surface can be intersected by a ray, it can be rendered using ray casting. Elaborate objects can be created by using solid modeling techniques and easily rendered.\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_3.png)\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_4.png)\n\n### Ray Tracing\n\nit almost like ray casting, but in ray tracing, it will generate some new ray from the closet intersection point.\n\n* Reflection ray\n* Refraction ray\n* Shadow rays\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_5.png)\n\nand this technique also called Recursive Ray Tracing.\n\n#### Advantages\n\nRay tracing's popularity stems from its basis in a realistic simulation of lighting over other rendering methods (such as scanline rendering or ray casting). Effects such as reflections and shadows, which are difficult to simulate using other algorithms, are a natural result of the ray tracing algorithm. The computational independence of each ray makes ray tracing amenable to parallelization.\n\n#### Disadvantages\n\nA serious disadvantage of ray tracing is performance (though it can in theory be faster than traditional scanline rendering depending on scene complexity vs. number of pixels on-screen). Scanline algorithms and other algorithms use data coherence to share computations between pixels, while ray tracing normally starts the process anew, treating each eye ray separately. However, this separation offers other advantages, such as the ability to shoot more rays as needed to perform spatial anti-aliasing and improve image quality where needed.\n\nAlthough it does handle interreflection and optical effects such as refraction accurately, traditional ray tracing is also not necessarily photorealistic. True photorealism occurs when the rendering equation is closely approximated or fully implemented. Implementing the rendering equation gives true photorealism, as the equation describes every physical effect of light flow. However, this is usually infeasible given the computing resources required.\n\nThe realism of all rendering methods can be evaluated as an approximation to the equation. Ray tracing, if it is limited to Whitted's algorithm, is not necessarily the most realistic. Methods that trace rays, but include additional techniques (photon mapping, path tracing), give far more accurate simulation of real-world lighting.\n\n#### Ray Tracing Detail\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_6.png)\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_7.png)\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_8.png)\n\n#### Shadow\n\nAt each surface intersection point,a shadow ray is shot towards eachlight source to determine any occlusion between light source and surface point.\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_9.png)\n\n---\n\n## Reference\n\n**[Ray Tracing Wiki](https://en.wikipedia.org/wiki/Ray_tracing) **\n\n**[NUSRI Summer Programme 2016, 3D Graphics Rendering, Lecture 9 Ray Tracing, School of Computing National University of Singapore](http://hucoco.com/file/lec09_ray_tracing.pdf)**\n\n**[Learn OpenGL](https://learnopengl.com/) **","source":"_posts/Theory-of-Ray-Tracing.md","raw":"---\ntitle: Ray Tracing Overview\ndate: 2018-07-05 20:09:50\nthumbnail: http://hucoco.com/img/Graphics/RayTracing/RayTracing_1.png\ntags: \n- Graphics\n- Ray Tracing\ncategories:\n- Graphics\n- Ray Tracing\n---\n\n## Overview\n\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_10.png)\n\nIn 3D compute graphics, ray tracing is rendering technique for generating an visual image by tracing the path of light. it has better effect than either ray casting and scan-line rendering techniques.\n\nTypically, there are two question need be deal:\n\n* What object has been seen?\n* What color of the object is under the influence of light and environment?\n\nIn nature, a ray will travel to a surface that stop ray traveling, or until out of energy eventually disappears.\nthere are four things might happen with light ray: **absorption**, **reflection**, **refraction**, **fluorescence**,\n\n<!--more-->\n\n### Ray Casting\n\nIn ancient time, it was used for the study of perspective.\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_2.png)\n\nThe first ray tracing algorithm used for rendering was presented by Arthur Appel in 1968.[1] This algorithm has since been termed \"ray casting\". The idea behind ray casting is to shoot rays from the eye, one per pixel, and find the closest object blocking the path of that ray. Think of an image as a screen-door, with each square in the screen being a pixel. This is then the object the eye sees through that pixel. Using the material properties and the effect of the lights in the scene, this algorithm can determine the shading of this object. The simplifying assumption is made that if a surface faces a light, the light will reach that surface and not be blocked or in shadow. The shading of the surface is computed using traditional 3D computer graphics shading models. One important advantage ray casting offered over older scanline algorithms was its ability to easily deal with non-planar surfaces and solids, such as cones and spheres. If a mathematical surface can be intersected by a ray, it can be rendered using ray casting. Elaborate objects can be created by using solid modeling techniques and easily rendered.\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_3.png)\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_4.png)\n\n### Ray Tracing\n\nit almost like ray casting, but in ray tracing, it will generate some new ray from the closet intersection point.\n\n* Reflection ray\n* Refraction ray\n* Shadow rays\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_5.png)\n\nand this technique also called Recursive Ray Tracing.\n\n#### Advantages\n\nRay tracing's popularity stems from its basis in a realistic simulation of lighting over other rendering methods (such as scanline rendering or ray casting). Effects such as reflections and shadows, which are difficult to simulate using other algorithms, are a natural result of the ray tracing algorithm. The computational independence of each ray makes ray tracing amenable to parallelization.\n\n#### Disadvantages\n\nA serious disadvantage of ray tracing is performance (though it can in theory be faster than traditional scanline rendering depending on scene complexity vs. number of pixels on-screen). Scanline algorithms and other algorithms use data coherence to share computations between pixels, while ray tracing normally starts the process anew, treating each eye ray separately. However, this separation offers other advantages, such as the ability to shoot more rays as needed to perform spatial anti-aliasing and improve image quality where needed.\n\nAlthough it does handle interreflection and optical effects such as refraction accurately, traditional ray tracing is also not necessarily photorealistic. True photorealism occurs when the rendering equation is closely approximated or fully implemented. Implementing the rendering equation gives true photorealism, as the equation describes every physical effect of light flow. However, this is usually infeasible given the computing resources required.\n\nThe realism of all rendering methods can be evaluated as an approximation to the equation. Ray tracing, if it is limited to Whitted's algorithm, is not necessarily the most realistic. Methods that trace rays, but include additional techniques (photon mapping, path tracing), give far more accurate simulation of real-world lighting.\n\n#### Ray Tracing Detail\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_6.png)\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_7.png)\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_8.png)\n\n#### Shadow\n\nAt each surface intersection point,a shadow ray is shot towards eachlight source to determine any occlusion between light source and surface point.\n\n![](http://hucoco.com/img/Graphics/RayTracing/RayTracing_9.png)\n\n---\n\n## Reference\n\n**[Ray Tracing Wiki](https://en.wikipedia.org/wiki/Ray_tracing) **\n\n**[NUSRI Summer Programme 2016, 3D Graphics Rendering, Lecture 9 Ray Tracing, School of Computing National University of Singapore](http://hucoco.com/file/lec09_ray_tracing.pdf)**\n\n**[Learn OpenGL](https://learnopengl.com/) **","slug":"Theory-of-Ray-Tracing","published":1,"updated":"2018-07-10T07:28:00.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmyp36ul001jssb95uu3ff0d","content":"<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_10.png\" alt=\"\"></p>\n<p>In 3D compute graphics, ray tracing is rendering technique for generating an visual image by tracing the path of light. it has better effect than either ray casting and scan-line rendering techniques.</p>\n<p>Typically, there are two question need be deal:</p>\n<ul>\n<li>What object has been seen?</li>\n<li>What color of the object is under the influence of light and environment?</li>\n</ul>\n<p>In nature, a ray will travel to a surface that stop ray traveling, or until out of energy eventually disappears.<br>there are four things might happen with light ray: <strong>absorption</strong>, <strong>reflection</strong>, <strong>refraction</strong>, <strong>fluorescence</strong>,</p>\n<a id=\"more\"></a>\n<h3 id=\"Ray-Casting\"><a href=\"#Ray-Casting\" class=\"headerlink\" title=\"Ray Casting\"></a>Ray Casting</h3><p>In ancient time, it was used for the study of perspective.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_2.png\" alt=\"\"></p>\n<p>The first ray tracing algorithm used for rendering was presented by Arthur Appel in 1968.[1] This algorithm has since been termed “ray casting”. The idea behind ray casting is to shoot rays from the eye, one per pixel, and find the closest object blocking the path of that ray. Think of an image as a screen-door, with each square in the screen being a pixel. This is then the object the eye sees through that pixel. Using the material properties and the effect of the lights in the scene, this algorithm can determine the shading of this object. The simplifying assumption is made that if a surface faces a light, the light will reach that surface and not be blocked or in shadow. The shading of the surface is computed using traditional 3D computer graphics shading models. One important advantage ray casting offered over older scanline algorithms was its ability to easily deal with non-planar surfaces and solids, such as cones and spheres. If a mathematical surface can be intersected by a ray, it can be rendered using ray casting. Elaborate objects can be created by using solid modeling techniques and easily rendered.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_3.png\" alt=\"\"><br><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_4.png\" alt=\"\"></p>\n<h3 id=\"Ray-Tracing\"><a href=\"#Ray-Tracing\" class=\"headerlink\" title=\"Ray Tracing\"></a>Ray Tracing</h3><p>it almost like ray casting, but in ray tracing, it will generate some new ray from the closet intersection point.</p>\n<ul>\n<li>Reflection ray</li>\n<li>Refraction ray</li>\n<li>Shadow rays</li>\n</ul>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_5.png\" alt=\"\"></p>\n<p>and this technique also called Recursive Ray Tracing.</p>\n<h4 id=\"Advantages\"><a href=\"#Advantages\" class=\"headerlink\" title=\"Advantages\"></a>Advantages</h4><p>Ray tracing’s popularity stems from its basis in a realistic simulation of lighting over other rendering methods (such as scanline rendering or ray casting). Effects such as reflections and shadows, which are difficult to simulate using other algorithms, are a natural result of the ray tracing algorithm. The computational independence of each ray makes ray tracing amenable to parallelization.</p>\n<h4 id=\"Disadvantages\"><a href=\"#Disadvantages\" class=\"headerlink\" title=\"Disadvantages\"></a>Disadvantages</h4><p>A serious disadvantage of ray tracing is performance (though it can in theory be faster than traditional scanline rendering depending on scene complexity vs. number of pixels on-screen). Scanline algorithms and other algorithms use data coherence to share computations between pixels, while ray tracing normally starts the process anew, treating each eye ray separately. However, this separation offers other advantages, such as the ability to shoot more rays as needed to perform spatial anti-aliasing and improve image quality where needed.</p>\n<p>Although it does handle interreflection and optical effects such as refraction accurately, traditional ray tracing is also not necessarily photorealistic. True photorealism occurs when the rendering equation is closely approximated or fully implemented. Implementing the rendering equation gives true photorealism, as the equation describes every physical effect of light flow. However, this is usually infeasible given the computing resources required.</p>\n<p>The realism of all rendering methods can be evaluated as an approximation to the equation. Ray tracing, if it is limited to Whitted’s algorithm, is not necessarily the most realistic. Methods that trace rays, but include additional techniques (photon mapping, path tracing), give far more accurate simulation of real-world lighting.</p>\n<h4 id=\"Ray-Tracing-Detail\"><a href=\"#Ray-Tracing-Detail\" class=\"headerlink\" title=\"Ray Tracing Detail\"></a>Ray Tracing Detail</h4><p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_6.png\" alt=\"\"><br><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_7.png\" alt=\"\"><br><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_8.png\" alt=\"\"></p>\n<h4 id=\"Shadow\"><a href=\"#Shadow\" class=\"headerlink\" title=\"Shadow\"></a>Shadow</h4><p>At each surface intersection point,a shadow ray is shot towards eachlight source to determine any occlusion between light source and surface point.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_9.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://en.wikipedia.org/wiki/Ray_tracing\" target=\"_blank\" rel=\"noopener\">Ray Tracing Wiki</a> </strong></p>\n<p><strong><a href=\"http://hucoco.com/file/lec09_ray_tracing.pdf\">NUSRI Summer Programme 2016, 3D Graphics Rendering, Lecture 9 Ray Tracing, School of Computing National University of Singapore</a></strong></p>\n<p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_10.png\" alt=\"\"></p>\n<p>In 3D compute graphics, ray tracing is rendering technique for generating an visual image by tracing the path of light. it has better effect than either ray casting and scan-line rendering techniques.</p>\n<p>Typically, there are two question need be deal:</p>\n<ul>\n<li>What object has been seen?</li>\n<li>What color of the object is under the influence of light and environment?</li>\n</ul>\n<p>In nature, a ray will travel to a surface that stop ray traveling, or until out of energy eventually disappears.<br>there are four things might happen with light ray: <strong>absorption</strong>, <strong>reflection</strong>, <strong>refraction</strong>, <strong>fluorescence</strong>,</p>","more":"<h3 id=\"Ray-Casting\"><a href=\"#Ray-Casting\" class=\"headerlink\" title=\"Ray Casting\"></a>Ray Casting</h3><p>In ancient time, it was used for the study of perspective.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_2.png\" alt=\"\"></p>\n<p>The first ray tracing algorithm used for rendering was presented by Arthur Appel in 1968.[1] This algorithm has since been termed “ray casting”. The idea behind ray casting is to shoot rays from the eye, one per pixel, and find the closest object blocking the path of that ray. Think of an image as a screen-door, with each square in the screen being a pixel. This is then the object the eye sees through that pixel. Using the material properties and the effect of the lights in the scene, this algorithm can determine the shading of this object. The simplifying assumption is made that if a surface faces a light, the light will reach that surface and not be blocked or in shadow. The shading of the surface is computed using traditional 3D computer graphics shading models. One important advantage ray casting offered over older scanline algorithms was its ability to easily deal with non-planar surfaces and solids, such as cones and spheres. If a mathematical surface can be intersected by a ray, it can be rendered using ray casting. Elaborate objects can be created by using solid modeling techniques and easily rendered.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_3.png\" alt=\"\"><br><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_4.png\" alt=\"\"></p>\n<h3 id=\"Ray-Tracing\"><a href=\"#Ray-Tracing\" class=\"headerlink\" title=\"Ray Tracing\"></a>Ray Tracing</h3><p>it almost like ray casting, but in ray tracing, it will generate some new ray from the closet intersection point.</p>\n<ul>\n<li>Reflection ray</li>\n<li>Refraction ray</li>\n<li>Shadow rays</li>\n</ul>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_5.png\" alt=\"\"></p>\n<p>and this technique also called Recursive Ray Tracing.</p>\n<h4 id=\"Advantages\"><a href=\"#Advantages\" class=\"headerlink\" title=\"Advantages\"></a>Advantages</h4><p>Ray tracing’s popularity stems from its basis in a realistic simulation of lighting over other rendering methods (such as scanline rendering or ray casting). Effects such as reflections and shadows, which are difficult to simulate using other algorithms, are a natural result of the ray tracing algorithm. The computational independence of each ray makes ray tracing amenable to parallelization.</p>\n<h4 id=\"Disadvantages\"><a href=\"#Disadvantages\" class=\"headerlink\" title=\"Disadvantages\"></a>Disadvantages</h4><p>A serious disadvantage of ray tracing is performance (though it can in theory be faster than traditional scanline rendering depending on scene complexity vs. number of pixels on-screen). Scanline algorithms and other algorithms use data coherence to share computations between pixels, while ray tracing normally starts the process anew, treating each eye ray separately. However, this separation offers other advantages, such as the ability to shoot more rays as needed to perform spatial anti-aliasing and improve image quality where needed.</p>\n<p>Although it does handle interreflection and optical effects such as refraction accurately, traditional ray tracing is also not necessarily photorealistic. True photorealism occurs when the rendering equation is closely approximated or fully implemented. Implementing the rendering equation gives true photorealism, as the equation describes every physical effect of light flow. However, this is usually infeasible given the computing resources required.</p>\n<p>The realism of all rendering methods can be evaluated as an approximation to the equation. Ray tracing, if it is limited to Whitted’s algorithm, is not necessarily the most realistic. Methods that trace rays, but include additional techniques (photon mapping, path tracing), give far more accurate simulation of real-world lighting.</p>\n<h4 id=\"Ray-Tracing-Detail\"><a href=\"#Ray-Tracing-Detail\" class=\"headerlink\" title=\"Ray Tracing Detail\"></a>Ray Tracing Detail</h4><p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_6.png\" alt=\"\"><br><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_7.png\" alt=\"\"><br><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_8.png\" alt=\"\"></p>\n<h4 id=\"Shadow\"><a href=\"#Shadow\" class=\"headerlink\" title=\"Shadow\"></a>Shadow</h4><p>At each surface intersection point,a shadow ray is shot towards eachlight source to determine any occlusion between light source and surface point.</p>\n<p><img src=\"http://hucoco.com/img/Graphics/RayTracing/RayTracing_9.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><strong><a href=\"https://en.wikipedia.org/wiki/Ray_tracing\" target=\"_blank\" rel=\"noopener\">Ray Tracing Wiki</a> </strong></p>\n<p><strong><a href=\"http://hucoco.com/file/lec09_ray_tracing.pdf\">NUSRI Summer Programme 2016, 3D Graphics Rendering, Lecture 9 Ray Tracing, School of Computing National University of Singapore</a></strong></p>\n<p><strong><a href=\"https://learnopengl.com/\" target=\"_blank\" rel=\"noopener\">Learn OpenGL</a> </strong></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjmyp36ti0000ssb9stwd6acs","category_id":"cjmyp36to0003ssb99eiuuntv","_id":"cjmyp36ua000wssb9bq0avoli"},{"post_id":"cjmyp36ti0000ssb9stwd6acs","category_id":"cjmyp36u3000mssb95frocty9","_id":"cjmyp36uc0010ssb9xhc1dfs1"},{"post_id":"cjmyp36tt0007ssb9wnftbuvc","category_id":"cjmyp36to0003ssb99eiuuntv","_id":"cjmyp36ud0013ssb9a3xakd7r"},{"post_id":"cjmyp36tt0007ssb9wnftbuvc","category_id":"cjmyp36u3000mssb95frocty9","_id":"cjmyp36uf0018ssb9tggwhxjm"},{"post_id":"cjmyp36tu000assb9g71t9075","category_id":"cjmyp36tt0008ssb9cnqtx5p2","_id":"cjmyp36ui001dssb99solg59m"},{"post_id":"cjmyp36tu000assb9g71t9075","category_id":"cjmyp36ua000vssb9l62vaqzf","_id":"cjmyp36uk001gssb9sxbed1gv"},{"post_id":"cjmyp36tn0002ssb90oto3efv","category_id":"cjmyp36tt0008ssb9cnqtx5p2","_id":"cjmyp36un001lssb9piso0pqx"},{"post_id":"cjmyp36tn0002ssb90oto3efv","category_id":"cjmyp36ua000vssb9l62vaqzf","_id":"cjmyp36uo001nssb9vi2tvwyq"},{"post_id":"cjmyp36tq0005ssb9t2ldbzkd","category_id":"cjmyp36to0003ssb99eiuuntv","_id":"cjmyp36ur001wssb922af4snm"},{"post_id":"cjmyp36tq0005ssb9t2ldbzkd","category_id":"cjmyp36u3000mssb95frocty9","_id":"cjmyp36us0020ssb9h9bqr5d2"},{"post_id":"cjmyp36tz000fssb9h0o7qchd","category_id":"cjmyp36tt0008ssb9cnqtx5p2","_id":"cjmyp36ut0021ssb9km4m0ahb"},{"post_id":"cjmyp36tz000fssb9h0o7qchd","category_id":"cjmyp36uq001tssb9lo1n28e7","_id":"cjmyp36uu0025ssb9mop98l7a"},{"post_id":"cjmyp36u1000issb9bss8z7u4","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36uu0028ssb9au6gmzf7"},{"post_id":"cjmyp36u1000issb9bss8z7u4","category_id":"cjmyp36us001yssb98afd4xuh","_id":"cjmyp36uv002bssb9uutgxu2s"},{"post_id":"cjmyp36tr0006ssb9ouvkeetm","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36uw002essb9u2yu4b31"},{"post_id":"cjmyp36tr0006ssb9ouvkeetm","category_id":"cjmyp36ut0023ssb9krm6kx33","_id":"cjmyp36ux002gssb9qxkvm5uw"},{"post_id":"cjmyp36u2000kssb9n1d3cgan","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36ux002kssb9969yo6db"},{"post_id":"cjmyp36u2000kssb9n1d3cgan","category_id":"cjmyp36ut0023ssb9krm6kx33","_id":"cjmyp36uy002mssb9db3r1pc4"},{"post_id":"cjmyp36u4000ossb9scg34cru","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36uz002ossb904in2tvz"},{"post_id":"cjmyp36u4000ossb9scg34cru","category_id":"cjmyp36us001yssb98afd4xuh","_id":"cjmyp36v0002rssb99eo57naj"},{"post_id":"cjmyp36u5000qssb9yf5eceol","category_id":"cjmyp36to0003ssb99eiuuntv","_id":"cjmyp36v1002vssb9hfzrfijh"},{"post_id":"cjmyp36u5000qssb9yf5eceol","category_id":"cjmyp36ux002jssb9hzp08a3i","_id":"cjmyp36v2002wssb9dxre6uk2"},{"post_id":"cjmyp36u7000tssb9r9vaokro","category_id":"cjmyp36to0003ssb99eiuuntv","_id":"cjmyp36v3002zssb96yxde0ow"},{"post_id":"cjmyp36u7000tssb9r9vaokro","category_id":"cjmyp36ux002jssb9hzp08a3i","_id":"cjmyp36v40031ssb9wyrsgg51"},{"post_id":"cjmyp36u9000ussb9mfuznqcg","category_id":"cjmyp36to0003ssb99eiuuntv","_id":"cjmyp36v50034ssb99jiglq2h"},{"post_id":"cjmyp36u9000ussb9mfuznqcg","category_id":"cjmyp36ux002jssb9hzp08a3i","_id":"cjmyp36v50036ssb9059z0dtu"},{"post_id":"cjmyp36uc0011ssb97y60h5a5","category_id":"cjmyp36tt0008ssb9cnqtx5p2","_id":"cjmyp36v7003dssb9vgp2m3al"},{"post_id":"cjmyp36uc0011ssb97y60h5a5","category_id":"cjmyp36v50035ssb9irmgvpqk","_id":"cjmyp36v8003fssb9xjqo8luc"},{"post_id":"cjmyp36ud0015ssb9cibm6ndn","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36v9003issb9ezoxo8o7"},{"post_id":"cjmyp36ud0015ssb9cibm6ndn","category_id":"cjmyp36ut0023ssb9krm6kx33","_id":"cjmyp36v9003kssb9xnuza1fb"},{"post_id":"cjmyp36uf0019ssb9ow0wveuw","category_id":"cjmyp36tt0008ssb9cnqtx5p2","_id":"cjmyp36vb003ossb97g8jtoc0"},{"post_id":"cjmyp36uf0019ssb9ow0wveuw","category_id":"cjmyp36v50035ssb9irmgvpqk","_id":"cjmyp36vb003pssb9n0rmwzsb"},{"post_id":"cjmyp36uh001bssb93f8otiof","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36vc003sssb9znt5b848"},{"post_id":"cjmyp36uh001bssb93f8otiof","category_id":"cjmyp36us001yssb98afd4xuh","_id":"cjmyp36vd003ussb9i1gyd63v"},{"post_id":"cjmyp36uj001fssb9ok7vhzsi","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36ve003yssb9z5rt9ot7"},{"post_id":"cjmyp36uj001fssb9ok7vhzsi","category_id":"cjmyp36ut0023ssb9krm6kx33","_id":"cjmyp36ve003zssb9c6p1817h"},{"post_id":"cjmyp36tv000bssb9ox92ry7y","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36vf0042ssb9gn8nia20"},{"post_id":"cjmyp36tv000bssb9ox92ry7y","category_id":"cjmyp36us001yssb98afd4xuh","_id":"cjmyp36vf0044ssb9nqmfxhd7"},{"post_id":"cjmyp36ul001jssb95uu3ff0d","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36vh0048ssb9w76oz3de"},{"post_id":"cjmyp36ul001jssb95uu3ff0d","category_id":"cjmyp36us001yssb98afd4xuh","_id":"cjmyp36vi004assb95f46f0yz"},{"post_id":"cjmyp36tx000essb97d9ne8wp","category_id":"cjmyp36u0000gssb90nhbobhc","_id":"cjmyp36vj004dssb9yupcpp08"},{"post_id":"cjmyp36tx000essb97d9ne8wp","category_id":"cjmyp36us001yssb98afd4xuh","_id":"cjmyp36vk004fssb9a594aale"},{"post_id":"cjmyp36ua000yssb9nwmnt33b","category_id":"cjmyp36v3002yssb9j9q3givm","_id":"cjmyp36vl004issb9jxq43du1"},{"post_id":"cjmyp36ua000yssb9nwmnt33b","category_id":"cjmyp36vg0047ssb94f2gq7r3","_id":"cjmyp36vl004kssb9xb9ddnt5"}],"PostTag":[{"post_id":"cjmyp36ti0000ssb9stwd6acs","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36u2000jssb9er4fx9h7"},{"post_id":"cjmyp36ti0000ssb9stwd6acs","tag_id":"cjmyp36tu0009ssb9hyvo2q4a","_id":"cjmyp36u3000lssb9zwd3i5ya"},{"post_id":"cjmyp36ti0000ssb9stwd6acs","tag_id":"cjmyp36tw000dssb92yqb1qf2","_id":"cjmyp36u5000pssb9oqhg16s9"},{"post_id":"cjmyp36tn0002ssb90oto3efv","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36ub000zssb9a5gpkvwp"},{"post_id":"cjmyp36tn0002ssb90oto3efv","tag_id":"cjmyp36u4000nssb9uq40w5zv","_id":"cjmyp36ud0012ssb9y6kitbis"},{"post_id":"cjmyp36tn0002ssb90oto3efv","tag_id":"cjmyp36tw000dssb92yqb1qf2","_id":"cjmyp36uf0017ssb907a4pov2"},{"post_id":"cjmyp36uf0019ssb9ow0wveuw","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36ui001essb9jj42ampb"},{"post_id":"cjmyp36uf0019ssb9ow0wveuw","tag_id":"cjmyp36u4000nssb9uq40w5zv","_id":"cjmyp36uk001hssb9115rqywr"},{"post_id":"cjmyp36uf0019ssb9ow0wveuw","tag_id":"cjmyp36tw000dssb92yqb1qf2","_id":"cjmyp36uo001mssb98iov7dhk"},{"post_id":"cjmyp36tq0005ssb9t2ldbzkd","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36up001ossb9oxbojat0"},{"post_id":"cjmyp36tq0005ssb9t2ldbzkd","tag_id":"cjmyp36tu0009ssb9hyvo2q4a","_id":"cjmyp36uq001rssb90gqsoy43"},{"post_id":"cjmyp36tq0005ssb9t2ldbzkd","tag_id":"cjmyp36tw000dssb92yqb1qf2","_id":"cjmyp36uq001sssb9wpdpzbmr"},{"post_id":"cjmyp36tr0006ssb9ouvkeetm","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36ur001vssb9foeth89f"},{"post_id":"cjmyp36tr0006ssb9ouvkeetm","tag_id":"cjmyp36up001qssb9tqvrx72w","_id":"cjmyp36ur001xssb9c71p7fvi"},{"post_id":"cjmyp36tt0007ssb9wnftbuvc","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36ut0024ssb9srej4uhx"},{"post_id":"cjmyp36tt0007ssb9wnftbuvc","tag_id":"cjmyp36tu0009ssb9hyvo2q4a","_id":"cjmyp36uu0026ssb9qkc9qkhe"},{"post_id":"cjmyp36tt0007ssb9wnftbuvc","tag_id":"cjmyp36tw000dssb92yqb1qf2","_id":"cjmyp36uv002assb99i835x2y"},{"post_id":"cjmyp36tu000assb9g71t9075","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36uw002fssb97eeu1esi"},{"post_id":"cjmyp36tu000assb9g71t9075","tag_id":"cjmyp36u4000nssb9uq40w5zv","_id":"cjmyp36ux002hssb9rxz02wbd"},{"post_id":"cjmyp36tu000assb9g71t9075","tag_id":"cjmyp36tw000dssb92yqb1qf2","_id":"cjmyp36uy002lssb9yxak091p"},{"post_id":"cjmyp36tv000bssb9ox92ry7y","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36uz002qssb9giy31p95"},{"post_id":"cjmyp36tv000bssb9ox92ry7y","tag_id":"cjmyp36ux002issb9orzbna5z","_id":"cjmyp36v0002sssb97gcmqkoo"},{"post_id":"cjmyp36tx000essb97d9ne8wp","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36v40030ssb9zuy7kpfh"},{"post_id":"cjmyp36tx000essb97d9ne8wp","tag_id":"cjmyp36ux002issb9orzbna5z","_id":"cjmyp36v40032ssb9ynf4e794"},{"post_id":"cjmyp36tz000fssb9h0o7qchd","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36v60039ssb9l3u19yrf"},{"post_id":"cjmyp36tz000fssb9h0o7qchd","tag_id":"cjmyp36u4000nssb9uq40w5zv","_id":"cjmyp36v6003assb9hn229lwc"},{"post_id":"cjmyp36tz000fssb9h0o7qchd","tag_id":"cjmyp36v40033ssb98k0pz6d5","_id":"cjmyp36v7003essb9bmdn91zo"},{"post_id":"cjmyp36u1000issb9bss8z7u4","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36v9003jssb9a45yuxap"},{"post_id":"cjmyp36u1000issb9bss8z7u4","tag_id":"cjmyp36ux002issb9orzbna5z","_id":"cjmyp36va003lssb9zwwunh5f"},{"post_id":"cjmyp36u2000kssb9n1d3cgan","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36vc003tssb9pfa325gn"},{"post_id":"cjmyp36u2000kssb9n1d3cgan","tag_id":"cjmyp36up001qssb9tqvrx72w","_id":"cjmyp36vd003vssb9gl6o9jvv"},{"post_id":"cjmyp36u4000ossb9scg34cru","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36vf0043ssb99pv6cgb6"},{"post_id":"cjmyp36u4000ossb9scg34cru","tag_id":"cjmyp36ux002issb9orzbna5z","_id":"cjmyp36vg0045ssb946aqbbd7"},{"post_id":"cjmyp36u5000qssb9yf5eceol","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36vi0049ssb9gn1fxbfx"},{"post_id":"cjmyp36u5000qssb9yf5eceol","tag_id":"cjmyp36tu0009ssb9hyvo2q4a","_id":"cjmyp36vi004bssb9ex8dlq7i"},{"post_id":"cjmyp36u5000qssb9yf5eceol","tag_id":"cjmyp36ve0040ssb9it0u128s","_id":"cjmyp36vj004essb9b54a1yg0"},{"post_id":"cjmyp36u7000tssb9r9vaokro","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36vk004gssb9h89fnyb2"},{"post_id":"cjmyp36u7000tssb9r9vaokro","tag_id":"cjmyp36tu0009ssb9hyvo2q4a","_id":"cjmyp36vl004jssb98hmg1owz"},{"post_id":"cjmyp36u7000tssb9r9vaokro","tag_id":"cjmyp36ve0040ssb9it0u128s","_id":"cjmyp36vm004lssb9g9tfl3ix"},{"post_id":"cjmyp36u9000ussb9mfuznqcg","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36vm004nssb981hsnvpj"},{"post_id":"cjmyp36u9000ussb9mfuznqcg","tag_id":"cjmyp36tu0009ssb9hyvo2q4a","_id":"cjmyp36vm004ossb99m9i7an9"},{"post_id":"cjmyp36u9000ussb9mfuznqcg","tag_id":"cjmyp36ve0040ssb9it0u128s","_id":"cjmyp36vn004qssb9to9l9id5"},{"post_id":"cjmyp36ua000yssb9nwmnt33b","tag_id":"cjmyp36tq0004ssb9asiwut9x","_id":"cjmyp36vn004rssb99x6n4jja"},{"post_id":"cjmyp36ua000yssb9nwmnt33b","tag_id":"cjmyp36vk004hssb9nzi82zdo","_id":"cjmyp36vo004tssb9mfi60zn0"},{"post_id":"cjmyp36ua000yssb9nwmnt33b","tag_id":"cjmyp36vm004mssb9a7ow624r","_id":"cjmyp36vo004ussb998crn9jl"},{"post_id":"cjmyp36uc0011ssb97y60h5a5","tag_id":"cjmyp36vn004pssb9u5kndb01","_id":"cjmyp36vp004wssb9wzaacnq0"},{"post_id":"cjmyp36uc0011ssb97y60h5a5","tag_id":"cjmyp36u4000nssb9uq40w5zv","_id":"cjmyp36vp004xssb90j1hnv1i"},{"post_id":"cjmyp36uc0011ssb97y60h5a5","tag_id":"cjmyp36vn004sssb9u03f41rp","_id":"cjmyp36vp004zssb9d624xnw3"},{"post_id":"cjmyp36ud0015ssb9cibm6ndn","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36vq0051ssb9kl19dmb9"},{"post_id":"cjmyp36ud0015ssb9cibm6ndn","tag_id":"cjmyp36up001qssb9tqvrx72w","_id":"cjmyp36vq0052ssb9v0lme4f3"},{"post_id":"cjmyp36uh001bssb93f8otiof","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36vr0055ssb9vd37ek6t"},{"post_id":"cjmyp36uh001bssb93f8otiof","tag_id":"cjmyp36ux002issb9orzbna5z","_id":"cjmyp36vr0056ssb9fe9c46zn"},{"post_id":"cjmyp36uj001fssb9ok7vhzsi","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36vs0059ssb93fqyevu6"},{"post_id":"cjmyp36uj001fssb9ok7vhzsi","tag_id":"cjmyp36up001qssb9tqvrx72w","_id":"cjmyp36vt005assb9sfcewv3k"},{"post_id":"cjmyp36ul001jssb95uu3ff0d","tag_id":"cjmyp36uk001issb92lwk9chw","_id":"cjmyp36vt005cssb9r7ajabke"},{"post_id":"cjmyp36ul001jssb95uu3ff0d","tag_id":"cjmyp36ux002issb9orzbna5z","_id":"cjmyp36vt005dssb9lif28bb4"}],"Tag":[{"name":"C++","_id":"cjmyp36tq0004ssb9asiwut9x"},{"name":"Data Structure","_id":"cjmyp36tu0009ssb9hyvo2q4a"},{"name":"Graph","_id":"cjmyp36tw000dssb92yqb1qf2"},{"name":"Algorithm","_id":"cjmyp36u4000nssb9uq40w5zv"},{"name":"Graphics","_id":"cjmyp36uk001issb92lwk9chw"},{"name":"PBR","_id":"cjmyp36up001qssb9tqvrx72w"},{"name":"Ray Tracing","_id":"cjmyp36ux002issb9orzbna5z"},{"name":"Backtracking","_id":"cjmyp36v40033ssb98k0pz6d5"},{"name":"Tree","_id":"cjmyp36ve0040ssb9it0u128s"},{"name":"SIMD","_id":"cjmyp36vk004hssb9nzi82zdo"},{"name":"SSE","_id":"cjmyp36vm004mssb9a7ow624r"},{"name":"Python","_id":"cjmyp36vn004pssb9u5kndb01"},{"name":"Sort","_id":"cjmyp36vn004sssb9u03f41rp"}]}}